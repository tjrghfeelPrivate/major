<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>major page</title>
	<style>
		button{
			font-size:0.7vw;
			font-weight:bolder;
			background-color:#555555;
			color:white;
			border:0px solid black;
			border-radius:7px;
			margin-left:0.5vw;
			padding:0.1vw 0.5vw;
		}
		pre{
			margin:0px auto;
		}
		img{
			height:300px;
		}
	</style>
</head>
<body><!---->
	<button id="showAll">모두 펼치기</button><br><br>

	<br>컴퓨터 기본 <button>더보기</button>
	<pre>
		ㅇ 컴파일 언어, 인터프리터 언어<button>더보기</button>
		<pre>
			ㅡ 컴파일 언어 )
				ㄴ 컴파일러에 의해 소스코드가 기계어로 번역이 되어 이를 저장해두었다가 실행시키는 언어를 컴파일언어라 한다.
				ㄴ
				ㄴ ex) c, java ...
			ㅡ 인터프리터 언어 )
				ㄴ 프로그램이 실행될때 소스코드가 인터프리터에 의해 번역이 되면서 바로 실행되는 언어를 인터프리터 언어라 한다.
				ㄴ javascript, html, 파이선, ruby ...
				ㄴ 스크립트
		</pre>

		ㅡ 컴파일, 링크, 로드?
			ㄴ machine code
				ㄴ ??? cpu를 직접적으로 조작하는 명령어들로 이루어진 저수준 프로그래밍 언어?
			ㄴ lexical analysis, 어휘 분석
				ㄴ 프로그램, 웹페이지 등에 있는 문자열을 일련의 lexical token으로 변환하는 것.
				ㄴ lexical token이란 특정한 의미가 할당된 문자열. (토큰의 카테고리, 토큰값) 쌍으로 이루어짐.
				ㄴ 토큰 카테고리 목록
					ㄴ identifier. 프로그램 언어의 엔터티에 이름이 붙은 것. 언어의 엔터티는 변수, 데이터 타입, 라벨, 모듈 등이 포함.
						간단하게 프로그램 언어에서 사용자가 정의하는 이름들을 의미?
					ㄴ keyword. 프로그램 언어에서의 예약어들. if, return 등.
					ㄴ separator. 데이터, 문자열, 수학표현식 등의 안에서 분리된 영역, 독립된 영역의 경계을 나타내기 위해 사용되는
						하나 이상의 문자로 이루어진  문자열. ( ), { }, “ ”, csv의 컴마 등.
					ㄴ operator. 프로그래밍 언어에서 사용되는 연산자. +,* 등.
					ㄴ literal. 프로그래밍 언어의 리터럴
					ㄴ comment. 프로그래밍 언어의 주석.
			ㄴ Object code
				ㄴ 컴파일러에 의해 생성된 기계어.
				ㄴ 컴파일러의 목표 결과물이라 하여 'object' code.
			ㄴ Object file
				ㄴ object code를 포함하고 있는 파일.
				ㄴ 컴파일러나 어셈블러가 생성.
			ㄴ Linker
				ㄴ 컴퓨터 시스템 프로그램의 일종.
				ㄴ 하나 이상의 object file을 결합하여 하나의 실행파일(executable), 라이브러리 파일, object file을 만듦.
			ㄴ Linking
				ㄴ 여러 코드, 데이터를 모아 결합하여 load(메모리로 복사)되고 실행될 수 있는 하나의 실행 파일을 만드는 과정.
				ㄴ compile시, load시, runtime시에 수행 가능.
				ㄴ 과거엔 수작업으로 linking을 진행하였으나 현대엔 'linker'라는 프로그램을 사용하여 수행.
				ㄴ 장점, 의의
					ㄴ 모듈별로 분리하여 컴파일이 가능함으로서, 하나의 거대한 파일이 아닌 관리하기 쉬운 작은 단위의 파일들로서 사용 가능.
						특정 모듈 수행시 그 모듈만 재컴파일하고 다시 링킹만 하면 되는 등.
				ㄴ 작은 프로그램 개발시엔 큰 문제 없으나, 규모가 커질 경우 링킹과 관련된 이슈들이 발생.
					해결을 위해 링킹에 대한 이해가 필요.

			ㄴ Compiler Driver
				ㄴ preprocessor, compiler, assembler, linker를 호출하여 컴파일을 진행하는 컴포넌트.

		ㅇ statically typed language vs dynamically typed language<button>더보기</button>
		<pre>
			ㅡ statically typed )
				ㄴ 변수의 타입을 컴파일 시점에 알 수 있는 언어. java, c, c++ 등
			ㅡ dynamically typed )
				ㄴ 변수의 타입을 실행 시점에 알 수 있는 언어. js, python 등
				ㄴ 대부분의 스크립트 언어가 여기에 속한다. 컴파일러가 따로 없기때문.
					ㄴ 때문에, 인터프리터가 변수의 타입을 잘못 해석하여 버그가 발생하기는 하지만
					ㄴ 스크립트 언어는 규모가 크지않은 경우가 많기때문에 크게 문제가 되지 않는다.
		</pre>

		ㅇ WebDriver<button>더보기</button>
		<pre>
			ㅡ https://w3c.github.io/webdriver/webdriver-spec.html
			ㅡ w3c의 표준에는 'WebDriver'란 user agent(브라우저, 폰 등)을 컨트롤할 수 있게 해주는 'remote-control interface'라고 정의하고있다.
				ㄴ 브라우저를 클릭하거나 등.
				ㄴ 이런것들을 통하여 테스트를 자동화 하는듯함.
			ㅡ 웹 문서의 dom요소를 찾거나 조작하거나 user agent의 동작을 컨트롤하는 여러 인터페이스들을 제공.
			ㅡ 일반적으로 각 브라우저 밴더들이 표준에 맞게 구현하여 제공하고 있다고한다.
				ㄴ ex) chrome의 'Google chrome driver', 파이어폭스의 'geckodriver' 등
		</pre>

		ㅇ curl<button>more</button>
		<pre>

		</pre>

		ㅇ Sequence diagram<button>more</button>
		<pre>
			ㅡ 시간순으로 객체 사이의 상호작용을 다이어그램 형식으로 그린 것.
				ㄴ 객체 사이의 메세지 전달과 시나리오를 평행하는 수직선으로 표현한다.
			ㅡ 'event diagram', 'event scenarios'라고도 불린다.
			<img src="image/sequence_diagram.png" height="550"/>
			ㅡ 형식 )
				ㄴ 맨 위에 객체들이 존재
				ㄴ 각 객체 아래로 'lifeline'이 하나씩 존재. 아래로 갈 수록 시간이 지남을 나타낸다.
				ㄴ 'lifeline'에서 화살표를 다른 객체의 'lifeline'으로 연결하면서 객체간 '메시지' 상호작용을 나타낸다.
					ㄴ 채워진 화살표는 '동기'메시지를 의미, 점 화살표는 '비동기'메시지를 의미.
		</pre>

		ㅇ os (공룡책) <button>more</button>
		<pre>
			ㅡ ~~~~~

			ㅡ 18. 가상 머신, virtual machine<button>more</button>
			<pre>
				ㄴ 하드웨어(cpu, 디스크, 메모리, 네트워크 등)를 추상화하여 한 컴퓨터에서 여러 개의 분리된 환경이 돌아가는 것처럼
					보이게 하는 것.

			</pre>

			ㅡ 무제<button>more</button>
			<pre>
				ㄴ corn
					ㄴ unix-like os의 스케줄러
			</pre>
		</pre>

        ㅇ 가상화<button>more</button>
        <pre>
            ㅡ ~~~
            ㅡ hardware virtualization
                ㄴ = platform virtualization, server virtualization
                ㄴ hypervisor에 의해 host의 hardware에서 가상화가 수행된다.
                    가상의 컴퓨터 환경(virtual machine)을 만들어 낸다.
                ㄴ VM에서 돌아가는 소프트웨어들은 실제 하드웨어 위에서 돌아가는 것과 거의 동일하다.
                ㄴ 네트워크, display, keyboard, disk 등 물리적 시스템 자원에 대한 접근만 약간의 제한.
                ㄴ hypervisor 실행을 위한 리소스, VM에서의 감소된 리소스로 인해 성능 저하 경향 큼.
                ㄴ 사용 이유
                    ㄴ 서버 통합시,
                        작은 여러 서버들을 큰 하나의 서버로 통합하여 cpu, hard drive 등의 하드웨어 비용을 줄임.
                        ??? 하드웨어는 가상환경으로 통합되나, os는 그렇지 못하므로 이때 VM..?
                    ㄴ

            ㅡ virtual machine, VM
                ㄴ ~~~
                ㄴ system virtual machine
                    ㄴ full virtualization 라고도 함.
                    ㄴ 완전한 컴퓨터 시스템 전체, 완전한 os의 실행을 제공하는 가상 머신.
                    ㄴ ??? 기존의 아키텍처를 'emulate' 한다.
                    ㄴ 실제 하드웨어에서 사용할 수 없는 프로그램을 실행할 플랫폼을 제공
                    ㄴ 컴퓨터 자원을 효율적으로 활용하기 위해 여러 개의 가상 머신을 가지는 데 사용.

                    ㄴ hypervisor가 'machine code'를 이용하여 하드웨어를 공유 및 관리하여
                        하나의 물리 machine 위에서 서로 독립된 여러개의 환경이 존재하도록 한다.
                ㄴ process virtual machine
                    ㄴ

            ㅡ OS-level virtualization, os 가상화
                ㄴ 커널이 여러개의 고립된 'user space'의 존재를 허용하는 os 패러다임?
                    ㄴ 'user space'
                        ㄴ os에서 가상 메모리는 보통 'user space'와 'kernel space'로 나뉨.
                        ㄴ user space는 어플이나 드라이버가 실행되는 공간,
                            kernel space는 os kerner, device 드라이버 등이 실행되는 공간.
                        ㄴ 악성 소프트웨어로부터 메모리와 하드웨어를 보호하기 위함.
                    ㄴ user space 호칭
                        ㄴ container : LXC, Solaris containers, Docker, Podman
                        ㄴ zones : Solaris containers
                        ㄴ virtual private servers : OpenVZ
                        ㄴ 등등..
                ㄴ 컴퓨터의 리소스 중 일부만이 할당된다.
                ㄴ 여러개가 존재할 수 있다.
                ㄴ 컨테이너 안에서 돌아가는 프로그램의 관점에선, 일반 os와 다를게 없다.
				ㄴ container engine (컨테이너 엔진)
					ㄴ ex ) docker engine, RKT, CRI-O, LXD
					ㄴ CLI 등으로 유저의 요청을 받아 컨테이너 관련 작업을 하는 소프트웨어.
						image를 pull하거나 등등의 작업 수행.
					ㄴ OCI표준을 따르는 image를 사용하여 동작?
				ㄴ container runtime
					ㄴ 컨테이너 엔진으로부터 필요한 정보를 받아 실질적으로 컨테이너를 실행하는 컴포넌트.
					ㄴ OCI의 표준 구현체는 'runc'. 그 외에도 crun, railcar 등의 다른 컨테이너 런타임도 존재.
					ㄴ 리눅스 커널과 실질적으로 상호작용하여 컨테이너 실행.
					ㄴ 컨테이너의 cgroup, selinux 설정 등도 맡음.
					ㄴ 도커 초기에 LXC가 컨테이너 런타임으로서 컨테이너를 실행. 후에 도커에서 libcontainer라는 라이브러리를 만들어 사용.
						더 이후, OCI 등장때 도커에서 이 lib을 기부, 이를 기반으로 runc 탄생했다함.
				ㄴ OCI (Open Container Initiative)
					ㄴ os-level 가상화 (특히, 리눅스 컨테이너)에 대한 표준.
					ㄴ https://opencontainers.org
					ㄴ container image 형식에 대한 표준, container runtime에 대한 표준 등이 있다.
					ㄴ ~~~

			클라우드 컴퓨팅<button>more</button>
			<pre>
				ㅡ ~~~
				ㅡ 서비스 모델
					ㄴ NIST에서 정한 세가지 표준 모델 존재.
						IaaS, Infrastructure as a service
						PaaS, Platform as a service
						SaaS, Software as a service
						ㄴ ??? 아래로 갈 수록 추상화 수준이 높아짐.
					ㄴ IaaS
						ㄴ infrastructure as a service.
							ㄴ infrastructure, 즉, 컴퓨터 하부 구조를 서비스로 제공하는 것???
						ㄴ vendor가 저장소, 네트워크, 서버, 가상화(하드웨어 emulatation)을 제공.
						ㄴ 이러한 리소스를 public cloud, private cloud 또는 이 둘의 혼합형 cloud를 통하여 제공한다.
						ㄴ ??? 네트워크 구조, 데이터 파티션, 보안, 스케일링, 물리적 컴퓨터 리소스 등 여러가지 low-level 상세 정보를
							high-level api를 통하여 유저가 양방향 참조할 수 있게 해준다?
						ㄴ ??? cloud os 안에 있는 hypervisor들로 수 많은 가상 머신들과 이들의 스케일링 조절이 가능하다.
						ㄴ OpenStack, Apache CloudStack, OpenNebula 등의 '클라우드 컴퓨팅 관련 기술'(??? cloud orchestration technology)을 사용한다.
							ㄴ vm의 생성, hypervisor 결정 ~~~ 등등의 기능.
						ㄴ ??? hypervisor 대신 리눅스 'container' 사용 가능.
							ㄴ 컨테이너는 하나의 커널 위에 고립된 파티션에서 실행됨.
							ㄴ 이때, 리눅스 'namespace', 'cgroup' 기술이 컨테이너를 고립, 보안처리, 관리하는데 쓰임.
							ㄴ hypervisor 실행을 위한 오버헤드가 없으므로 가상화보다 성능이 좋다.
						ㄴ 임의의 os나 어플리케이션을 배포하고 실행할 수 있는 저장소, 네트워크, 기타 기반 컴퓨팅 리소스 등을 사용자에게 제공하는 것.
							소비자는 cloud의 하부 구조를 관리하지 않지만 os, 저장소, 어플리케이션에 대한 권한과 네트워크에 대한 약간 제한된 권한을 가진다.
						ㄴ 저러한 리소스들을 주문 요청에 따라 제공해준다.
						ㄴ 사용자는 인터넷을 이용할 수도, os를 설치할 수도, 어플리케이션을 설치할 수도 있다.
					ㄴ Paas (= Platform as a service)
						ㄴ = application platform as a service (aPaaS)
						ㄴ 플랫폼을 서비스로 제공하는 것?
						ㄴ ??? ~~~
						ㄴ 세가지 방식으로 제공될 수 있다.
							ㄴ 클라우드 서비스에 의해 제공.
								ㄴ 사용자가 최소한의 설정으로 어플을 배포하면, 서비스 제공자가 네트워크, 서버, 저장소, os, db,
									미들웨어(java runtime 등) 등을 제공하는 것.
							ㄴ ??? As a private service (software or appliance) behind a firewall.
							ㄴ ??? As software deployed on public infrastructure as a service.
						ㄴ 사용자가 어플을 생성, 배포, 호스트할 환경을 제공해준다.
						ㄴ 이를 통해 환경 세팅(서버, db 세팅 등)의 작업을 없애준다. 어플에만 집중할 수 있게 해준다.
						ㄴ ??? 그 외에도 Paas가
							어플 디자인, 개발, 테스트, 배포, 웹서비스 통합, db통합, 보안, 스케일링, 어플 버전관리 등등의 여러 기능을 포함할 수 있다.
						ㄴ ??? 단점으로는 가격, 운영기능 부족, 제어 감소, 트래픽 라우팅 시스템의 어려움.
						ㄴ ~~~



				ㅇ AWS<button>more</button>
				<pre>
					ㅡ ~~~
						ㅡ 제공 서비스
							ㄴ ~~~
							ㄴ ACM, AWS Certificate Manager
								ㄴ ssl, tls 인증서 및 키 관련 생성, 저장, 갱신 등의 작업을 대신 처리해주는 기능.
								ㄴ AWS의 Elastic load balancing, amazon CloudFront, amazon API Gateway, 등을 통해 배포된다.
									??? 직접 설치할 수는 없다고 한다.
								ㄴ

							ㄴ AWS Private CA (Certificate Authority)
								ㄴ ??? AWS cloud 내에서 Public Key Infrastructure (PKI)를 만들려 할 때 사용하는 서비스?

							ㄴ Elastic Load Balancing
								ㄴ 들어오는 트래픽을 지정한 타겟으로 분산시켜주는 기능.
									타겟들의 상태를 확인하여 양호한 상태의 타겟에게 트래픽을 라우팅한다.
									ㄴ 타겟이란 ec2 인스턴스, 컨테이너, ip 등.
								ㄴ 'Elastic' load balancer는 들어오는 트래픽의 양에 따라 load balancer의 scale을 자동으로 조절한다.
								ㄴ 다음의 load balancer를 지원한다.
									ㄴ Application Load Balancer
									ㄴ Network Load Balancer
									ㄴ Gateway Load Balancer
									ㄴ Classic Load Balancer
								ㄴ Application Load Balancer
									ㄴ 'Listener'
										ㄴ 설정에 따라 특정 프로토콜과 포트에서 클라이언트의 연결 request를 확인하고 있다가, 들어오면 설정한 'rule'에 따라 트래픽을 타겟으로 라우팅한다.
										ㄴ 'rule'은 우선순위, 하나 이상의 액션, 하나 이상의 조건으로 구성.
									ㄴ 'target group'
										ㄴ request를 포함하고 있는 target들에게 라우팅한다.
										ㄴ target에 대한 상태 체크를 설정할 수 있다. 모든 target에 대해 실행된다.

				</pre>

			</pre>

			ㅇ 도커, Docker<button>more</button>
			<pre>
				ㅇ
					ㄴ ??? PaaS들의 집합?
					ㄴ OS-level 가상화를 사용하여 '컨테이너'라 부르는 것 안으로 소프트웨어들을 패키징한다.
					ㄴ 가상 컨테이너 안에 어플과 이의 의존성들을 패키지화 해준다.
					ㄴ '컨테이너'는 Linux, Window, mac에서 돌아갈 수 있다.
					ㄴ Linux kernel 기능(cgroup, namespace)과 'union mounting' 기능을 사용하여 자원을 고립한다.
					ㄴ macOs에선 리눅스 가상머신 기능으로 이를 동작시킨다.
					ㄴ 컨테이너가 가볍기 때문에 한 서버에서 동시에 여러개를 구동시킬 수 있다.

				ㅇ 컨테이너란?
					ㅡ ??? 도커는 호스트 위에서 돌아가는 프로세스들의 집합???
						ㄴ ??? 이 프로세스들은 고립되어 있고, 몇 가지 공통적인 기능을 수행한다???
					ㅡ ??? 리눅스에서 프로세스들은 트리구조를 가지므로, 프로세스의 집합인 컨테이너는 항상 루트 프로세스를 가진다 할 수 있다???
					ㅡ chroot
						ㄴ 현재 프로세스의 루트 디렉토리를 변경하는 기능.
							ㄴ ??? 당연히 현재 프로세스의 자식 프로세스들의 루트 디렉토리도 같이 변경된다.

				ㅇ
					ㅡ 'container'라 불리는 느슨하게 고립된 환경 안에서 프로그램을 실행하고 패키지화 할 수 있다.
						ㄴ 프로그램 실행에 필요한 모든 것들을 포함하고 있어 이것들을 별도로 신경쓰지 않아도 된다.
						ㄴ 컨테이너는 다른 사람들과 공유가 가능.
						ㄴ 도커에서 컨테이너 관리 도구 및 플랫폼 제공.
							ㄴ ??? 어플 배포 및
					ㅡ 컨테이너라는 휴대성 좋은 단위를 기반으로 한 기술.
						스케일 변경과 구성 변경에 용이.
					ㅡ 가상머신보다 자원이 덜 들고 가볍고 빠르다.
					ㅡ 아키텍쳐
						ㄴ 클라이언트-서버 구조.
						ㄴ 서버가 컨테이너를 빌드, 실행, 배포.
						ㄴ 서버, 클라리언트는 같은 시스템 위에 있을 수도 떨어져 있을 수도 있다.
						ㄴ rest api, unix socket, network interface를 사용하여 통신.
					ㅡ 도커 데몬
						ㄴ dockerd
						ㄴ 도커 api request를 listen, 도커 이미지, 컨테이너, 네트워크, 볼륨 등의 도커 객체를 관리.
							타 도커 데몬과 통신.
					ㅡ 도커 클라이언트
						ㄴ docker
						ㄴ 유저가 실질적으로 도커를 사용하는데 쓰는 대상. ex ) docker run
						ㄴ 유저의 명령을 받거나 하면 docker 데몬에게 요청을 보내 작업을 수행하도록함.
						ㄴ 'docker api' 사용.
						ㄴ 하나 이상의 데몬과 통신 가능.
					ㅡ 도커 데스크탑
						ㄴ 도커를 좀 더 쉽게 사용할 수 있게 해주는 프로그램. mac, window, linux.
					ㅡ 도커 registries
						ㄴ 'docker image' 저장소.
						ㄴ docker hub는 public docker registry.
							기본적으로 docker hub에서 image를 찾도록 디폴트 설정. 변경 가능.
					ㅡ 도커 object
						ㄴ docker image, container, network, volume, plugin 등을 통칭.
						ㄴ docker image
							ㄴ docker container 생성을 위한 명령어들로 이루어진 read-only template.
							ㄴ 또 다른 docker image를 기반으로 커스터파이징이 추가되어 생성되는 경우 잦음.
							ㄴ registry로부터 받아 사용하거나 직접 build할 수 있다.
								ㄴ 후자를 위해, 'Dockerfile'을 문법에 맞게 생성 필요.
									이 파일의 내용은 이미지를 생성하고 실행하는데 필요한 단계들을 정의, ??? 이미지의 layer를 정의.
									ㄴ Dockerfile
										ㄴ 확장자명이 없는 단순 텍스트 파일.
										ㄴ 도커 이미지 생성에 사용될 명령어 script들을 담고 있다.
								ㄴ 'Dockerfile' 수정 후 재빌드시, 변화가 있는 layer만 재빌드된다. 이로 인해 도커가 타 가상화 기술에 비해 가볍고 빠르다 한다.
							ㄴ ???컨테이너에게 고립된 파일 시스템을 제공한다?
								ㄴ 같은 이미지더라도 매번 새 컨테이너 생성시 각각의 고립된 파일시스템을 할당해준다.
								ㄴ 'container volume'을 통해 이를 수정할 수 있다.
							ㄴ ??? 정확히 명시된 내용을 확인하지 못한 추측이지만..
								build시, 컨테이너를 실행시키기 위해 필요한 모든 파일들을 생성하여 image에 넣어두고
								이후, 이 image로부터 필요한 모든 것들을 가져다가 컨테이너를 실행한다? 일종의 필요한 파일들의 압축 파일 형태?
								물론 필요한 파일들 뿐만 아니라 환경 변수 등의 여러가지 설정 데이터도 포함?
								ㄴ 도커가 image를 어떻게 만들고 컨테이너 실행에 사용하는지는 모르겠지만,
									대략적으로, 컨테이너 실행에 필요한 파일, 메타데이터 등을 특정 표준에 맞게 구조화하여 묶어 놓은 것이 image.
									컨테이너 실행시, 컨테이너 환경에서 이 이미지를 풀어 사용하여 원하는 컨테이너 환경을 구성.
									ㄴ https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction#
									ㄴ https://iximiuz.com/en/posts/you-need-containers-to-build-an-image/
						ㄴ docker container
							ㄴ 이미지의 실행 가능한 인스턴스.
							ㄴ Docker api, CLI를 통해 컨테이너를 생성, 시작, 정지, 이동, 삭제 할 수 있다.
								하나 이상의 network에 접속하거나 저장소를 붙이거나 컨테이너의 현재 상태를 기반으로 새 이미지를 만들 수 있다.
							ㄴ 디폴트로, 다른 컨테이너 및 host machine과 잘 고립되어 있는 편. 디테일한 설정 가능.
							ㄴ 기반 이미지와 컨테이너 생성, 시작시의 여러가지 설정으로 정의된다.
							ㄴ 어떤 os에서도 구동가능.
							ㄴ 다른 컨테이너들과 독립되어 있다.
							ㄴ ex )
								docker run -i -t ubuntu /bin/bash
								ㄴ 'ubuntu'란 이미지 없을시, registry로부터 pull. docker pull ubuntu 명령 수행시와 동일하게.
								ㄴ 컨테이너 생성. docker container craete 명령 수행시와 동일하게.
								ㄴ 컨테이너에 파일시스템 할당. ??? final layer에?
								ㄴ network interface 생성.
								ㄴ 컨테이너 실행 및 '/bin/bash' 명령 실행. '-i', '-t' 옵션으로 인해.
								ㄴ 이후 /bin/bash의 터미널 종료시, 컨테이너 '정지'. '삭제'되지 않음.
						ㄴ container Volume
							ㄴ 컨테이너의 파일시스템을 host machine의 특정 파일시스템 경로에 연결시켜주는 기능을 한다.
							ㄴ 여러 컨테이너가 동일한 위치를 사용할 수 있으며, 컨테이너들 사이에서 공유되는 효과가 있다.
							ㄴ docker run 명령어에 '-v' 옵션으로 volume 관련 설정 가능.
						ㄴ 도커는 'Go' 언어로 개발, 리눅스 커널의 기능 사용.
							'namespace' 라는 기술 사용하여 컨테이너의 고립된 작업 환경 기능 구현. 컨테이너 실행시, 해당 컨테이너에 대한 'namespace' set 생성하여 사용.
							컨테이너 내에서도 layer별로 namespace 고립.
							ㄴ 리눅스 kernel의 'namespace', 'cgroup'
								ㄴ ~~~
								ㄴ https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504 참고
					ㅡ 기본 사용법 )
						ㄴ ~~~
						ㄴ 이미지 빌드
							ㄴ 'Dockerfile' 생성 및 명령어 작성.
							ㄴ docker build -t (*생성될 이미지의 태그명*) (*'Dockerfile'을 찾을 경로*)
								ㄴ (*'Dockerfile'을 찾을 경로*)에서 'Dockerfile'을 찾아 이미지 생성.
						ㄴ 컨테이너 실행
							ㄴ ex ) docker run -dp 3000:3000 getting-started
								ㄴ 'detached' 모드(백그라운드 실행)로, 3000번 포트 연결하여 실행.
						ㄴ 컨테이너 정지
							ㄴ ex )
								docker stop (*컨테이너id*)
						ㄴ 컨테이너 삭제
							ㄴ ex )
								docker rm (*컨테이너id*)
						ㄴ 업데이트
							ㄴ 기존 포트 사용하는 컨테이너 정지 후, 새로 빌드한 이미지를 실행시키면 됨.
						ㄴ container volume 설정
							ㄴ docker volume create (*volume명*)
							ㄴ docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
							ㄴ 해당 컨테이너 삭제 후 새 컨테이너를 -v todo-db:/etc/todos 옵션을 동일하게 주어 실행시, 데이터 유지.
							ㄴ docker volume inspect (*volume명*)
								ㄴ 해당 볼륨에 대한 정보 조히ㅗ.

					ㅡ Docker Build
						ㄴ docker build 명령어 : 가장 기본적인 빌드 방법.
						ㄴ docker BuildKit
							ㄴ 새롭게 추가된 빌드 컴포넌트.
						ㄴ docker Buildx
							ㄴ BuildKit에서 지원하는 모든 기능을 포함하면서 docker build 명령어를 상속하는 CLI plugin.
							ㄴ 'docker buildx build'
								ㄴ 'docker build' 명령어와 거의 동일한 UX로 사용된다.
						ㄴ Dockerfile
							ㄴ 특정 문법을 따르는 명령어 모은 텍스트 파일. 이미지를 구성할 때 필요하다.
							ㄴ 명령어
								ㄴ FROM (*image*)
									ㄴ base image 정의.
								ㄴ RUN (*명령어*)
									ㄴ ??? 현재 이미지의 최상 layer에서 해당 명령을 실행하고 결과를 커밋.
									ㄴ ??? 명령어 실행을 위한 shell form을 가지고 있다?
								ㄴ WORKDIR (*디렉터리*)
									ㄴ Dockerfile에서 뒤에 오는 모든 RUN, CMD, ENTRYPOINT, COPY, ADD 명령어를 위한
										working 디렉토리 설정.
								ㄴ COPY (*소스*) (*목적지*)
									ㄴ 파일이나 디렉토리 복사 붙여넣기.
								ㄴ CMD (*명령어*)
									ㄴ 해당 이미지를 기반으로하는 컨테이너 시작시 맨 처음 실행될 명령어 설정.
									ㄴ Dockerfile 당 하나 존재해야 하며, 여러개인 경우 마지막 것만 취급.
							ㄴ 디폴트 파일명은 'Dockerfile'
								ㄴ 디폴트 파일명인 경우, 'docker build' 명령시 별도의 파일명 플래그 필요 없음.
									디폴트가 아닌 경우, docker build --file (*파일명*)
								ㄴ 명시적 설정의 경우, '(*파일명*).Dockerfile' 이 관례.
						ㄴ 도커 이미지는 read-only layer들로 구성. 각각은 Dockerfile의 명령어의 결과.
						ㄴ ~~~

					ㅡ Docker Storage
						ㄴ 디폴트로, 컨테이너 안에서 생성되는 모든 파일들은 컨테이너 계층 안에서 저장되기 때문에,
							컨테이너가 존재하지 않게되면 영속되지 않고, 컨테이너 계층 바깥으로 꺼내기 어렵다.
						ㄴ ??? host machine과 강하게 결합되어 있어 꺼내거나 다른 곳으로 옮ㄱ기ㅣ 어렵다?
						ㄴ ??? 'storage driver'를 사용한다?
						ㄴ 컨테이너 계층이 아닌 host machine에 데이터를 저장하는 두가지 방법 존재. 'volume', 'bind mount'
							ㄴ 그 외에 host machine의 시스템 메모리에 파일을 저장하는 방법. 'tmpfs'(리눅스의 경우), 'named pipe'(윈도우의 경우)
								ㄴ 메모리에 저장하므로 당연히 영속되지 않는다.
						ㄴ volume
							ㄴ host의 파일시스템 중 일부가 도커에 의해 관리되면서 이곳에 데이터가 저장되는 방식.
							ㄴ 도커가 아닌 프로세스가 이 부분을 수정할 수 없다.
							ㄴ 'docker volume create'를 통해 명시적 생성 또는 컨테이너, 서비스 생성시 도커에 의해 자동 생성.
							ㄴ 여러 컨테이너한테 동시 마운팅 가능.
							ㄴ volume을 사용중인 실행 중인 컨테이너가 없어도 없어지지 않는다.
							ㄴ 'docker volume prune'으로 제거 가능.
							ㄴ 좋은 사용 예 )
								ㄴ 여러 컨테이너들 사이에서 데이터 공유가 필요한 경우.
								ㄴ 호스트가 해당 디렉터리 구조를 가지는지가 불분명한 경우. 호스트에서의 설정과 컨테이너의 실행을 분리해준다.
								ㄴ ??? 컨테이너의 데이터를 로컬이 아닌 remote host나 cloud provider에 저장하고 싶을떄?
								ㄴ ??? 데이터를 한 호스트에서 다른 호스트로 백업, restore, migrate하고자 할떄?
								ㄴ 'docker desktop'에서 높은 i/o 성능을 필요로 할때. volume이 호스트에서 linux VM에 저장되기 때문에 읽기쓰기 성능이 더 좋다.
								ㄴ ??? 'docker desktop'에서 어플이 완벽하게 native filesystem 처럼 동작해야 할때. volume이 linux VM에 저장되기때문에 이를 보장해준다.
						ㄴ bind mount
							ㄴ host의 어디든 저장소로 사용될 수 있다.
							ㄴ 컨테이너나 host의 도커가 아닌 프로세스가 수정할 수 있다.
							ㄴ host의 파일이나 디렉토리가 컨테이너에 마운트된다.
								ㄴ 전체 경로가 제공되고
								ㄴ 해당 파일이나 디렉토리가 없으면 자동 생성.
							ㄴ ??? 도커 CLI command로 bind mount를 관리할 수 없다?
							ㄴ 좋은 사용 예 )
								ㄴ 설정 파일이나 배포를 위한 소스코드, 빌트 artifact 등을 호스트와 컨테이너가 공유해야 할 때.
								ㄴ 컨테이너가 마운트하여 사용할 호스트의 파일 또는 디렉토리 구조 부분이 일관성을 보장할 수 있을 때.
						ㄴ tmpfs
							ㄴ host의 메모리에만 저장되며 host의 파일시스템에 write되지 않는다.
							ㄴ 좋은 사용 예 )
								ㄴ 데이터를 영구적으로 저장할 필요가 없을 때.
									ㄴ 보안상의 이유이거나
									ㄴ 저장하지 않을 대용량의 데이터를 write 해야하는 경우에 성능상의 이유 등.
						ㄴ 컨테이너 상에서 이미 파일, 디렉토리가 존재하는 위치에 빈 volume을 마운트할 경우,
							기존에 존재하던 파일, 디렉토리들이 volume으로 복사된다.
						ㄴ ??? 컨테이너 상에서 이미 파일, 디렉토리가 존재하는 위치에 비어있지 않은 volume을 마운트하거나 bind mount를 할 경우,
							기존에 존재하던 파일, 디렉토리들이 리눅스의 /mnt에 저장되는 것처럼 가려진다.
							~~~

					ㅡ networking
						ㄴ 도커 network driver
							ㄴ 도커의 네트워크 관련 subsystem은 driver를 이용하여 pluggable하다.
							ㄴ 종류 )
								ㄴ bridge network )
									ㄴ 디폴트 network driver.
									ㄴ 소프트웨어적인 bridge. 같은 bridge에 연결된 컨테이너들이 통신할 수 있도록.
										다른 bridge에 속한 컨테이너들과는 네트워크 고립.
									ㄴ 같은 docker daemon host 위에 있는 컨테이너들에 적용 가능.
									ㄴ 도커 실행시, default bridge network 생성.
										컨테이너 실행시, network관련 아무 명시가 없으면 컨테이너를 이 디폴트 bridge에 연결.
									ㄴ 사용자 정의 bridge network 생성 가능.
									ㄴ 디폴트 bridge대신 사용자 정의 bridge 사용 권장.
									ㄴ standalone container 내의 어플에 대한 통신이 필요할 때 사용.
									ㄴ 디폴트 bridge 사용시, 관련 없는 대상이 네트워크 연결될 수 있다.
										사용자 정의 브릿지를 통하여 확실히 관련있는 대상들만 연결되도록 하는 것이 낫다.
									ㄴ ???사용자 정의 브릿지 사용시, 컨테이너 재시작 필요 없이 bridge 연결을 끊거나 연결할 수 있다.
										디폴트 브릿지는 재시작해야함.
									ㄴ 사용자 정의 브릿지마다 필요한 설정을 따로 하여 적용 가능.
									ㄴ ??? 여러 컨테이너가 환경변수를 공유할 방법은 디폴트 브릿지로 연결하여야지만 가능하지만 다른 방식으로 해겨 ㄹ가능.
										ㄴ docker volume에서 mount를 통하여 파일을 공유
										ㄴ docker-compose에서 compose파일 내에 변수 정의
										ㄴ swarm service
									ㄴ 'docker network create (*사용자 정의 브릿지 네트워크명*)' 을 통하여 사용자 정의 브릿지 생성 가능.
										ㄴ 여러 옵션들로 네트워크 설정 가능.
									ㄴ 'docker network rm' 으로 브릿지 네트워크 삭제.
										ㄴ 사전에 브릿지에 연결된 컨테이너 disconnect 필요.
									ㄴ 같은 bridge 내의 컨테이너들은 서로 모든 포트 접근 가능.
									ㄴ

								ㄴ host network
									ㄴ 컨테이너의 네트워크가 고립되지 않고 host의 네트워크 네임스페이스를 공유한다.
									ㄴ 컨테이너가 별도의 ip주소를 가지지 않는다.
									ㄴ 컨테이너에 대한 port mapping은 무시된다.
										ㄴ -p, --publish, -P, --publish-all 옵션이 무시됨.
									ㄴ 성능 최적화,
										컨테이너가 많은 포트를 사용해야 할 때, (???'network address translation'이 필요치 않음)
										??? 'userland-proxy'가 포트별로 없을 때?
										유용하다.
									ㄴ 리눅스 호스트일때만 지원.
										Window, Mac의 Docker Desktop과 Docker EE에선 지원 x.
									ㄴ ???swarm service에 사용 가능.
										ㄴ 'docker service create'에 '--network host'옵션을 통하여.
										ㄴ ??? swarm 서비스들의 트래픽은 overlay network를 통하여 전달되지만,
											각각의 swarm service container들은 호스트의 네트워크를 통하여 데이터를 보냄.
								ㄴ overlay network
									ㄴ 여러 docker daemon host를 연결하여 네트워크를 만들거나
										'docker swarm service'들이 서로 통신할 수 있게한다.
										ㄴ swarm service와 standalone container 사이의 통신,
											서로 다른 daemon의 standalone container끼리의 통신도 가능하다.
										ㄴ 하여, os-level routing을 대체할 수 있다.
									ㄴ ??? This network sits on top of (overlays) the host-specific networks, allowing containers connected to it (including swarm service containers) to communicate securely when encryption is enabled.
									ㄴ ??? ~~~
								ㄴ ipvlan
									ㄴ ???IPv4, IPv6 addressing을 관리할 수 있게한다.
									ㄴ ~~~
								ㄴ macvlan
									ㄴ 컨테이너의 MAC address를 할당할 수 있게한다.
									ㄴ ~~~
								ㄴ none
									ㄴ 컨테이너의 네트워크를 diable한다.
									ㄴ swarm service에선 사용불가.
								ㄴ 그 외 plugin
									ㄴ third-party 네트워크 플러그인을 설치하여 사용 가능.
									ㄴ Docker Hub나 third-party vendor들로부터 받을 수 있다.

						ㄴ port publish
							ㄴ 도커 컨테이너의 특정 포트를 외부로 노출시켜(publish) 접근할 수 있도록 하는 것.
							ㄴ ??? --publish(= -p) 플래그 사용.
						ㄴ CLI > docker run 네트워크 관련 옵션
							ㄴ --network 옵션
								ㄴ ex ) docker run --network="bridge" ~~~
								ㄴ 인자값
									ㄴ "bridge"
										ㄴ 디폴트값.
										ㄴ
									ㄴ "host"
										ㄴ 컨테이너가 호스트의 네트워크 스택을 사용.
									ㄴ "container:(*컨테이너 이름 또는 id*)"
										ㄴ 컨테이너가 다른 컨테이너의 네트워크 스택을 사용.
									ㄴ "(*user 생성 docker network명*)"
										ㄴ 'docker network create' 를 통해 생성한 사용자 생성 네트워크를 사용.
									ㄴ "none" : 컨테이너 네트워크가 disable.

							ㄴ --dns
								ㄴ 컨테이너의 dns서버는 디폴트로 호스트와 동일.
								ㄴ 이 옵션으로 컨테이너 dns서버 지정 가능.
							ㄴ --mac-address
								ㄴ 컨테이너 mac address 지정 가능.
						ㄴ ??? docker proxy server 설정
							ㄴ ~~~
						ㄴ ~~~





					ㅡ mount 방식 유형
						ㄴ bind mount
							ㄴ host machine의 파일 또는 폴더를 직접 사용하는 것.
						ㄴ named volume
							ㄴ 도커에 의해 생성되고 관리되며, host machine, 다른 container 사이에서 공유될 수 있다.
						ㄴ tmpfs
							ㄴ ~~~
						ㄴ named pipe
							ㄴ ~~~

					ㅡ Docker Compose
						ㄴ multi-container 도커 어플을 정의 및 실행해주는 도구.
						ㄴ YAML 파일로 관련 설정들을하고, 이를 실행하는 방식으로 동작.
						ㄴ 3가지 단계로 사용 절차 구성
							ㄴ 'Dockerfile' 정의.
							ㄴ 'docker-compose.yml'에 어플을 구성할 서비스들 정의.
							ㄴ docker compose 실행.
						ㄴ docker-compose.yml
							ㄴ ex )
								version: "3.9"  # optional since v1.27.0
								services:
								  web:  # 실행할 컨테이너를 지칭. 임의 명칭?
									build: .  # 이 위치에서 빌드하여 이미지로 사용할 것.
									ports:  # 포트 바인드.
									  - "8000:5000"
									volumes:
									  - .:/code
									  - logvolume01:/var/log
									depends_on:
									  - redis
								  redis:
									image: redis  # 'redis'란 이미지 사용. hub에서 가져올 수도 있다.
								volumes:
								  logvolume01: {}

					ㅡ Docker CLI
						ㄴ run
							ㄴ ~~~
							ㄴ option
								ㄴ --add-host
									ㄴ
								ㄴ --network
									ㄴ ex ) docker run --network=my-net (*container name*)
						ㄴ ~~~

					ㅡ Orchestration
						ㄴ ???도커 컨테이너처럼 '컨테이너화된 어플리케이션'을 관리(배포, 스케일링, 유지보수 등)하는 도구를 의미.
						ㄴ ex ) Kubernetes, Docker Swarm

			</pre>

        </pre>

        ㅇ email (메일, Electronic mail) <button></button>
		<pre>
            ㅡ ??? 전기 장치를 사용하는 사람들 사이의 메세지(mail) 교환 방법?
                ㄴ 물리적인 mail만 존재하던 때에 이에 상응하는 전기적 mail이라 하여 붙여진 이름?
            ㅡ ??? email 시스템은 보통 'store-and-forward' 모델을 따른다?
            ㅡ FQDA
                ㄴ email 주소를 나타내는 문자열.
                ㄴ ex ) localpart@mailhost.example.com
                ㄴ @ 앞부분 : local part. 보통 username.
                ㄴ @ 뒷부분 : 메일의 호스트, 도메인명.
            ㅡ MX record
                ㄴ ??? 도메인명을 대신하여 이메일을 받을 메일 서버를 명시하는 record?
                    ㄴ ex ) 대략적 형식
                        Domain			TTL   Class    Type  Priority      Host
                        example.com.		1936	IN	MX	10         onemail.example.com.
                        example.com.		1936	IN	MX	10         twomail.example.com.
                ㄴ ??? DNS 내부에 있는 데이터?
                    ㄴ 도메인명과 메일서버 도메인명이 우선순위 값과 함께 매핑되어 있다.
                    ㄴ MTA가 DNS에게 이메일 수령 주소의 도메인명에 대한 MX records를 요청하면
                        DNS는 MX records에서 이와 매핑되어 있는 메일서버 도메인명 목록을 반환해준다.
                    ㄴ MTA는 이 메일서버의 호스트명으로 SMTP 연결을 진행한다?
            ㅡ MUA (mail user agent, email client, email reader) :
            ㅡ MSA (mail submission agent)
                ㄴ 이메일 전달하는 애? MUA로부터 메세지를 받아 MTA와 상호작용하는 프로그램 또는 에이전트.
                ㄴ ??? SMTP의 변형인 ESMTP 프로토콜 사용?
                ㄴ 많은 경우, MTA가 MSA의 역할도 수행.
                ㄴ 역사적으로는 MSA, MTA 모두 port 25를 사용하나, MSA의 공식적 port는 587.
            ㅡ MDA (message delivery agent) : 이메일을 인터넷으로부터 받아 mailbox에 전달하는 애?
            ㅡ Message transfer agent (MTA, mail transfer agent, mail relay)
                ㄴ SMTP 프로토콜을 사용하여 한 컴퓨터에서 다른 컴퓨터로 메일을 전달하는 소프트웨어.
                ㄴ 문맥에 따라 mail server, mail exchanger, MX host 라고도 불린다.
                ㄴ MTA, MSA, MUA로부터 메일을 받는다.
                ㄴ ??? 이메일 수신시마다, 메세지 헤더 top에 'Received' trace header 필드를 추가하여, MTA들의 처리 기록을 만든다?
                ㄴ 메세지를 수신할 mailbox가 local에 없으면, 메세지는 다른 MTA로 전달된다(relayed)
                ㄴ 메세지를 MDA에게 전달.
                ㄴ relay server, filtering server는 이메일을 간략하게 저장하나, 다른 경우, mailbox를 두어 이메일 전체를 저장하며,
                    이 경우, end user가 MUA나 email client를 통해 이메일에 접근할 수단을 지원한다.
                    ㄴ POP3, IMAP, proprietary system(MAPI 등).
                ㄴ 이메일에 대한 user의 접근은 보통 webmail이나 email client에 의해 이루어진다.
                ㄴ ??? mail client에 의한 새 이메일 전송은 SMTP, port 587이나 465을 통해 이루어지나,
                    현재는 사용자가 ISP와 같은 계정을 가진 경우로 제한되는 경향이 있다.
                    일종의 정책이며, 사용자가 스팸이나 이메일 남용하는 것에 대한 책임을 묻기 위함이라 한다.
            ㅡ 기본적인 동작 방식 )
                ㄴ 1. MUA(mail user agent)가 메세지를 email format으로 구성,
                        전송 프로토콜(SMTP)를 사용하여 로컬 MSA(mail submission agent)에게 메세지 전달. (smtp.a.org???)
                ㄴ 2. MSA가 SMTP 프로토콜에서 제공하는 목적지 address를 결정.(FQDA로)
                ㄴ 3. DNS 서버가 해당 도메인에 대한 MX records를 반환.
                ㄴ 4. ??? MSA가 메세지를 SMTP로 MDA로 전달. 중간에 MTA를 거칠 수도 있다?
                ㄴ 5. ??? MDA가 메세지를 받아 mailbox에 전달.
                ㄴ 6. ??? MUA가 POP3나 IMAP 프로토콜을 이용하여 메세지를 가져옴.
            ㅡ 기본적인 동작 방식은 위와 같으나, 이 외에도 이메일을 전달하는 다양한 변형 방식들이 존재.
                ㄴ ~~~
		</pre>

	</pre>
	<br>front-end<button>더보기</button>
	<pre>
		html<button>더보기</button>
		<pre >
			ㅇ HTML이란?<button>더보기</button>
			<pre>
				ㅡ 그냥 일반 텍스트 문서인데, '요소(태그)'라는걸로 구조화된 텍스트 문서이다.
			</pre>
			ㅇ 한글 인코딩
       			ㅡ 브라우저는 html문서를 화면에 나타낼때 기존에 설정된 글자셋을 가지고 문서를 읽는다.
       			ㅡ 해서 기존에 설전된 글자셋이 문서의 내용과 맞지않으면 글자가 깨지게되며,
       			ㅡ 이를 해결하기위해 html문서의 < head>아래에 < meat>태그를 이용해 charset을 설정해준다.
       			ㅡ ex)	< head>
       						< meta charset="UTF-8">
       					< /head>

			ㅡ요소 중첩시 닫히는 순서를 지켜야한다.
			ㅡ블럭요소와 인라인요소로 나뉘어질수있음. 블럭은 새로운줄을 만들며생기는것 인라인은 그 줄에 해당되는 요소.
			ㅡ속성값을 ""로 감싸야함
			ㅡ boolean 속성값이란것이 존재. 속성이름과 같은 값만을 속성값으로 가질수있다. ex) disabled="disabled"
			ㅡ< strong >태그 : 내용을 강조해줌.
			ㅡ< em >태그 : 글자를 기울림.
			ㅡ< div > : 아무런 기능도하지않고 구역을 나누는 역할. 주로 css적용목적.
			ㅡ< article > : 독립된 내용을 담는데 쓰임
			ㅡ< nav > : html 문서 구조의 한 구획으로, 보통 페이지안이나 다른페이지로넘어가는 링크를 걸어둔다.
			ㅡ

			ㅇ html에서 파일업로드하기
				ㅡ ...
				ㅡ 파일 이름 가져오기
					ㄴ getFileSystemName ( String name ) : 실제로 저장된 파일 이름을 가져온다
					ㄴ getOriginalFileName ( String name ) : 파일의 원래 이름을 가져온다.
					ㄴ getFileNames() : 여러개의 파일을 올릴경우 Enumeration의 형태로 그 이름들을 가져온다는데 어떻게 쓰는건지 잘 모르겠다.
							그냥 input을 여러개 동적으로 만들어서 넘겨주는 형태가 더 쉬웠다.

			ㅇ 태그 종류 )
				ㅡ < img>
					ㄴ src 속성에 있는 url에 해당하는 이미지를 뿌려주는 태그.
						ㄴ url이기때문에 다른 웹페이지 주소형태로 입력하여도 그 페이지의 이미지가 출력된다.
			ㅇ 태그<button>더보기</button>
			<pre>
				ㅡ < img>
					ㄴ ~~~~~
					ㄴ 실무 )
						ㄴ src 속성에 base64로된 url를 넣으면 이미지 출력이 가능하다.

			</pre>

			ㅇ Escape (이스케이프)
				ㅡ <, ' 등과같은 사전에 문법적으로 약속된 문자를 표현하기 위해선 그냥 해당 문자를 작성하는 것이 아닌, 'html 엔터티'를 사용하여야 한다.
				ㅡ html 엔터티란 '& l t ;', '& n b s p ;' 등을 말한다.
				ㅡ 이렇게 특정문자를 html로 변환하는 것을 '이스케이프'한다고 한다.
		</pre>
		css<button>더보기</button>
		<pre>
			ㅡ https://developer.mozilla.org/en-US/docs/Learn/CSS 참조.
			ㅇ css 동작 과정 )
				ㄴ 다음은 매우 간소화한 내용이고 브라우저마다 조금씩 다르다는점 기억.
				ㄴ 단계 )
					1. 브라우저가 html을 로드받는다.
					2. html이 dom으로 변환된다.
					3. 브라우저가 html문서에 링크된 이미지, 비디오, linked css등을 가져온다.(fetch한다)
					4. 브라우저거 fetch된 css를 파싱하여 선택자에 따라 어떤 rule이 어떤 dom에 적용되어야하는지 분류하고 이를 적용한다.
					5. ???The render tree is laid out in the structure it should appear in after the rules have been applied to it.
					6. 스크린에 css가 적용된 페이지가 보여진다.
				ㄴ 오류가있을시)
					ㄴ 프로퍼티나 value에 오류가 있을시, (스펠링이 틀리거나 아직 지원하지않는 내용이거나) 해당부분은 그냥 무시된다.

			ㅇ 선택자
				ㅡ 콤마(,)를 이용하여 여러개항목을 동시에선택할수도있다. ex) $(" (*요소1*) , (*요소2*), ... ").~~~
				ㅡ E F	E 요소의 자손인 F 요소를 선택합니다.
				ㅡ E>F	E 요소의 자식인 F 요소를 선택합니다.
				ㅡ E+F	E 요소를 뒤따르는 F 요소를 선택합니다.(E와 F 사이에 다른 요소가 존재하면 선택하지 않습니다.)
				ㅡ E~F	E 요소가 앞에 존재하면 F를 선택합니다. (E가 F보다 먼저 등장하지 않으면 선택하지 않습니다.)
				ㅡ 선택자 : 가상 요소, 가상 클래스
					ㄴ 가상 클래스 : ':'로 표시되며 ex) a:visited, button : hover 같은 것. 선택된 요소의 특정 상태를 선택하기 위한 선택자.
					ㄴ 가상 요소 : ' :: ' 로 표시되며 선택된 요소의 특정 부분을 선택하기위한 키워드. ex) p :: first-line ( p태그의 첫번째 줄을 선택 )

			ㅡ css 적용 우선순위)
				1. !important
				2. 태그에 style속성 사용
				3. id 선택자
				4. class 선택자
				5. 속성 선택자
				6. 가상클래스
				7. 태그 선택자
				8. 상속된 속성
				ㄴ 같은 순위 안에서는 선택자에서 지정항 항목?이 많을수록 우선시되는 듯 하다. (정확하게는 모르겠다)
					ㄴ .aaa 보다 .aaa td 이렇게 하나라도 더 세세한 정보가 제시된게 우선적용된다.

			ㅡ 상속이 되는 속성과 안되는게 있다.
				ㄴ color같은건 상속. display같은건 상속안됨.
				ㄴ ex)
					< div>
						< form> ~~ < /form>
					< /div>
					div에 display : inline을 하더라도 form은 변화없이 디폴트인 block이다.

			ㅡ 퍼센트 css value 타입 )
				ㄴ 대부분의 경우 특정 값의 상대값으로 작용한다.
					ㄴ font-size이면 부모 font-size의 상대값, width면 부모 width의 상대값.
			ㅡ 크기 조절하기 )
				ㄴ 요소들은 본래의 intrinsic size를 가지고 있다고 한다. ex) img
				ㄴ div같은 요소들은 내용물이없으면 size가 없다. 이런 요소들은 안의 content에 따라 intrinsic size가 결정된다고 할 수 있다.
				ㄴ margin, padding을 퍼센트로 적용할 경우, top,bottom은 height를기준으로, left,right는 width를 기준으로 적용되는게 아니라
					모든 방향의 margin, padding값이 수평값인 width을 기준으로 적용된다.
				ㄴ span과 같은 inline요소에는 width, height를 지정할 수 없다.
					ㄴ 하려면 display:block 또는 display:inline-block으로 바꿔주어야 한다.
				ㄴ width, height를 %값으로 설정할경우, 부모요소의 크기를 기준으로 %가 적용된다.
			ㅡ image, media, form elements )
				ㄴ 특정 요소들은 css에서 좀 특별하게 적용된다고 한다. image, 다른 media형태의 요소, form 요소가 대표적이다.
				ㄴ replaced elements : image, video와 같이 css가 내부내용에 관여하지 못하는 요소들을 말한다. (그 요소부분이 css가 관여못하는
					다른것으로 대체되었다해서 이렇게부르나?)
				ㄴ 별내용없는듯하다
			ㅡ css 설계나 유지보수에 도움이 될 팁 )
				ㄴ 내 경우에 도움이 될만한 것들은..
				ㄴ 너무 옵션이 많은 선택자 사용은 지양해라
				ㄴ 하나의 css에 모든 내용을 담지말고 적절하게 분산해라.
			ㅡ 'containing block'
				ㄴ 요소의 위치나 크기에 영향을 미치는 개념.
				ㄴ 요소가 들어있는 박스 같은걸로 생각하면 된다.
				ㄴ 보통 그냥 요소의 영역을 생각하면 쉬운데 엄밀히 content area, padding area, border area, margin area 로 나뉜다고한다.
					( margin, padding 구분할때 그 영역 맞음)
				ㄴ width, height, padding, margin과 position프로퍼티가 absolute인 요소들의 위치프로퍼티(top,bottom등)을 설정할때
					이 containg block이 기준이 된다고한다.
				ㄴ 결정 요소 )
					ㄴ containing block은 'position'속성값에 의해 결정된다고 한다.
					ㄴ position값이 static, relative, sticky일 경우 )
						ㄴ 'block container', 'formatting context'를 가지는 가장 가까운 부모요소의 'context box'가
							containing block이 된다고 한다.
					ㄴ position값이 absolute인 경우 )
						ㄴ position값이 static이상으로(즉, fixed, absolute,relative,sticky) 설정되어있는 가장 가까운 부모요소의
							'padding box'가 containg block이 된다한다.
					ㄴ fixed인 경우 )
						ㄴ viewport나 page area가 containg block이 된다.
					ㄴ absolute나 fixed인 경우 )
						If the position property is absolute or fixed, the containing block may also be formed by the edge of the padding box of the nearest ancestor element that has the following:
						A transform or perspective value other than none
						A will-change value of transform or perspective
						A filter value other than none or a will-change value of filter (only works on Firefox).
						A contain value of paint (e.g. contain: paint;)
			ㅡ position
				ㄴ 요소의 위치를 결정하는 개념.
				ㄴ 디폴트로 static. 설정값으로 relative, absolute, fixed, sticky가 있다.
				ㄴ
				ㄴ ex)
					position : relative ;
					top : 40px;
					left : 10%;
				ㄴ static )
					ㄴ 디폴트값으로, 이걸로 설정되어있으면 top, bottom, left, right, z-index 프로퍼티가 효과가 나오지 않는다.
					ㄴ normal flow에 따라 위치가 설정된다.
				ㄴ relative )
					ㄴ 요소의 normal position을 기준으로 top, bottom, left, right가 결정된다.
				ㄴ absolute )
					ㄴ position의 값이 absolute인 요소에 해당
					ㄴ 요소의 containg block을 기준으로 위치가 설정된다.
						ㄴ absolute의 containg block이란 : position값이 static 이상으로 설정되어있는 가장 가까운 조상의 padding box.
					ㄴ 요소가 normal flow에서 제거되고 페이지레이아웃에서 해당 요소의 공간이 없어진다.
					ㄴ 따라서 다른 요소들은 이 absolute 요소가 존재하지 않는 것처럼 위치한다.
				ㄴ fixed )
					ㄴ 요소가 normal flow에서 제거되고 페이지레이아웃에서 해당 요소의 공간이 없어진다.
					ㄴ viewport의 containg block을 기준으로 위치가 설정된다.
					ㄴ 조상요소중 transfer, perspective, filter 프로퍼티의 값이 none 이상인 경우, 해당 조상이 containg block과 같이된다. ???
					ㄴ containg block의 설정부분만 제외하고는 absolute와 같다.
				ㄴ sticky )
					ㄴ position의 값이 sticky인 경우.
					ㄴ ???정확한 동작방식은 모르겠음. 주어진 offset값에서 fixed처럼 위치해있다가 다른 relative positioned 요소를 만나면 그곳에 위치가 고정된다.
					ㄴ top, bottom, left, right중 하나가 반드시 있어야한다.


			ㅡ layout )
				ㄴ https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout 참조.
				ㄴ 요소들을 위치시키는 것에 대해 배움.
					ㄴ normal flow, display property, flexbox, grid, floats, positioning, table layout, multiple-column layout에 대해 배울것.
				ㄴ normal flow )
					ㄴ 아무런 설정도 하지 않았을때 브라우저가 요소들을 배치시키는 방식.
					ㄴ block 요소들은 부모요소의 넓이를 100% 차지한다.
					ㄴ inline 요소들은 내부 컨텐츠의 높이와넓이만큼의 높이와넓이를 차지한다.
				ㄴ display 속성 )
					ㄴ 각 요소들은 디폴트 display값을 가지고있음. (< a>는 inline, < li>는 block 등등)
					ㄴ flex 값 )
						ㄴ 참고 사이트 )
							ㄴ https://heropy.blog/2018/11/24/css-flexible-box/
							ㄴ  https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox
						ㄴ 개요 )
							ㄴdisplay속성값중 하나.
							ㄴ 요소들을 1차원으로(한줄로) 배치하는데쓰이는 값.
						ㄴ 사용법 ) 부모요소에 'display : flex' 를 주면 바로 아래 자식요소들이 1줄로 배치된다.
						ㄴflex box 구성 )
							ㄴ flex_box.png참조.
							ㄴ axis가 축을 말함. 이 축을 기준으로 flex box내의 요소들이 정렬된다.
						ㄴ 관련 속성 )
							ㄴ 부모에 설정하는 속성)
								ㄴ flex-direction )
									ㄴ 어떤 축을 기준으로 1줄로 배치할지 결정할수있다.
										ㄴ flex-direction : row ) 수평으로 한줄로 배치
										ㄴ flex-direction : colum ) 수직으로 한줄로 배치
										ㄴ flex-direction : row-reverse ) 수평으로 한줄로 순서를반대로하여 배치
										ㄴ flex-direction : colum-reverse ) 수직으로 한줄로 순서를 반대로 하여 배치.
								ㄴ flex-wrap )
									ㄴ 한줄로 배치할때 overflow되는경우 어떻게 처리할지 결정하는 속성.
								ㄴ flex-flow )
									ㄴ flex-direction과 flex-wrap의 shorthand.
									ㄴ 형식 ) flex-flow : (*flex-direction값*) (*flex-wrap값*) ;
								ㄴ align-items )
									ㄴ flex요소들의 정렬을 설정하는 속성.
									ㄴ 값 )
										ㄴ stretch : 디폴트값. 'cross axis'의 방향으로 요소들이 부모요소를 꽉채우도록 하는 설정.
										ㄴ center : 'cross axis'를 기준으로 요소들이 가운데 정렬이 되게하는 값.
										ㄴ flex-start, flex-end : 요소들이 'cross axis'의 시작부분이나 끝부분에 정렬될수있도록 하는 값.
								ㄴ justify-content )
									ㄴ main axis를 기준으로 flex의 요소들이 어떻게 정렬될지를 설정하는 속성.
									ㄴ 값 )
										ㄴ flex-start : 디폴트값. main axis를 기준으로 처음부분에 정렬.
										ㄴ flex-end : 위의 반대.
										ㄴ center : 중간
										ㄴ space-around : main axis를 기준으로 요소들을 균등한 간격으로 정렬시킴. (맨왼쪽과 오른쪽에 여백을 남긴다)
										ㄴ space-between : space-around와 같으나 맨왼쪽과오른쪽에 여백을 남기지 않는다.
							ㄴ 자식에 설정하는 속성 )
								ㄴ flex )
									ㄴ 1차원 배치상에서 해당 요소가 차지하는 사이즈를 설정.
								ㄴ order )
									ㄴ 디폴트로 0이 설정되어있다.
									ㄴ 값이 낮을수록 main axis를 기준으로 먼저나온다.
									ㄴ 같다면 소스상에서 먼저 나온 요소가 우선된다.

					ㄴ gird 값 )
						ㄴ display 속성의 값중 하나.
						ㄴ 요소를 2차원으로 배치하려할때 사용.
						ㄴ 구성 )
							ㄴ grid_layout.png 참조.
							ㄴ column과 row로 구성되고 그 사이사이를 gutter라고 한다.
						ㄴ 사용법 )
							ㄴ 부모요소에 display : gird 를 부여하면 grid layout이 되며 디폴트는 column하나라 normal flow와 차이가 없다. grid-template-rows, grid template-column을 통해
								gird layout을 구성하면 이에 맞게 요소들이 2차원구조안에 배치된다. ( table처럼 표형식으로 배치된다. )
						ㄴ 관련 속성 )
							ㄴ 부모에 사용하는 속성 )
								ㄴ grid-template-rows, grid-template-column ) gird layout을 구성하는 속성.
									ㄴ ex)
										grid-template-rows : 10px 10px 10px;		=>row가 높이 10px로 세줄로 구성.
										grid-template-column : 1fr 2fr 1fr 1fr; 	=>column이 해당 fr비율에 맞게 4칸으로 구성.
									* fr : 비율로서 값을 나타내는 단위. 가용한 공간을 해당 비율에 맞게 자동으로 부여한다. 위와같은 경우, 1: 2: 1: 1의 비율로 가용한공간을 분할하여 할당한다.
									ㄴ 값으로 repeat( (*원하는 column,또는 row수*), (*사이즈*) ) 를 사용할 수 있다.
										ㄴ ex) grid-template-rows : repeat ( 3, 1fr ) ;
								ㄴ grid-column-gap, grid-row-gap, gird-gap ) gird layout에서 각 column과 column사이, row와 row사이의 gap을 만들고싶을때 사용. 원하는 크기를 값으로 부여하면되며,
									gird-gap은 column, row동시적용할때.
								ㄴ grid-auto-columns, grid-auto-rows )
									ㄴ grid-template-rows,columns로 명시적으로 설정을 하지 않았거나 명시적으로 설정한 범위 이상으로 요소가 위치하게될때(요소가 명시한것보다 많거나하는경우) 이 auto속성값들이 적용된다
									ㄴ 값으로 minmax( (*최소값*), (*최대값*) ) 을 사용 할 수 있다. (안에 어떤 크기의 내용이 들어갈지 모르기때문에 사용하는것)
							ㄴ 자식에 사용하는 속성 )
								ㄴ grid-column-start, grid-column-end, grid-row-start, grid-row-end, gird-column, grid-row )
									ㄴ grid layout상에서 해당 요소의 시작위치와 끝위치를 설정하는 속성.
									ㄴ grid layout에서 각 column과 row를 구분하는 선이 있다고 보고 이 선을 값으로 주면된다. (column에선 맨왼쪽선이 1번, row에선 맨위에 선이 1번)
									ㄴ ex ) grid-column : 1/3; =>column상에서 첫번째선에서 시작해 3번째선에서 끝남.
									ㄴ grid-column, grid-row는 shorthand.
							ㄴ ...
				ㄴ Float 속성 )
					ㄴ 값으로 left, right, none, inherit이 있으며 해당요소는 normal flow에서 나와 부모요소의 한쪽에 위치하게 되며, 다른 요소들이 해당 요소를 감싸게 된다.
						ㄴ inherit은 부모요소의 float값을 상속받는단 의미.
					ㄴ https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats 에 잘나와있으니 더 알아야되면 그때 참고하자.
				ㄴ positioning )
					ㄴ 위에 정리한 내용있음.
				ㄴ multi-column layout )
					ㄴ 신문에서 글들이 표시된것처럼. 컬럼묶음으로? 글들을 나열하는 방식으로 구성하고싶을때 사용.
					ㄴ column-count, 또는 column-width를 이용해 글묶음의 개수를 지정하거나 넓이를 지정하면, 자식 내용들이 해당 값에 맞게 컬럼처럼 글이 묶음으로 배치된다.

			ㅡ border-collapse : table의 경계선이 하나로 합쳐져야하는지 분리되어야 하는지 설정
				ㄴ 값 : collapse, separate


			ㅡ 벤더 프리픽스 (Vender Prefix)
				ㄴ 웹표준이 아닌 특정 기능들을 사용하기 위해서 브라우저마다 해당 기능을 사용하기 위해서 붙이는 '접두어'.
				ㄴ ex)
					 .button {
		      				  background: red;          <!-- gradient 속성을 지원하지 않는 모든 브라우저를 위한 코드 -->
		 				  background: -webkit-linear-gradient(red, yellow); <!-- 크롬과 사파리 4.0 이상을 위한 코드 -->
		 				  background: -moz-linear-gradient(red, yellow);    <!-- 파이어폭스 3.6 이상을 위한 코드 -->
		 				  background: -ms-linear-gradient(red, yellow);     <!-- 익스플로러 10.0 이상을 위한 코드 -->
		 				  background: -o-linear-gradient(red, yellow);      <!-- 오페라 10.0 이상을 위한 코드 -->
						  background: linear-gradient(red, yellow);         <!-- CSS 표준 문법 코드 -->
				    	}

		</pre>
		자바 스크립트<button>더보기</button>
		<pre>
			기본<button>더보기</button>
			<pre>
				ㅇ 기본 )
					ㅡ 클라이언트쪽 브라우저 안에서 동작하는 코드.
					ㅡ ECMAScript 스펙을 따르는 프로그래밍 언어.
					* ECMAScript란?
						ㅡ ECMA 국제기구에서 설정한 프로그래밍 언어의 표준.
					ㅡ 개인적인 개요)
						ㄴ js가 하는일은 보통, 이벤트 처리, 그리고 그에 따른 동적인 화면조작(화면 요소조작)인것 같다.

				ㅇ 문법
				  		ㅡ js는 대소문자를 구분.
					ㅡ 리터럴 : 직접표현되는 값 자체를 말함
						ㄴex) 12 =>숫자 리터럴, "hello" => 문자열 리터럴
					ㅡ 식별자 : 변수나 함수의 이름.
						ㄴ 영문대소문자, 숫자, 언더스코어(_), 달려($)만 사용할수있다.
						ㄴ 숫자로는시작할수없다.
					ㅡ 키워드: js의 예약어.
						ㄴ function, var 등등.
					ㅡ 주석 : java와 같다.

				ㅇ js에서 출력하는방법
					1. window.alert() 메소드
						ㅡ 대화상자 창을띄워 내용을 출력해준다.
						ㅡ ex) alert(" (*내용*) ");
					2. HTML DOM요소를 이용한 innerHTML 프로퍼티
						ㅡ document객체의 getElementByID() 또는 getElementsByTagName()에 HTML요소를 인자로넘겨줌으로써 선택하고 반환받은 것을 변수에 저장하고 이에 대해
							innerHTML프로퍼티의 값을 바꾸면 선택한 요소의 내용이나 속성을 변경할수있다
						ㄴ ex) 	var str=document.getElementById(" (*id이름*) ");
								str.innerHTML = "(*바꿀내용*)";
								=>이렇게하면 id이름에 해당하는 요소의 내용이 (*바꿀내용*)으로 바뀜
					3. document.write()메소드
						ㅡ 페이지에 내용을 출력하는 메소드.
						ㅡ 웹페이지의 로딩시에 가장먼저 출력된다고함.
						ㅡ 다른내용들이 로딩된 이후에 이 메소드가 실행되면, 기존의 내용들을 다지우고 해당내용을 출력한다고한다.
						ㅡ 따라서 테스트나 디버깅용도로만 주로사용된다고함.
					4. console.log()메소드
						ㅡ 콘솔창에 출력.


				ㅇ js코드 삽입방법
					1. 내부 js코드
						ㄴex) < script>~~ < /script>로 코드를 삽입하는방법.

					2. 외부 js파일
						ㅡ 외부파일로 js를 만들에 삽입하는방법.
						ㅡ 외부의 js파일은 .js확장자를 가지며,
						ㅡ 삽입하려는 페이지에 삽입하면된다
							ㄴ ex) < script src="(*url*)">< /script>
						ㅡ 깔끔하ㅏ고 유지보수가 편해진다함.

				ㅇ js 타입<button>더보기</button>
                       <pre>
					ㅡ number. 숫자
						ㄴ 정수 실수 구분없이 모든수를 실수로표현.(64비트 부동소수점으로표현)
						ㄴ toString() 을 이용해 수를 여러진법의 형태로 바꿀수 있다.
							ex)	var num=100;
								num.toString(16);	=>16진법으로 변경.
								num.toString(8);	=>8진법으로 변경.
						ㄴ Infinity와 -Infinity라는 양의 무한대와 음의무한대를뜻하는 값이 있다.
						ㄴ NaN : 숫자가 아니라는 의미로, 정의되지 않은 값이나 표현할 수 없는 값을 가리킵니다.
					ㅡ 문자열. string
						ㄴ 큰따옴표나 작은따옴표로 둘러싸인 문자집합.
						ㄴ 큰따옴표 안에 작은따옴표. 또는 그반대 가능.
							ㄴ ex) "이것도 '문자열'입니다", '이것도 "문자열"입니다'
					ㅡ boolean
						ㄴ 참거짓값.
					ㅡ 심볼(symbol)
						ㄴ ECMAScript 6부터 새로나옴.
						ㄴ 유일하고 변경할수없는타입으로, 객체의 프로퍼티를 위한 식별자로 사용할수있다고함.
					* typeof연산자
						ㅡ 피연산자의 타입을 반환하는 연산자
						ㅡ ex)  typeof 10; =>number타입
					ㅡ null : object타입으로 아직 값이 정해지지않은것 의미.
					ㅡ undefined : null과 달리 타입이 정해지지 않은것.
                    ㅡ falsy value )
                        ㄴ 거짓 값.
                        ㄴ Boolean형과 만났을때 거짓으로 처리되는 값들을 말한다.
                        ㄴ 종류 )
                            ㄴ false, 0, -0, 0n, -0n, "", '', ``, null, undefined, NaN, document.all
                </pre>

				ㅇ js의 형변환
					ㅡ js는 상황에 맞게 자동으로 형을 변환해줌.
						ex) 10+"3" =>문자열3이 숫자3으로변환.
							1- "문자열" =>문자열이 NaN으로 변환( NaN은 표현할수 없는값이라는뜻)

					ㅡ명시적으로 타입을 변환할수도있다.
						ㄴ Number(), String(), Boolean(), Object() 등을 이용한다.
						ㄴex) Number("10"); =>문자열 10을 숫자10으로 바꿈
							String(true)=> boolean true를 문자열 true로 바꿈.
							Boolean(0)	=>숫자 0을 boolean false로 바꿈.

				ㅇ js연산자 )<button>더보기</button>
                <pre>
					ㅡ 산술, 비교, 대입, 증감, 논리, 비트 모두동일
					ㅡdelete연산자
						ㄴ 피연산자인 객체, 객체의 프로퍼티, 배열의 요소를 삭제.
						ㄴ 삭제되면 true반환. 아니면 false반환.
					ㅡ instanceof연산자
						ㄴ (*확인대상*) instanceof( (*비교대상*) )
							: 확인대상이 비교대상과 일치하는지를 알려준다. 단순히 객체인것뿐아니라 어떤 객체인지도 확인할 수 있다.
						ㄴ ex)	var str=new String("aaa");
								str instanceof Object; => true
								str instanceof String; => true
								str instanceof Array;  => false
					ㅡ typeof 연산자
						ㄴ typeof( (*확인대상*) ) : 대상의 데이터 유형을 확인하는 함수.
							ㄴ 'undefined', 'boolean', 'number', 'string', 'object', 'function' 중 어디에 속하는지 알려준다.
					ㅡ 전개연산자, '...' )
						ㄴ 함수의 인자나 배열의 인자에 값을 넣을때, 배열, 문자열 등의 반복가능한 값을 요소 하나하나로 전개하여 대입할수있게해주는 연산자.
						ㄴ ex)	function sum(x, y, z) {
								  return x + y + z;
								}

								const numbers = 'hello';
								const aa = [...numbers];
								console.log(...numbers);	// > "h" "e" "l" "l" "o"
								console.log(aa);			// > Array ["h", "e", "l", "l", "o"]
								console.log(sum(...numbers));	// > "hel"
							ㄴ 문자열 'hello'가 전개되어 요소 하나하나로 나뉘어 값이 들어간다.
							ㄴ 'hello'같은 문자열이 아니고 배열이어도 똑같다.
                    ㅡ 논리연산자 )
                        ㄴ && ) expr1 && expr2  : expr1이 true이면 expr2를 반환, 아니면 expr1을 반환.
                        ㄴ || ) expr1 || expr2  : expr1이 true이면 expr1을 반환, 아니면 expr2를 반환.
                        ㄴ ! ) !expr1  : expr1이 true이면 false반환, 아니면 true반환.
                </pre>
				ㅇ 제어문
					ㅡ 조건문 : 자바와 동일
					ㅡ 반복문
						ㅡ for, while 자바와 동일.
						ㅡ for/in문 : 해당 객체의 모든 열거할수 있는 프로퍼티에 대해 반복을해주는 반복문.
							ex) for( (*변수*) in (*객체*) ){ (*반복하는부분*) }
								=> 객체의 모든 프로퍼티에대해 각각을 변수에 넣어 반복하는부분 실행해줌.
						* 열거할수 있는 프로퍼티 :내부적으로 enumberable 플래그가 true로 설정된 프로퍼티를 의미.

						ㅡ for/of문 : 반복할수있는객체를 반복해주는 반복문.
							ex) for( (*변수*) of (*객체*) ){ (*반복하는부분*) }
						*반복할수있는객체란 : js에서는 Array, Map, Set, arguments 객체 등이있다.

						ㅡ continue, break 자바와 동일.

				ㅇ 배열<button>더보기</button>
                <pre>
					ㅡ 배열은 js에서 Array객체에 해당한ㄴ다.
					ㅡ 요소로 아무 타입이나올수있으며 모두 동일하지 않아도된다.
					ㅡ 생성
						ㄴ ex)	var arr=[ ~~, ~~, ...];
								var arr=Array(~~, ~~, ...);
								var arr= new Array(~~, ~~, ...);
					ㅡ 배열의 참조
						ㄴ 자바와 동일.
						ㄴ ex) (*배열이름*)[ (*인덱스*) ]
						ㄴ 배열 객체에 length라는 프로퍼티로 배열의 길이가 저장되어있다.
					ㅡ 배열의 추가
						ㄴ ex) 	(*배열이름*).push( (*추가할요소*) );
								(*배열이름*)[(*배열이름*).length] = (*추가할요소*);
								(*배열이름*)[(*특정 인덱스*)] = (*추가할요소*);
					ㅡ 배열 객체의 함수 )
						ㄴ pop() : 맨 뒤 index에서부터 하나씩 삭제하고 반환.
						ㄴ unshift() : 맨 뒤 index부터 하나씩 삭제하고 반환.
						ㄴ shift()
						ㄴ push()
						ㄴ splice( (*index*), (*개수*) ) : (*index*)위치에서 (*개수*)만큼 뽑아서 삭제후 배열형태로 반환.
						ㄴ join( (*구분자*) ) : 배열안의 요소들을 (*구분자*)를 기준으로 하나의 문자열로 합침.
							ㄴ ex)	var i = [ 2,3, 4,5 ]
								i.join(',')	=> "2,3,4,5"
					ㅡ 희소배열
						ㄴ js의 배열은 꼭 순차적인 인덱스대로 값을 넣지 않아도 된다.
						ㄴ 이런특성으로 인해, 배열의 요소의 위치가 연속적이지 않은 배열을 희소배열이라한다.
						ㄴ ex) var arr= new Array();
							arr[99]="aaa"; => 0부터 98인덱스에 암것도 안넣고 99에 값넣음.
					ㅡ 다차원배열
						ㄴ Array를 하나 만들고 각 인덱스에대해 Array를 또만드는식으로 생성가능.
					ㅡ 연관배열
						ㄴ 인덱스값으로 숫자가 아닌 문자열로된 '키'값을 지정하는 배열을 말하는데. js에서는 따로 지원을 하지않아 만들수는 있지만 내부적으로 Array객체의 length프로퍼티가 사라짐.
							ex) 	var arr=[]; =>이렇게 배열하나 만들고
									arr["하나"] = 1; =>이렇게 키값형태로 인덱스저장을하면
									document.write(arr.length); =>안나옴.
					ㅡ js의 문자열은 []연산자를 사용하여 각 인덱스에 해당하는 문자를 읽어올수있다. (읽어올수만 있다)
				</pre>
				ㅇ 함수
					ㅡ js에서 함수는 데이터 타입의 일종.
					ㅡ function키워드로 정의한다.
						 ex)	function (*함수이름*)( (*매개변수1*), ...){
							  	(*함수내용*)
								}
					ㅡ 함수를 변수에 저장할수도있다.
						ex)	function sqr(x){~~}
							var aaa=sqr;
							aaa(4);	=>저장한 변수를 통해 함수호출.
					ㅡ 매개변수)
						ㄴ arguments : 함수가 기본적으로 가지고있는값으로 배열은 아니지만 배열과 유사.

				ㅇ 함수의 매개변수
					ㅡ js에서는 함수정의시 매개변수 타입을 따로 정의하지않음. 따라서 호출시 전달하는 인자의 타입검사또한 없음. 그만큼 형식에서 자유롭다.
					ㅡ 인자의 개수또한 자유롭다. 매개변수보다 적으면 인자를받지못한 매개변수는 undefined로, 더 많으면 매개변수에 저장이 안되어도 arguments객체에 저장이된다.
					ㅡ arguments객체 : 함수가 기본적으로 가지고있는객체로, Array는 아니지만 Array와 유사하다.
						ㄴ 함수호출시 전달된 인자를 순서대로 저장하고있으며
						ㄴ arguments[ (*인자의 인덱스*) ] 형태로 접근할수 있다.
						ㄴ length프로퍼티도 가지고있어 인자의 개수를 알수있다.ex) arguments.length

				ㅇ 변수의 유효범위<button>펼치기</button>
				<pre>
					ㅡ js는 다른언어와 다르게 영역을 {}단위로 나누지 않고 함수단위로 나눈다.
						따라서 {}안에있으면 지역변수, 밖에있음 전역.이게아니라 함수안에있으면 지역변수, 밖에있으면 전역변수가된다.
						ex) for(var i=0;i<3;i++){~~} => 변수i는 전역변수이다. for문이끝나도 접근가능.
					ㅡ 함수 내에서 선언되었으면 지역변수. 자바의 지역변수와 동일.
					ㅡ 함쉬 외에서 선언되었으면 전역변수. 자바의 전역변수와 동일.
					ㅡ 따라서 js에서는 되도록 전역변수말고 지역변수를 쓰는게 좋다.

					ㅡ변수 호이스팅
						ㄴ 호이스트란 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는것을 의미한다.
						ㄴ 즉, var a=10;과 같이 정의가 되어있어도 이 정의가 코드 어느위치에 있건 해당 변수의 '선언'이 코드 최상위 부분으로 변경되는것. (지역변수일경우 함수의 최상위,
							전역일경우 전역코드의 최상위) '선언'위치는 이렇게 바뀌고 초기화나 할당은 원래의 위치에서 발생.
							ex) var a = 10; 이면 최상위 부분에 var a가 오고 원래의 위치에 a=10;이 온다고 이해하면 된다.

					ㅡ js의 스코프 )
						ㄴ 식별자의 유효범위. 자신이 어디서, 어떻게 선언되었는지에 따라 스코프가 결정된다.
					ㅡ js의 식별자 선언 세가지 : var, let, const )
						ㄴ var : 함수 스코프를 따른다. 자신이 선언된 곳과 가장 ㅏㄱ까운 함수를 스코프로 가진다.
							ㄴ ex)
								var x =0;
								{
									var x =1;
									console.log(x); //1
								}
								console.log(x); //1	=>var은 함수 스코프를 따르기때문에 첫번째 var x, 두번째 var x모두 같은 메인함수안에있고 둘다 메인함수의 스코프를 가진다. 따라서 첫번째에서 0을 넣었지만 두번째에서 덮어씌워진것.
										ㄴ let, const : 블록 스코프를 따른다. 자신이 선언된 곳과 가장 가까운 블록을 스코프로 가진다.
											ㄴex)
								let x = 0;
								{
									let x=1;
									console.log(x);//1	=>let은 블록 스코프를 가직때문에 여기서의 x는 같은 블록안에있는 바로 위의 1이 들어간 x이다.
								}
								console.log(x);//0	=>여기서의 x는 맨처음 0이 들어간 x이다.
									ㅡ 스코프 체인 )
										ㄴ js는 식별자를 찾을때 자신이 속한 스코프에서 찾지 못하면 그 상위스코프에서 식별자를 찾는다. 이러한 방식을 '스코프 체인'아라한다ㅏ.
										ㄴ 상위 스코프 결정 )
											ㄴ 어떤 스코프가 상위 스코프인지 결정하는 방법에는 두가지가있다.
											ㄴ 동적 스코프 ) 함수의 호출 지점을 기준으로 상위스코프를 결정
											ㄴ 렉시컬 스코프 ) 함수의 선언 지점을 기준으로 상위스코프를 결정.
											ㄴ ex)
								var x = 1;

								function foo() {
								  var x = 10;
								  bar();
								}

								function bar() {
								  console.log(x);
								}

								foo(); // 10? 1?	=> 동적 스코프일경우, foo()호출->bar()호출->console.log(x)호출->bar()안에 x가없음->상위스코프에서탐색(bar()를 호출한곳인 foo()가 상위스코프로 결정)->var x=10찾음->10출력
											렉시컬 스코프인경우, foo()호출->bar()호출->console.log(x)호출->bar()안에 x가없음->상위스코프에서탐색(bar()가 선언된곳인 main()가 상위스코프로 결정)->var x=1찾음->1출력.
								bar(); // 1

					ㅡ js 함수의 bind() 메소드 )
						ㄴ https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind참조
						ㄴ Function.prototype.bind()
						ㄴ 어떤 함수에게 그 함수 안에서 사용될 this값을 넘겨줄수있는 메소드. (다른기능들도있는듯하다)
						ㄴ 위에서 나오는 js의 this의 특징으로 인해, 함수안에서 this사용시, 그게 어떤것인지 정확하게 장담할수없다. 따라서 이 메소드를 통해 함수안에서 사용될this가 무엇인지를 결정할 수 있다.
						ㄴ ex)
							this.x = 9;
							var module = {
							  x: 81,
							  getX: function() { return this.x; }
							};

							module.getX(); // 81

							var retrieveX = module.getX;
							retrieveX();
							// 9 반환 - 함수가 전역 스코프에서 호출됐음

							// module과 바인딩된 'this'가 있는 새로운 함수 생성
							// 신입 프로그래머는 전역 변수 x와
							// module의 속성 x를 혼동할 수 있음
							var boundGetX = retrieveX.bind(module);	=>retrieveX함수 안에서의 this는 module객체임을 지정.
							boundGetX(); // 81
					ㅡ javascript의 this
						ㄴ 함수에서 사용되는 this는 어떻게 호출되는지에 따라 내용물이 달라진다.
							ㄴ ?????
						ㄴ '화살표 함수'를 사용하고 그안에서 this를 호출하는 경우 )
							ㄴ 이 경우에는 화살표함수를 둘러싸는 '렉시컬 범위'의 this가 사용된다.

				</pre>
			    ㅇ 구조 분해 할당 <button>더보기</button>
			   	<pre>
                    ㅡ 배열과 객체를 하나의변수에 한번에 저장하는것이 아니라, 여러 변수에 분해해서 저장할 수 있는 기능.
                    ㅡ ex )
                        const arr = ["name1", "name2"];
                        const [aaa, bbb ] = arr ; //변수 aaa, bbb가 생기고, aaa에는 'name1'이, bbb에는 'name2'가 들어간다.

                        객체 )
                        let obj = {
                            title : 'sampleTitle',
                            name : 'sampleName'
                        }
                        let {title, name} = obj;  // 변수 title, name이 생기고, title에는 obj.title인 'sampleTitle'이, name에는 obj.name인 'sampleName'이 들어간다.
                    ㅡ 배열의 구조 분해 할당 )
                        ㄴ 좌측 변수에 컴마를 기준으로 인덱스순서대로 배열의 값이 분해되어 할당된다.
                        ㄴ 컴마를 비울수도있고 (ex) const [a, , b] = "hello";
                        ㄴ 변수의 수와 할당하려는 배열의 수가 맞지 않으면 알아서 조정된다. 배열의 수가 부족하면 변수가 undefined로 비게되고,
                            배열의 수가 더 많으면 있는 배열의 수만큼만 들어간다.
                        ㄴ 좌측에 ...rest를 사용할 수있다. 남은 배열값들이 배열로 할당되게 된다.
                            ㄴ ex)
                                const arr  = ['a','b', 'c', 'd'];
                                const [ x, y, ...z ] = arr; //x='a', y='b', z=['c', 'd']
                        ㄴ 문자열도 할당할수잇으며, 문자 하나가 배열의 한 요소가 된다. ex) const [a,b,c] = "hello";
                        ㄴ 문자열뿐만 아니라 set 등 '반복가능한 객체'는 뭐든 올 수 있다.
                    ㅡ 객체의 구조 분해 할당 )
                        ㄴ 순서와 상관없이 객체의 키값과 일치하는 변수명에 값이 할당된다.
                        ㄴ 마찬가지로 ...rest를 사용할 수있다. 남은 값들이 객체로 들어간다.
                        ㄴ 키값이 아닌 원하는 변수명을 설정할 수도 있다.
                            ㄴ ex) let { title : t, name : n } = obj;    //obj.title인 'sampleTitle'은 변수 t에, obj.name인 'sampleName'은 변수n에 저장.
                        ㄴ 키값이 없을시 디폴트값 설정도 가능하다.
                            ㄴ ex) let { title : t = 'noTitle', name = getDefaultName() } = arr ;
                            ㄴ ' = '을 붙여 디폴트값을 설정한다. 값이 아닌 함수를 줄 수도 있다.
                        ㄴ 중첩 객체의 구조 분해 할당 )
                            ㄴ 객체 구조를 똑같이 맞춘다면 중첩객체도 구조분해 할당이 가능하다.
                            ㄴ ex)
                                let options = {
                                  size: {
                                    width: 100,
                                    height: 200
                                  },
                                  items: ["Cake", "Donut"],
                                  extra: true
                                };

                                // 코드를 여러 줄에 걸쳐 작성해 의도하는 바를 명확히 드러냄
                                let {
                                  size: { // size는 여기,
                                    width,
                                    height
                                  },
                                  items: [item1, item2], // items는 여기에 할당함
                                  title = "Menu" // 분해하려는 객체에 title 프로퍼티가 없으므로 기본값을 사용함
                                } = options;
                            ㄴ 단, size, items라는 변수를 생성되지 않는다. 그 하위 요소인 width, height, item1, item2만 변수로 생성되고 값이 할당된다.
                </pre>
			</pre>
			함수와 객체, 프로토타입<button>더보기</button>
			<pre>
				ㅇ 생성자 함수
					ㅡ js에서 함수는 그냥 함수일뿐만 아니라 객체를 만드는데도 쓰인다. 정의된 함수앞에 new라는 키워드를 붙이면되는데,
			  			ex) function Person(name){
							this.name= name;					=>객체로만들어졌을시 name이란 변수를갖게됨.
							this.introduce =  function(){		=>객체로만들어졌을시 introduce란 메소드를가짐.
								return 'My name is '+this.naem;
							}
						}
						var p = new Person('tjrgh');			=>'tjrgh'를 name매개변수로 넘겨주어 함수Person을
																	객체로서 만들어줌.
					ㅡ 이렇게 객체를 만드는데 쓰이는 함수를 '생성자 함수'라고 하고,
						구분을 위해 첫알파벳을 대문자로써준다.

				ㅇ 객체
					ㅡ 개요)
						ㄴ js에서 객체는 이름(name)과 값(value)로 구성된 프로퍼티의 정렬되지 않은 집합을 말한다.
						ㄴ 자바의 'map'자료형과 유사.
					ㅡ 형식)
						var (*이름*) = { (*키1) : (*값1*), (*키2*) : (*값2*), ...};
						또는
						var (*이름*) = {};
						(*이름*)[ (*키1*) ] = (*값1*);
						(*이름*)[ (*키2*) ] = (*값2*);
						...
						또는
						var (*이름*) = new Object();
						(*이름*)[ (*키1*) ] = (*값1*);
						...
						ㄴ 이렇게 만들어진 객체를 인스턴스라고한다.
					ㅡ 값을 읽을때)
						ㄴ	(*이름*)[" (*키*) "]
							또는
							(*이름*).(*키*);
						ㄴ 모든값을읽고싶을때는 반복문사용시 인덱스값이 없으므로 for/in문을사용.
					ㅡ 메도스호출할때)
						ㄴ 프로퍼티로 함수가 올수있으며 이때이함수를 '메소드'라고한다.
						ㄴ (*이름*).(*메소드이름*)();
						ㄴ (*이름*).(*메소드이름*) 이렇게만쓰고 뒤에 ()를붙이지않아 호출을하지않으면 프로퍼티값자체가 반환이되어 메소드정의자체가 반환된다.
					ㅡ js에서는 숫자, 문자열, boolean, undefined타입을 제외하고는 모두 객체이다.
					ㅡ 수사, 문자열, boolean도 값이정해진 객체로 취급되어 객체의특징도 갖는다.
					ㅡ 객체 초기화시, '계산된 속성명(computed property name)'을 사용할수있다.
						ㄴex) var a = {
								[name + 1] : value1,
								[name + '22'] : value2
							}
						ㄴ 프로퍼티부분에 []를 주고 그안에 js의 식을 사용할 수 있다.

				ㅇ 프로토타입이란?<button>더보기</button>
				<pre>
					ㅡ js의 모든 객체는 함수이다.
						ㄴ Object도 fucntion으로 정의된 함수의 일종.

					ㅡ 개요)
						간단하게말하면, 객체에 대해 인스턴스생성시마다 인스턴스를 새로 생성하는게 아니고 원형이되는 프로토타입을 하나 만들어놓고 인스턴스들이 그 프로토타입객체를 참조해서 사용하는 방식.???

					ㅡ함수가 정의될때 일어나는일)
						ㄴ 해당함수에 생성자 자격을 부여한다고한다. 이를통해 해당 함수에 대해 new키워드로 객체를 생성할수있다.(생성자 함수)
						ㄴ Prototype Object도 같이 생성된다.
						<img src="image/프로토타입구조1.png" style="height:300px; width:auto;">

					ㅡ 생성된함수는 prototype이라는 속성을 통해 Prototype Object에 접근가능.
						ㄴ 이 함수를 생성자로서 객체생성시(new연산사용해서), 생성자에 해당하는 함수의 prototype속성이 가리키는 Prototype Object가 만들어지는 객체의 프로토타입이 된다.
							ex) var date = new Date();	=> date객체는 Date()함수의 prototype속성이 가리키는 Prototype Object를 프로토타입으로 갖는다.

					ㅡ Prototype Object는 constructor, __proto__라는 속성을 가짐.
						ㄴ contructor는 Prototype Object와 함께 생성되었던 함수를 가리키고있다.
						ㄴ __proto__ 속성은 모든 객체가 가지고있는 속성으로서, 객체가 생성될 당시 원형이 되는 함수의 Prototype Object를 가리키는 값이다.
							<img src="image/프로토타입구조2.png" style="height:300px; width:auto;">
							ex)	function Person(){};	=>이렇게 함수가 생성되었을때 함수에 생성자 자격이 부여되고 이 함수에 대한 Prototype Object가 생성된다.
								var kim= new Person();	=> 함수를 객체로 생성하여 kim에 넣었다.
								=> 이렇게 되면 kim은객체이므로 __proto__속성을 가지고 잇으며 그 값은 kim객체의 원형이 되는 함수인 Person()함수의 Prototype Object.
									Person()함수가 생성되었을때 같이 생성된 Person()함수의 Prototype Object가 __proto__값으로 들어있다.
					ㅡ 이 __proto__속성값을 통해 kim이 원형인 Prototype Object를 참조하는식으로 객체가 동작????
					ㅡ __proto__를 참조하여 속성을찾고 없으면 __proto__의 __proto__로 올라가서 찾고 이런식으로 작동. 이런식으로 상속을 구현하며, 이렇게 엮여있는것을
						'프로토타입체인'이라고함.
						<img src="image/프로토타입구조3.png" style="height:300px; width:auto;">
						ㅡ 객체에 프로퍼티 및 메소드 추가하기)
							ㄴ ex)	function Dog(color, name, age){
										this.color=color;
										this.name=name;
										this.age=age;
									}
									var myDog = new Dog("~~~);
									myDog.family="~~";	=>이렇게 새로운 프로퍼티를 추가.
									=>이렇게 인스턴스에 추가를하면 그냥 해당인스턴스에만 추가가 되며, 프로토타입이나 같은프로토타입을가지는 다른인스턴스에 영향x.

					ㅡ 프로토타입에 프로퍼티 및 메소드추가하기)
						ㄴ 생성자함수의 prototype속성에 추가함으로서 프로토타입에 프로퍼티 및 메소드 추가가능.
						ex)	위 예에 이어서..
							Dog.prototype.breed="~~";	=>이러면 프로토타입에 breed프로퍼티가 추가되어 현존하는 인스턴스뿐아니라 새로생길 인스턴스에 모두 적용.

					ㅡ this 키워드
						ㄴ this는 this가 있는 위치의 영역을 포함하고있는 객체를 가리킨다.
							ex)	메소드 내부에선 메소드를 포함하고있는 객체,
								객체 내부에선 객체 그자체.
						ㄴ 생성자함수 내부에서 사용되는 this는 어떤값도 가리키지않으며 앞으로 생성될 객체로 값이 채워진다.

					ㅡ 객체 프로퍼티 삭제하기
						ㄴ delete (*객체이름*).(*프로퍼티이름*); 을하면 객체의 프로퍼티가 삭제됨.
						ㄴ '프로퍼티'삭제이므로 함수나 변수에는 작동 x.

					ㅡ 객체의 비교
						ㄴ완전히 동일한 인스턴스가 아닌이상 비교연산자(==, ===)는 false가 나옴.

					ㅡ Object의 메소드
						ㄴ 모든 객체는  Object.prototype이 가리키는 객체를 상속받으므로 여기에 있는 프로퍼티와 메소드를 사용할수있다.
						ㄴ hasOwnProperty() : 해당객체에 특정 프로퍼티가 존재하는지를 판별하여 boolean값 반환. 직접선언된 프로퍼티만을 검사하므로 상속받은건 없는셈친다.
						ㄴ propertyIsEnumerable() : hasOwnProperty()를 만족하면서 열거할수있는 프로퍼티인지 검사하여 boolean값 반환.
						ㄴ isPrototypeOf() : 특정객체의 프로토타입체인에 현재 객ㅊ체가 존재하는지.
						ㄴ toString() : 호출한 객체의 값을 문자열로 반환.
						ㄴ valueOf() : 모르겟다.
						ㄴ getter, setter : 모르겟다.
				</pre>
				ㅇ 기타 <button>더보기</button>
				<pre>
					ㅡ Rest 파라미터 <button>더보기</button>
					<pre>
						ㄴ 함수에 몇개의 인자가 들어올지 알 수 없을때, 이 정해지지 않은 개수의 인자를 받게해주는 문법이다.
						ㄴ 간단 사용법 )
							ex)	function myFunc(a, b, ...theArgs) {	//함수의 인자 중 마지막인자의 앞에 '...'을 붙여준다.
								  // ...
								}
								~~~~~
								myFunc("one", "two", "three", "four", "five", "six");
													//함수 호출시, 인자a,b와 매핑되는 처음 두개 이외에, 그 뒤로 몇개의 인자가 오든,
													이 추가적인 인자들은 Rest파라미터인 theArgs안에 js배열의 형태로 저장된다.
													즉, theArgs안에 ['three','four','five','six']가 저장되어있다.

					</pre>

				</pre>
				ㅇ 표준 내장 객체<button>더보기</button>
				<pre>
					ㅡ Object 객체<button>더보기</button>
					<pre>
						ㄴ ~~~~~
						ㄴ 메소드<button>더보기</button>
						<pre>
							ㄴ ~~~~~
							ㄴ is()<button>더보기</button>
							<pre>
								ㄴ 두 값이 같은지 비교
								ㄴ ~~~~~
								ㄴ ==연산자나, ===연산자와 같지 않다.
							</pre>
						</pre>
					</pre>
					ㅡ Date <button>more</button>
					<pre>
						ㄴ ~~~~~
						ㄴ 메소드 <button>more</button>
						<pre>
							ㄴ toISOString()
                                ㄴ iso형식으로 문자열 반환. ex) 2011-10-05T14:48:00.000Z
                                ㄴ utc기준 시간으로 자동 변환한다.
                                    가령, 한국이라 GMT+9000인 경우, toISOString()은 -9시간을 하여 반환.
                                    ex )
                                        new Date()  // Thu Oct 20 2022 12:24:12 GMT+9000 (한국 표준시)
                                        new Date().toISOString()  // "2022-10-20T03:25:33.691Z"
                            ㄴ getHours()
                                ㄴ 시간 integer값 반환. local timezone에 맞게 반환.
                            ㄴ getUTCHours() : getHours()의 utc버전.
                            ㄴ getTimezoneOffset()
                                ㄴ utc시간에서 현재 local timezone 시간을 뺀 값을 분단위 integer로 반환.
                                    ㄴ ex ) 한국의 경우, +0900이므로, -9시간 즉, -540.

						</pre>

					</pre>
					ㅡ Array <button>more</button>
					<pre>
						ㄴ ~~~~~
						ㄴ 메소드 <button>more</button>
						<pre>
							ㄴ slice( [beginIdx [, endIdx]] )
								: beginIdx의 인덱스부터 끝까지, endIdx가 있을시, endIdx의 인덱스 전까지에 해당하는 부분을 자른 배열을 복사한 새 배열 반환.
									숫자, 문자열 등의 일반 데이터는 새로
						</pre>
					</pre>

				</pre>

			</pre>
			이벤트<button>더보기</button>
			<pre>
				ㅇ 이벤트<button>더보기</button>
				<pre>
					ㅡ 웹브라우저가 알려주는 html요소에 대한 사건발생의미.
					ㅡ js는 이 사건에 대해 특정 동작을 수행할수있다. (이벤트중심 프로그래밍)
					ㅡ 이벤트 타입 : 발생한 사건, 즉 이벤트의 종류를 나타내는 문자열.
					ㅡ 이벤트 명세?????
					ㅡ 개인적인정리)
						ㄴ 이벤트에서 고려해야할것 : 어떤요소에서 발생했는지, 어떤 이벤트인지(이벤트 타입), 어떤동작을 할것인지(리스너), 어떻게 등록할것인지.

					ㅡ 이벤트 리스너
						ㄴ 이벤트 발생시 그 이벤트 처리를 담당하는 함수를 말함. 이벤트 헨들러라고도함.

					ㅡ 이벤트 등록
						ㄴ 세가지 방법이있다.
						1. 자바스크립트 코드에 프로퍼티로 등록
							ㄴ ex) window.onload = function(){~~~}
							ㄴ function이 리스너부분. onload가 어떤 이벤트인지지정하는것.
							ㄴ 어떤 요소에서 발생하는지 특정하기가 어렵다.
							ㄴ 이벤트 종류당 한가지 리스너밖에 등록할수없다.

						2. html 태그 속성에 등록
							ㄴ ex) < p onclick = "alert(~~~)">
							ㄴ 요소특정이 가능하고, 1번과 달리 한종류의 이벤트장 한 리스너만있지않아도된다.
							ㄴ 대신 가독성이떨어진다함.

						3. addEventListener()이용
							ㄴ 형식) (*객체*).addEventListener( "(*이벤트명*)", (*리스너*), (*이벤트 전파방식*) );
							ㄴ ex)	var aaa= document.getElementById("(*id명*)");	=>id명에 해당하는 태그를 반환하여 aaa에 저장.
								aaa.addEventListener("click", ~~~);	=>해당 태그들에 click이벤트 리스너 등록. 클릭이벤트발생시 해당리스너가 실행되게됨.
							ㄴ 버전에따라 위함수가 지원되지않을경우 attackEvent()를 사용해야함.

					*document.getElementById()
						ㅡ 인자로준 id에 해당하는 요소하나를 반환한다.
						ㅡ document.getElementsByTagName()은 인자로넘긴 태그명에 해당하는 컬렉션을 반환한다고함.

					ㅡ이벤트 삭제
						ㄴ (*객체*).removeEventListener( "(*이벤트명*)", (*리스너*) );

					ㅡ 이벤트 호출
						ㄴ 리스너가 등록되면, 해당 요소에서 지정된이벤트발생시 브라우저가 해당 리스너를 호출한다.
						ㄴ호출하면서 '이벤트 객체'를 인자로 전달한다.
						ㄴ 이벤트객체에는 해당 이벤트에 대한 정보를 가지고 있으며, 어떤이벤트인지를 나타내는 type프로퍼티와 이벤트대상을 나타내는 target프로퍼티가있다.

					ㅡ 이벤트 호출순서
						ㄴ 하나의 이벤트종류에 여러개의 리스너가 있으면, 브라우저는 위 이벤트 등록방법에서 1,2로 등록한 이벤트리스너를 먼저 실행하며 그다음 3으로 등록한 이벤트리스너를 호출한다.

					ㅡ 이벤트 전파 (event propagation)
						ㄴ js에선 요소에서 이벤트가 발생하면 그 요소에서만 발생하지 않고 이벤트가 DOM구조를 타고 전파한다.
						ㄴ 버블링방식과 캡쳐링 방식이 있다.
						ㄴ ex)
							< body>
								< div class="one">
									< div class="two">
										< div class="three">
										< /div>
									< /div>
								< /div>
							< /body>
						ㄴ 버블링방식)
							ㄴ 이벤트가 발생한 요소로부터 부모요소쪽으로 root요소까지 이벤트가 전파되는 방식.
							ㄴ 위의 예에서, class 'three'에서 클릭 이벤트가 발생하면, three으로 이벤트전달된뒤, two, one, body...순서로
								이벤트를 받게된다(전파된다).
							ㄴ 물론 이 이벤트에 해당하는 핸들러가 있을시 이벤트를 받아서 처리하게되며, 없으면 아무것도일어나지않고 위로 전파하게된다.
						ㄴ 캡쳐링방식)
							ㄴ root요소로부터 이벤트가 발생한 요소까지 이벤트가 전파되는 방식.
							ㄴ 위의 예에서, class 'three'에서 클릭 이벤트가 발생하면, ... body, one, two, 그리고 three순서로
								이벤트를 받게된다.


					ㅡ 이벤트 기본동작의 취소
						ㄴ < a>요소는 클릭이벤트 발생시 해당 url로 이동하는 동작이 지정되어있다. 이런것들을 기본동작이라고한다.
						ㄴ preventDefalult()메소드나 returnValue프로퍼티를 이용하여 이런 기본동작을 취소할수있다.

					ㅡ 이벤트 전파의 취소
						???
				</pre>
				ㅇ 이벤트 객체<button>더보기</button>
				<pre>
					ㅡ js의 Event interface를 말한다.
					ㅡ 유저의 동작(마우스, 키보드 클릭 등), api호출, 임의의 이벤트 발생함수호출 등을 통해 생성되며, 특정 DOM타겟에게 전달된다.
					ㅡ 이 Event interface를 상속하는 많은 이벤트 인터페이스들이 존재한다.
						ㄴ ex) FetchEvent, FocusEvent, InputEvent, KeyboardEvent, MouseEvent
					ㅡ properties )
						ㄴ ~~~~~
						ㄴ target )
							ㄴ read only
							ㄴ 이벤트를 발생된 dom을 가리킨다.
						ㄴ currentTarget )
							ㄴ read only
							ㄴ 현재 이벤트객체를 받아서 가지고있는 dom을 가리킨다.
								ㄴ target과의 차이점 )
									ㄴ 클릭 이벤트가 버블링되어 전달되는경우를 생각해볼때, target은 클릭된 dom자체를 가리키지만,
										currentTarget은 클릭된 dom으로부터 이벤트객체가 전파되어 어느 이벤트핸들러가받게되면,
										해당 이벤트핸들러가 부착되어있는 dom을 가리키게된다.
									ㄴ ex)
										< li onclick="sampleFunc()"> < span> sample button < /span> < /li>
										ㄴ sample button을 클릭하게되면 span dom이 클릭되고, 이벤트를 발생시킨 dom은 span이므로,
											target은 항상 span dom을 가리키게된다.
										ㄴ span에서 발생한 이벤트가 전파되어 li에게 전달되면, li의 이벤트핸들러 sampleFunc()가 이벤트를 받아
											처리하게되고 이때 currentTarget은 li dom을 가리키게된다.
						ㄴ ~~~~~
					ㅡ method )
						ㄴ ~~~~~
						ㄴ preventDefault() )
							ㄴ 이벤트의 기본동작을 중지한다.
						ㄴ ~~~~~

				</pre>
			</pre>
			문서조작<button>더보기</button>
			<pre>
				ㅡ js의 일반적으로하는일중 하나는 문서구조를 어떤방식으로 조작하는것이다.
				ㅡ 그리고이것은 DOM과 Document객체를 사용하여 많이 수행된다.

				ㅇ DOM (Document Object Model)
					ㅡ DOM은 일종의 문서에대한 표현방식이다. 더 자세히말하면, DOM방식은 문서를 구조화된 nodes, 프로퍼티, 메소드를 가지고있는 객체로 표현한다.
						(일종의 객체지향표현방식이라 할수있다)
						ㄴ html을 예로들면, 여러태그들, < html>, < a>, < body>등을 객체로서 보고 문서를 인식하는 방식을 말함.
						ㄴ 그리고 이런방식은 프로그래밍언어가 문서의 내용을 다룰수있게 해준다.
						ㄴ DOM API를 통해 이 객체들을 다룰수 있다.
							ex) document.getElementById("~~");
						<img src="image/html dom 구조 예.png" style="height:300px; width:auto;">
					ㅡ 웹페이지가 로딩될때 브라우저는 위 그림과같은 HTML DOM을 내부적으로 생하며, 브라우저마다 각기의 방식으로 문서를 DOM으로 구현한다.

						<img src="image/html dom 구조 예2.png" style="height:300px; width:auto;">
					ㅡ 구조가 바로 위 그림과같이되어있다.
						ㄴ 어떤요소노드의 자식노드로 (만약 그 요소가 내용을 갖는다면) 가장먼저 그요소의 내용노드(즉, 텍스트노드)가 오고, 그다음에 나머지 자식요소들이온다.
						ex)	< ul id="list"> aaa
								< li> bbb < /li> ccc
								< li> ddd < /li> eee
								< li> fff < /li> ggg
							< /ul>
							=>이럴때 ul태그의 첫번째 자식노드는 바로아래있는 li태그가 아닌 ul의 내용인 "aaa"가 된다. li는 그다음자식노드.
							그림으로설명하면,
								ul
									ㄴ ul의 텍스트("aaa")		=>첫번째자식노드
									ㄴ 첫번째 li				=>두번째자식노드
										ㄴ li의 텍스트("bbb")	=>...
									ㄴ li뒤의 텍스트 노드("ccc")
									ㄴ 두번째 li
										ㄴ li의 텍스트("ddd")
									ㄴ 두번째li뒤의 텍스트("eee")
									...
							이런식이다.
						ㄴ NodeList건 HTMLCollection이건 이게 DOM구조이기때문에 이걸따름.

					ㅡ HTML문서에서 dom구조는 node tree형태이며, 각 요소들, 즉 객체는 node에 대응된다. 속성,또한 노드이다.

					ㅡ 객체 지향 구조이기때문에 Document인터페이스, HTMLDocument인터페이스, HTMLElement인터페이스, Element 클래스, Node 인터페이스,
						등 여러 클래스와 인터페이스가 상속,구현관계에 있으며 이들이가지고있는 프로퍼티와 메소드로 문서를 조작한다.
						ex) < talbe> 태그에 해당하는 노드는 Node인터페이스 및 HTMLElement인터페이스 Element클래스 등 여러가지를 가지고있다.

				ㅇ 요소 선택하기
					ㅡ DOM 요소를 조작하기위해선 우선 해당요소를 선택하고 변수에 참조를 저장해야한다.
					ㅡ 가장 최신 메소드로 document.querySelector( (*선택자*) ) 가 있다. 선택자에 해당하는 요소중 첫번째요소에해당하는 Element객체를 반환해준다. 없으면 null반환.
						ㄴ 선택자부분은 css의 선택자와 같은 방식으로 써야한다. 아닐경우 SYNTAX_ERR발생
						ㄴ Document.querySelectorAll( (*선택자*) )을 이용하여 선택자에해당하는 모든요소를 가져올수도있다. NodeList형으로 반환한다.
						ㄴ 좀 오래된메소드로는
							document.getElementsByTagName(태그이름) : 해당 태그 이름의 요소를 모두 선택함.
							document.getElementById(아이디) : 해당 아이디의 요소를 선택함.
							document.getElementsByClassName(클래스이름) : 해당 클래스에 속한 요소를 모두 선택함.
							document.getElementByName(name속성값) : 해당 name 속성값을 가지는 요소를 모두 선택함.
							또는 프로퍼티로 있는 객체집합을 통해 요소를 선택할수도 있다( document.images, document.links 등 각각 < img>요소와 href속성을
							가지는 < a>와 < area>요소를 모두반환함.)
					ㅡ 요소의 참조를 저장한 변수를 이용해 해당요소의 속성과 내용등을 조작할수있다
						ex)	var aaa=document.querySelector("a");
							aaa.textContent="~~~";	=>요소의 내용 변경.
							aaa.href="~~~"		=>속성 href값 변경.
					ㅡ 'Node 인터페이스'의 프로퍼티들로 요소에 접근하거나 요소의 정보를 알수있다.
						ㄴ parentNode : 부모노드를 반환.
						ㄴ childNoodes : 자식노드 리스트 반환.
						ㄴ firstChild : 첫번째자식노드
						ㄴ lastChild : 마지막자식노드
						ㄴ nextSibling : 다음 형제노드
						ㄴ previousSibling : 이전 형제노드
						ㄴ nodeName : 노드 고유이름 대문자로. 요소노드에선 태그이름, 속성노드에선 속성이름, 텍스트노드에선 #text
						ㄴ nodeValue : 노드의 값. 요소노드에선 undefined, 속성노드에선 속성값, 텍스트노드에선 해당텍스트문자열.
						ㄴ nodeType : 노드 고유의 타입을 숫자로 저장. ex) 요소노드는 1, 속성노드는 2 등등..

				ㅇ 노드만들기, 배치하기
					ㅡ 요소노드만들기
						document.createElement( (*요소이름*) ) : 이름에 해당하는 요소를 생성해 반환. Element객체 반환.
					ㅡ 속성노드만들기
						document.createAttribute( (*속성이름*) ) : 이름에 해당하는 속성을생성해반환. attribute 노드인 Attr객체반환.
							ex)	var atr= document.createAttribute(~~);	=>해당속성의 참조정보를 저장.
								atr.value="~~";							=>속성에대해 value프로퍼티에 값을저장함으로서 속성값부여. value는 Attr객체의 프로퍼티
								(*속성넣으려는요소*).setAttributeNode(atr);	=>만든속성을 원하는 요소에 setAttributeNode()메소드로 삽입.
					ㅡ 텍스트노드만들기
						document.createTextNode("~~") : 해당내용을가지는 텍스트노드생성반환.

					ㅡ 노드의 배치 및 추가하기
						ㄴ (*목표노드*).appendChild( (*추가할노드*) )
							 : 추가할노드를 목표노드의 자식노드리스트의 맨 마지막에 추가함. Node인터페이스의 메소드.
						ㄴ (*목표노드*).insertBefore( (*추가할노드*), (*기준노드*) )
							 : 추가할노드를 목표노드의 자식노드리스트에서 기준노드 바로앞에추가함. Node인터페이스의 메소드.
						ㄴ (*텍스트노드*).insertData( (*오프셋*), (*새로운내용*) )
							 : 텍스트노드에 내용을  추가하는메소드. 오프셋은 기존텍스트에서 몇번째위치에추가할지를나타내며 0부터시작한다.

				ㅇ 노드 이동, 삭제
					ㅡ appendChild를 이용하면 새로추가하는것뿐만아니라 이동도가능하다. 기존에 있는 요소를 이 메소드의 인자로넘겨주면 그요소의 위치를 이동시킬수있다.
						ex)	var aaa=document.querySelector("body");
							var bbb=document.querySelector("div");
							aaa.appendChild(bbb);					=>div요소의 위치가 body요소의 자식리스트중 가장 마지막부분으로 이동된다.
					ㅡ 노드삭제
						ㄴ (*목표노드*).removeChild( (*삭제할노드*) ) : 목표노드의 자식노드중에서 삭제할노드를 삭제.
						ㄴ (*목표노드*).removeAttribute( (*삭제할속성명*) ) : 목표노드의 속성중 속성명에해당하는 속성제거.

				ㅇ 노드 복제
					ㅡ (*복제할노드*).cloneNode( (*자식노드복제여부*) ) : 자식노드복제여부에따라 복제할노드를 복제하여 반환.

				ㅇ 스타일 조작
					ㅡ 'document.stylesheets프로퍼티'에는 'CSSStyleSheet 객체'의 배열이 담겨있어 이를이용하면 스타일시트를 조작할수있다. 하지만 어렵고 옛날방식이라함.
					ㅡ 더 편한방법으로 각 요소들이 가지고있는 'HTMLElement.style프로퍼티'를 이용하면 스타일속성을 인라인형태로 설정할수가있다고한다.
						ex)	(*요소*).style.color="red";	=>스타일속성의 color를 red로설정.
							(*요소*).style.padding="10px"; 등등.
					ㅡ 또는 요소에 속성을 설정하는  메소드를 통해 스타일시트를 설정해줄수있다(class나 id같은)
						ex)	(*요소*).setAttribute( '(*추가할속성이름*)', '(*속성값*)' )
							aaa.setAttribute('class', 'character');

				*NodeList 객체와 HTMLCollection 인터페이스
					ㅡ NodeList는 node의 콜렉션, HTMLCollection은 Element의 콜렉션이다.
					ㅡ 둘다 기능은 비슷.
					ㅡ node는 dom에서 최소구성요소단위. element는 node의 종류중 하나인 element에 해당하는 node. element node외에도 text node,
						attribute node등이있다. 그중 하나일뿐.
					ㅡ 요소 선택자들(DOM구조에서 document.getElementsByName나 .childNodes같은)을 통해 반환받을때 반환할 노드가 한개가 아닌경우 보통
						 이 두 타입중 하나를 반환하게된다.
						ㄴ브라우저마다 조금씩 차이가있는경우가있는것같다.
					ㅡ사용법은 두개가 비슷하여 큰의미는없을듯하다. 그래도하자면,
						ㄴ document.getEelementsByClassName() : HTMLCollection을 반환.
						ㄴ document.getEelementsByTagName() : HTMLCollection을 반환.
						ㄴ document.getEelementsByTagNameNS() : NodeList반환. (인터넷익스플로어에선 HTMLCollection반환)
						ㄴ Node 인터페이스의 프로퍼티 childNodes : NodeList반환.
						ㄴ document.querySelectorAll() : NodeList반환.


			</pre>
			js의 API<button>더보기</button>
			<pre>
				ㅡ 흔히 알고있는 그 API를 말한다.
				ㅇ js API 분류)
					자바스크립트에는 많은 api들이 있고, 이들은 보통 두종류로 나뉜다고한다.
					ㄴ Browser apis)
						ㄴ 브라우저에 있는 api들
						ㄴ 예로, Web Audio API가 있고, 볼륨조절, 오디오효과적용 등 브라우저에서 오디오를 컨트롤하는 js construct를 제공한다.
					ㄴ Third party APIs)
						ㄴ 기본적으로 브라우저에 깔려있는게 아닌 따로 설치를해야하는 api들
						ㄴ Twitter API같은 것들이 있다.

				ㅇ API 이외의 것들)
					 그외에 api는 아니지만 관련된것들
					ㄴ js libraries) 사용자가 추가할수있는 커스텀 함수를 포함하는 js파일들. 제이쿼리나 React등이 있다.
					ㄴ js frameworks) 앵귤러나 Ember등이 있으며, html,css,js와 기타 다른 기술들이 패키지화되는 경향이 있다. 설치하여 전체 웹 어플리케이션을
						작성할수있게한다. 라이브러리와의 차이점은 '제어의 역전'이라한다. 라이브러리를 사용할때는 개발자가 제어권을가지고 메소드를 호출하지만,
						프레임워크에선 프레임워크가 제어권을 가지고 개발자의 코드를 호출한다고한다(아직무슨말인지모르겟다)

				ㅇ 주요 API들
					ㅡ browser APIs)
						무수히 많은 browser api들이 있지만 주로 많이 쓰이는 api들은 다음과같다.
						ㄴ document 조작 api) 알고있는 DOM 조작 api들이 이에 해당한다. document.~~하는거
						ㄴ 서버로부터 데이터 fetch api) 페이지 일부를 업데이트하거나 할때 사용되는 api. XMLHttpRequest와 FetchAPI등을 포함하며, 흔히 Ajax을 말함.
						ㄴ 그래픽을 그리고 조작하는 api) Canvas, WebGL등이 있고, 도형그리거나 이미지 삽입하거나 필터적용하거나 할때 쓰이는것들.
						ㄴ 오디오, 비디오 api)
						ㄴ Device api) 하드웨어 장치로부터 데이터를 받는데 쓰이는 api
						ㄴ Client-side storage api) 클라이언트쪽에 데이터를 저장하는 기술.

					ㅡ third-party APIs)
						역시 무수히 많은 third-party api들이 있지만 유명한것들은 다음과같다.
						ㄴ Twitter api
						ㄴ Map api) Mapquest나 Google Maps API처럼 지도와관련된것들을 할수있게해주는 api
						ㄴ FaceBook suite of APIs)
						ㄴ Telegram APIs, YouTube API, Pinterest API 등등..


				ㅇ api들은 어떻게 작동하는가?
					ㅡ api들은 객체로 되어있다.
						ㄴ api들은 하나 또는 그이상의 js object들을 사용하며, 이 객체들은 api가 사용하는 데이터를 담는역할(객체의 프로퍼티로서)과 api가 수행할
							기능을 담는역할(객체의 메소드로서)을 한다.
					ㅡ Web Audio API를 이용한 사례)
						ㄴ api의 대표적인 객체)
							AudioContext : 브라우저에서 오디오를 조작할때사용하는 audio graph를 나타내는 객체. 오디오조작을 위해쓰이는 많은 메소드와 프로퍼티를가지고있다.
							MediaElementAudioSourceNode : 사용자가 재생하고 조작하기를원하는 오디오를 가지고있는 < audio>태그를 나타내는 객체
							AudioDestinationNode : 오디오의 목적지를 나타내는 객체. 목적지란 오디오가 실제로 출력될 device같은걸 말함.스피커 헤드셋같은.
					ㅡ API들을 사용할때 entry point를 지정해야한다. Web Audio API같은 경우, AudioContext객체를 생성할때가 entry point가 된다.
						DOM API의 경우 Document객체를 생성할때이고.
					ㅡ API들은 대부분 이벤트를 활용한다.
					ㅡ API들은 각자의 추가적인 보안메커니즘을 가진다.

				ㅇ API들 상세 <button>더보기</button>
				<pre>
					ㅡ FormDate <button>더보기</button>
					<pre>
						ㅡ form태그의 데이터들을 쉽게 전송할 수 잇게 해주는 api
						ㅡ 간단 사용법 )
							ㄴ ex)
								const formData = new FormData();//FormData 객체 생성후,

								formData.append("id",this.state.companyId);	//append( (*파라미터명*), (*값*) )을 통해
										인자를 넣어주면된다.
								formData.append('memberId', this.state.memberId);

								fetch(this.context+"/v2/api/manage/company",{
									method:'PUT',
									body: formData 		//request body에 formData를 통째로 넣어주면 request의 header가 자동으로
															설정된다.
								})
									.then(res => res.json())
									.then(
										(result) => {
											/*this.setState({
												result:result
											})*/
										}
									)
						ㅡ append( (*파라미터명*), (*값*) )
							ㄴ request에 파라미터 추가하는 메소드
							ㄴ (*값*)부분에 파일을 넣을 수 있다.
							ㄴ (*값*)부분에 파일이 아닌경우 String형태로 저장된다.
								ㄴ js의 null이나 undefined를 저장해도 "null"과 같은식으로 문자열형태로 저장된다.
						ㅡ ~~~~~
						ㅡ 실무 )
							ㄴ multipart/form-data을 js에서 ajax으로 전송시 사용하는듯하다.

					</pre>
					ㅡ DOM <button>더보기</button>
					<pre>
						ㄴ
					</pre>

				</pre>
			</pre>
			AJAX<button>더보기</button>
			<pre>
				ㅇ ajax 기술의 배경과 장점
					ㅡ 고전적방식인 요청을 보내고 그에대한 응답을 받아서 컴퓨터에 출력하는 방식은 사용자가 페이지으 일부를 업데이트하고자할때 전체페이지를 다시
						받아야하기때문에 낭비가심하고 낮은 사용자 경험을 제공한다고한다.
					ㅡ 이런 문제를 해결해주는 api가 XMLHttpRequest와 Fetch API이다. 이것들은 웹페이지가 작은조각의 데이터(html,xml,json등같은)를
						요청하여 원하는 일부에서만 업데이트할수있게해준다.
					ㅡ 장점)
						ㄴ 웹페이지가 서버에서 이용가능한 특정자원을 위해서 직접 HTTP request를 만들수있게해주고 그 데이터를 출력전에 가공할수있게해준다.
						ㄴ 일부만 업데이트를 하기때문에 훨씬빠르다.
						ㄴ 더 적은 데이터를 주고받으므로 bandwidth의 낭비가 적다.(데스크탑에선 별로 해당되지않는문제이지만 모바일이나 개도국에선 중요한 이슈라고한다)
					ㅡ 더 빠른 속도를 위해, 몇몇사이트들은 처음 요청이 들어왔을때, 데이터를 사용자에 컴퓨터에 저장해놓느낟고한다. 이후 방문 하게되면 데이터를 서버로부터
						다운받는게 아니라 저장된 로컬버젼을 사용하고, 업데이트가 필요할때만 리로드하는 방식.

				ㅇ Promise 객체
					ㅡ 개요) 비동기적 작업의 결과(성공인지 실패인지)를 나타내주는 객체.
					ㅡ 배경) 이전의 비동기 작업 코딩방식이 '콜백 헬'이라부르는 문제가 심각하여 해결책으로서 나온 방법이라함.
					ㅡ 메소드와 프로퍼티들을 사용하여 이 비동기적 작업들을 훨씬더 깔끔하고 편하게 프로그래밍할수있다.
					ㅡ Promise chainning : 여러 비동기 작업이 순차적으로 이전의 작업결과를 이용해 수행되어야할때 Promise chain을 이용해 이를 구현할수있다.
						ㄴ ex)	const promise = doSomething().then(successCallback, failureCallback);
							=> doSomething()을 실행하고 반환된 Promise에 대해 then()을 호출하는식으로 이전의 작업결과를 이용한 순차적 비동기작업을 수행하도록 할수있다.
						ㄴ 체인안에서 각각의 Promise는 어떤 비동기 작업의 완료를 의미한다. (비동기작업이 완료되면 인자로넘어간 콜백함수가 실행되고 또다른 Promise가 반환되는거니까)
						ㄴ 예전에 Promise가없었을때는 이런 비동기작업을 처리하는부분에서 '콜백 헬'이 생겨 어려움이있었는데, 이제는 promise chain을 이용해
							이렇게 then()을 추가하기만 하면된다.

					ㅡ 생성자) new Promise(executor)
						ㄴ 함수를 인자로 하나 받는다(executor라고 부르겟다)
						ㄴ 이 executor함수는 인자로 resolve와 reject(함수명은 자유)함수를 가진다.
						ㄴ executor는 생성자가 종료되기도 전에 바로 실행된다.
						ㄴ executor가 완료되면서 resolve가 호출되어 promise가 resolved되거나, 에러가 발생하면 reject가 호출되며 promise가 rejected된다.
						ㄴ executor의 리턴값은 무시된다.

					ㅡ 프로퍼티)

					ㅡ 메소드)
						ㄴ then( (*응답성공했을시 실행되는함수*), (*응답실패했을시 실행되는함수*) )
							ㄴ 비동기작업의 결과를 나타낸다는 Promise에 성공과 실패에 따른 핸들러를 붙이는기능.
							ㄴ 두번째 인자는 생략가능하다.
							ㄴ 성공적으로 수행되었을때 첫번째 인자의 함수가 실행되며, 실패했을때는 두번째인자의 함수 실행.
							ㄴ 첫번째인자는 자동적으로 응답받은 response(Response인터페이스)를 인자로 받는다고한다. 매개변수이름은 자유.
							ㄴ 반환값)
								 기본적으로 Promise객체를 반환하지만, 인자로 넘어간 함수의 반환값에따른 규칙이있다한다.
								ㄴ value를 반환하면, 반환되는 Promise는 그 value로 resolved된다한다.
								ㄴ 아무것도 반환하지않으면, Promise는 undefined로 resolved된다한다.
								ㄴ 에러를 반환하면, Promise는 그 에러를 던지며 rejected된다
								ㄴ 이미 fulfilled된 promise를 반환하면, 반환되는 Promise는 이 promise의 값으로 fulfill된다.
								ㄴ 이미 rejected된 promise를 반환하면, 반환되는 Promise는 이 promise의 값으로 rejected된다.
								ㄴ 다른 pending중인 promise를 반환하면, 반환되는 Promise의 resolution과 rejection은 pending중인 promise의
									resolution과 rejection뒤에 대기한다.
						ㄴ catch( (*함수*) )
							ㄴ promise에 reject 핸들러 콜백함수를 붙이는 기능. then(null, (*응답실패했을시 실행되는함수*) )와 같다고 보면된다.

				ㅇ XMLHttpRequest 객체
					ㅡ 서버와 상호작용하는 객체이다.
					ㅡ 프로퍼티)
						ㄴ readyState : XMLHttpRequest객체의 상태(생성되었거나, open()되었거나 등)을 나타내는 값을 가지는 프로퍼티. 다음의 5가지값을가짐.
							ㄴ 0 (UNSENT) : 생성됨. 아직 open()되지는 않음.
							ㄴ 1 (OPENED) : open()이 호출됨.
							ㄴ 2 (HEADERS_RECIEVED) : send()가 호출되고, header가 이용가능.
							ㄴ 3 (LOADING) : 다운로딩
							ㄴ 4 (DONE) : 작업이 완료됨.
						ㄴ onreadystatechange : 콜벡함수를 저장하는 프로퍼티. 이벤트 핸들러역할이다. 'readyState'프로퍼티의 값이 바뀔때마다 호출된다.
												(여기서 등록한 콜백함수에서 readyState의 값을 if문으로 체크하면서 각각의 경우 실행할 내용을 정의하는식으로사용)
						ㄴ responseType : enumberated된 값으로, response의 type을 결정한다.
						ㄴ response : 위 responseType 프로퍼티에 따라  ArrayBuffer, Blob, Document, JavaScript object, DOMString
										중 하나를 반환한다. response의 body내용을 담고있다.
					ㅡ 메소드)
						ㄴ open( (*어떤 HTTP request 메소드인지*), (*요청할 url*) ) : 보낼 요청을 초기화하는 역할을한다.
						ㄴ send() : 초기화한 url로 요청을 보낸다.

				ㅇ Fetch API
					ㅡ 기본적으로 XMLHttpRequest와 같은기능을 하지만 더 사용하기좋게 최근에 나온 API.
					ㅡ 제공하는 인터페이스들)
						1. WindowOrWorkerGlobalScope.fetch( (*url*) )
							ㅡ Fetch API에서 제공하는 메소드로, 이 메소드가 entry point이다.
							ㅡ XMLHttpRequest의 open()과 send() 기능을 한다.
							ㅡ Promise객체를 반환한다.

						2. Header
						3. Request
						4. Response 인터페이스
							ㅡ request에 대한 response를 나타내는 인터페이스로.
							ㅡ 응답의 내용과 이를 처리할수있는 프로퍼티와 메소드들을 가지고있다.
							ㅡ 직접 Response()생성자를 이용해 만들ㅇㅓ도되지만 보통 fetch()같은 메소드의 반환값으로 받아서 많이쓰게된다.
							ㅡ Body mixin을 구현하므로 이안에있는 프로퍼티와 메소드를사용할수있다.
							ㅡ 프로퍼티)
							ㅡ 메소드)
								ㄴ (Body mixin의) text() : 응답 스트림을 가져다 끝까지 읽고, 그것을 USVString으로 resolve된 Promise를 반환한다.
												XMLHttpRequest의 프로토타입 responseType을 'text'로 설정하는 기능과 같다한다.
								ㄴ (Body mixin의) json() : 응답 스트림을 가져다 끝까지 읽고, 응답의 body를 json형태로 파싱한 결과로 resolve된
												Promise를 반환한다.

					* mixin
						ㅡ 클래스 또는 인터페이스. 둘중 어느것이라고 하기어려운것.
						ㅡ 가지고있는 프로퍼티나 메소드의 일부,또는 전부가 구현되지않은상태이다.
						ㅡ 때문에, 이 구현을 다른 클래스나 인터페이스가 해야함.
						ㅡ 여러 인터페이스가 쓰이는 APIs만들때 설계상의 이점이 있다고한다.

					ㅡ 들어있는 mixin)
						Body mixin
						ㅡ request, response의 body를 나타내는 mixin.
						ㅡ request, response의 contentType을 설정하거나 이것이 어떻게 다루어져야하는지를 설정하게해주는 mixin.

				ㅇ AJAX 사용하기
					1. XMLHttpRequest를 이용)
						ㅡ XMLHttpRequest를 이용한 기술은 꽤 오래된 기술이다.
						ㅡ 예제를 만들어보며 설명.
						<a href="code/ajax_XMLHttpRequest이용.txt" target="_blank">XMLHttpRequest 예제</a>
						ㅡ 네트워크로부터 데이터를 받는것은 '동기적'작업이다.
						ㅡ XMLHttpRequest를 사용할때, onload 이벤트핸들러를 사용할수있다. onload 이벤트핸들러는 load 이벤트가 발생하였을때 실행되며,
							즉 응답을 반환받았을때를 말한다.
						ㅡ XMLHttpRequest객체의 response프로퍼티를 이용해 응답받아온 데이터를 이용할수있다.

					2. Fetch를 이용)
						ㅡ fetch()를 호출하여 url로 요청을 보낸다.
						ㅡ ex) 위 XMLHttpRequest 예제에서 updateDisplay(verse)함수 부분만 다르다.
							 function updateDisplay(verse) {
						    	//< select>에 의해 선택된 내용을 불러오려는 텍스트파일이름과 같이 변경해주는부분.('Verse 1'을 'verse1.txt'이런식으로)
						    	verse = verse.replace(" ", "");
						    	verse = verse.toLowerCase();
						    	var url = verse + '.txt';

						    	//Fetch API를 이용해 처리.
						    	fetch(url).then(function(response) {	=>fetch()로부터 반환받은 Promise에대해 then()을호출.
					    		  response.text().then(function(text) {	=>응답에 대해 text()를 호출하고 반환받은 Promise에대해 다시 then()호출.
					    		    poemDisplay.textContent = text;		=>반환받은 내용을 페이지의 내용에 삽입해줌.
					    		  });
					    		});
						    };

						ㅡ 반환받은 promise객체에 대해 then()을 호출하며 응답성공시 실행할 함수를 정의하여 인자로 넘긴다.
							ㄴ XMLHttpRequest예제에서 onload를 통해 응답에대해 이벤트핸들링을 설정하는것과 같은기능.
						ㅡ 방금 정의한 함수가 자동으로 받은 Response인터페이스에 대해 tex()를 호출하여 contentType을 설정한다.
						ㅡ text()에서 반환받은 Promise객체에 대해 다시 then()을 호출하여 인자로 넘기는 함수에서 응답내용을
							출력함.
						ㅡ tip)
							ㄴ ex)	fetch(url).then(function(response) {
								 	 return response.text()
									}).then(function(text) {
									  poemDisplay.textContent = text;
									});
							ㄴ 위와 같은 형태로 많이 작성한다고한다.(이 예제 이전에 나온예제보다) 더 보기좋기때문.
							ㄴ text()에서 promise를 반환하므로 이전예제에서는 text()바로뒤에 promise에 대해 then()을 붙여서 구문을 중첩시켯지만,
								이 예제는 then()이 인자로 전달한 함수의 반환값과 같은 promise를 반환한다는것을 이용해, then()뒤에 반환한 promise에
								대해 또 then()을 호출하는식으로 코딩을함.

					ㅡ 둘중 어떤방식을 이용해야하나)
						ㄴ XMLHttpRequest방식은 오래된방식이기때문에 많은곳에서 지원이 되는기술이긴하다.
						ㄴ Fetch방식은 최신의 방식으로 앞으로 계속 쓰임이 늘어날것이다.

				ㅇ 기타
					ㅡ 한계?) AJAX기술은 요청을 하고 응답을 받아올수는 있지만, 서버단에서 하는것처럼 복잡한작업은 이걸이용해서 할수없는듯하다.
						결국 돌아가는건 브라우저상에서 자바스크립트 안에서 돌아가는것이기때문에. 단순한 데이터 받아서 그거 사용하는정도.

			</pre>
			기타<button>더보기</button>
			<pre>
				ㅇ 전역객체
					ㅡ js에서 미리정의된 객체로, 전역 프로퍼티나 전역함수를 담는공간의 역할을 한다.
					ㅡ 전역범위에서 this연산자를통해 접근가능하다.
					ㅡ 전역객체는 코드상에서 생략이 가능하다.
						ex)	document.~~~	=	window.docucment.~~~

				ㅇ 래퍼객체
					ㄴ js에서 원시타입은 객체가 아니므로 프로퍼티를 가질수없다. 그런데도 원시타입의 값에 대해 프로퍼티에 접근하려하면 자동적으로 그 원시타입에 해당하는
						객체가(Number, String, Boolean, Symbol) 원시타입의값을 감싸 객체가 되어 프로퍼티를 사용할수있게해준다.
					ㄴ 사용이 끝나면 이 생성된 객체는 사라지고 값은 다시 원시타입이 되며, 이때 이렇게 잠깐 생겼다사라지는 임시객체를 '래퍼객체'라고한다.
						ex)	var str="문자열;	=>string형 원시타입값이다.
							var len = str.length;	=>원시타입인str은 length란 프로퍼티를 가질수도없고 사용할수도없지만, 이때 자동으로
														new String(str)을 호출한것같은 동작이 일어나 str이 String객체가 된다. 이때 이 객체가 래퍼객체.
				ㅇ 표준객체
					ㅡ 기본적으로 있는 js에서 자주쓰이는 객체를 말한다.
					ㅡ 각 객체에 있는 프로퍼티와 메소드들은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference">참조</a>에
						자세하게 나와있다. 이것들은자세하게안썼으니 이걸보면서 참고하자.
					1. Number 객체
						ㅡ 숫자를 이 객체로 표현할수도있다.
						ㅡ 리터럴 숫자와 Number객체는 당연히 다른것. 이걸로 표현할수도 있는것뿐.
						ㅡ 메소드)
							ㄴ Number.parseFloat() : 인자로넘ㅇ어오는 문자열을 파싱하여, 문자열에 포함된 숫자부분을 실수형태로 반환. 숫자가 여러개면 첫번째숫자만반환.
							ㄴ Number.parseInt() : 위와동일. 정수로 반환하는것만다름.
							ㄴ Number.isNaN() : 인자로받은 '숫자'가 NaN인지 확인. 맞으면 true반환.
							ㄴ Number.isFinite() : 인자로받은 '셀수있는값'이 유한한수인지확인. 유한하면 true반환.
							ㄴ Number.isInteger() : 인자로받은값이 정수이면true.
							ㄴ Number.isSafeInteger()
					2. Math객체
						ㅡ 수학상수 및 함수에대한 프로퍼티,메소드를 가지고있다.
					3. Date객체
						ㅡ 날짜와 시간과 관련된 프로퍼티와 메소드제공.
					4. String객체
						ㅡ 문자열과 관련된 프로퍼티,메소드를 가지고있다
						ㅡ 문자열위치찾기, 해당인덱스에있는문자반환, 문자열추출, 분리,결합, 대소문자변경, 공백제거, 등의기능이있다.
					5. Array 객체
						ㅡ  배열과 관련된 프로퍼티, 메소드를 제공.

				ㅇ BOM(Browser Object Model)
					ㅡ 모르겟다. 그냥 브라우저창 관련 기능을 제공해주는 객체정도로만 알고있자.
					ㅡ window객체가 있다.
						ㄴ js에서는 모든객체, 전역함수, 전역변수가 window객체의 프로퍼티가된다한다
						ㄴ js에서는 전역범위에 해당하는 window를 생략할수있다.
						ㄴ 함수 )
							ㄴ prompt() : 윈도우 창에서 데이터를 입력받고 이값을 반환해주는 함수. 인자로 값을 넘기면 입력창에 그 인자 값이 출력된다.
								ㄴ ex) var answer = prompt(word); 	=>word의 값을 출력하며 값을 입력받는 창을 띄워준다.
																		값을 입력하면 그값을 반환해 answer에 넣는다.
					ㅡ 프로퍼티)
						ㄴ document : 위에있는 Document객체.
						ㄴ innerWidth, innerHeight : 창 크기를나타내는 프로퍼티.
					ㅡ  메소드)
						ㄴ open(), close() : 브라우저창 열고닫는 메소드.
					ㅡ location객체
						ㄴ 현재 브라우저에 표시된 html문서의 주소를 얻거나 브라우저에 새문서를 불러올때사용
						ㄴ window으 ㅣ프로퍼티로 존재.
						ㄴ loaction.href : 현재문서의 전체url 문자열로반환.
						ㄴ location.hostnaem : 현재문서의 인터넷호스트이름반환.
						ㄴ location.pathname : 현재문서의 파일경로명 반환.
						ㄴ location.assign( (*url*) ) : url에 해당하는문서를 불러옴.
					ㅡ history객체 : 브라우저의 히스토리정보를 저장.
					ㅡ screen객체 : 사용자의 디스플레이 화면에대한 객체.
					ㅡ navigator객체 : 브라우저 공급자 및 버전정보 등을 포함한 브라우저에대한 다양한정보를 저장하는 객체.

				ㅇ JSON
					ㅡ 객체를 텍스트 형식으로 주고받아 데이터 교환을 경량화 해주는 기술.
						ㄴ js객체를 텍스트형식으로 변환하고 텍스트를 js객체형식으로 변환하여 서버와 주고받을때 많이 쓰임.
					ㅡ 문법)
						ㄴ js의 객체와 거의비슷하지만 조금다른부분이있다.
						ㄴ json 데이터는 이름,값의 쌍으로 구성되어야하며
							ex) " (*이름*) ":" (*값*) "
							와 같은 형태이다. 이름은 따옴표("")로 묶여있는 문자열이어야한다.
							'값'부분에는 String, number, (json형)객체, 배열, boolean, null만 올수있다.
					ㅡ JSON.parse( (*문자열*) )
						ㄴ json형식으로 되어있는 문자열을 받아 js객체로 변환해준다.
					ㅡ JSON.stringify( (*객체*) )
						ㄴ 객체를 받아서 이를 json형태의 문자열로 변환한다.
				ㅇ Date 객체<button>더보기</button>
				<pre>
					ㅡ js에서 날짜와 시간 등을 나타내는 객체.
					ㅡ 기본적으로 형태가 'Thu May 09 2019 10:23:18 GMT+0900 (한국 표준시)' 이런식인듯하다.
					ㅡ 메소드 )
						ㄴ Date.now() : 그 기준시간대로부터 밀리세컨드를 숫자로 바환
						ㄴ Date.parse() : 날짜의 string표현을 가지고 그 날짜에 맞는
						ㄴ new Date() : 여러 인자를 통해 Date객체 생성.
						ㄴ getTime() : '그 기준'시간대로부터 지난시간을 밀리세컨드단위로 반환.
						ㄴ Date.prototype의 메소드들 )
							ㄴ https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/prototype 참조
							ㄴ getDate(), getFullYear()등 현재 Date객체의 시간, 날짜, 요일 등을 여러 형태로 가져올수있는 getter메소드와
								설정할수있는 setter메소드들, 기타 여러 메소드들이 있다.
					ㅡ Date.UTC )
						ㄴ ?????
					ㅡ 실무 )
						ㄴ Date객체 변환하기 )
							ㄴ Date객체를 원하는 형태로 변경해주는 방법.
							ㄴ 가장 간단하게 Date.prototype의 getMonth()등의 메소드를 이용하여 각 일, 월 등을 가져와 수작업으로 바꿔주는 방법.

				</pre>
			</pre>
			실무<button>더보기</button>
			<pre>
				ㅇ < input type="file">에서 파일 업로드 클릭하고 바로 이미지 보기<button>더보기</button>
				<pre>
					ㅡ 코드 )
						function readURL(input) {	//1. input태그의 이벤트 핸들러. input은 이벤트객체의 target을 받도록.
							if (input.files && input.files[0]) {
								var reader = new FileReader();
								reader.onload = function (e) {//3. 2번에서 reader에 파일을 저렇게 넣으면 base64형태로 데이터가 가져와지고
									$('#blah').attr('src', e.target.result);//4. #blah는 < img>를 말하고, img태그의 src에 이 base64를
																				넣으면 바로 이미지를 볼 수 있다.
								}
								reader.readAsDataURL(input.files[0]);//2. targer으로부터 업로드한 파일을 가져와 reader에 처리.
							}
						}

				</pre>


			</pre>
			라이브러리<button>more</button>
			<pre>
				ㅡ 차트 라이브러리<button>more</button>
				<pre>
					ㄴ 비교<button>more</button>
					<pre>
						ㄴ 목록 )
							ㄴ ~~~~~
							ㄴ AmCharts )
								ㄴ https://www.amcharts.com/
								ㄴ 조건부 무료. (차트에 개발사 링크가 출력되는 조건)
							ㄴ HighCharts )
								ㄴ  https://www.highcharts.com/
								ㄴ 상업용이 아닐 경우 무료.
							ㄴ D3 )
								ㄴ https://d3js.org
								ㄴ 그냥가져다 쓰는 라이브러리가 아니고 시각화 프레임워크 같은 것. 만들어서 써야 한다.
								ㄴ 무료.
							ㄴ Chart.js )
								ㄴ http://www.chartjs.org
								ㄴ 무료.
							ㄴ google chart )
								ㄴ https://developers.google.com/chart
							ㄴ Morris.js )
								ㄴ http://morrisjs.github.io/morris.js
								ㄴ 무료
							ㄴ Chartist.js
								ㄴ http://gionkunz.github.io/chartis-js
								ㄴ 무료.
							ㄴ C3 )
								ㄴ https://c3js.org
								ㄴ 오픈소스 / 무료
								ㄴ D3 위에 만든 라이브러리.
								ㄴ 속도 빠르고, 브라우저 호환이 좋다함.
							ㄴ Plotly.js )
								ㄴ 무료.
								ㄴ 종류가 많음.

							ㄴ 대략, 많이 사용되는 것들로
								chart.js, highcharts, c3, nvd3, chartist, victory, plotly.js 등이 있다.

					</pre>
					ㄴ flotchart<button>more</button>
					<pre>
						ㄴ http://www.flotcharts.org/
							ㄴ 기본 사용법 ) https://github.com/flot/flot/blob/master/API.md#multiple-axes

					</pre>
					ㄴ plotly.js<button>more</button>
					<pre>

					</pre>
					ㄴ amChart<button>more</button>
					<pre>
						ㄴ 개요 )
							ㄴ 조건부 무료 차트 라이브러리. (렌더링되는 그래프에 amchart의 로고와 링크가 표시)
							ㄴ 판매하는 라이브러리인 만큼 질이 좋고 다양하다.
							ㄴ 2021년9월에 5버전 출시.
						ㄴ 설치 및 세팅 )
							ㄴ ~~~~~
						ㄴ 기본 사용법 )
							ㄴ ~~~~~
						ㄴ Root Element<button>more</button>
						<pre>
							ㄴ var root = am5.Root.new("chartdiv"); 로 생성.
								ㄴ new()의 인자는 그래프를 삽입할 div의 id.
							ㄴ Root Element를 제외한 다른 인스턴스 생성시, new()의 첫번째 인자로 항상 이 Root Element가 들어간다.
							ㄴ	var chart = root.container.children.push(
									am5pie.PieChart.new(root, {})
								);
								ㄴ 해당 div에 Pie chart가 삽입된다.
							ㄴ 설정 )
								ㄴ Formatter )
									ㄴ 내부적으로 다음 3개의 포메터가 있다함.
										ㄴ NumberFormatter
										ㄴ DateFormatter
										ㄴ DurationFormatter
									ㄴ 이들은 '글로벌 포메터'라고함.
								ㄴ fps )
									ㄴ root.fps 속성을 통해 애니메이션의 fps를 설정할 수 있다함.
								ㄴ time zone )
									ㄴ root.timezone = am5.Timezone.new("America/Vancouver");
									ㄴ timezone 속성으로 timezone설정 가능. "UTC", "Asia/Tokyo", "America/New_York", "Europe/Lisbon" 등
								ㄴ new()의 setting인자 )
									ㄴ new()의 두번째 인자로 객체를 넘길 수 있고, 이는 root element에 대한 설정으로 사용된다.
									ㄴ ex)
										var root = am5.Root.new("chartdiv", {
										  useSafeResolution: false
										});
									ㄴ 현재 이걸로 넘기는 옵션이 'useSafeResolution'밖에 없다하.ㅁ
									ㄴ 옵션 )
										ㄴ useSafeResolution : boolean )
											ㄴ 자동으로 해당 장치에 맞는 그래프 해상도를 설정할지 말지를 설정.
								ㄴ Locale )
								ㄴ Top-level tab index
							ㄴ root.container.children.clear()
								ㄴ root의 컨테이너 안의 요소들을 모두 지운다.
								ㄴ root가 제거되지는 않음. (root에 다시 요소들을 push할 수 있음)
							ㄴ root.dispose()
								ㄴ root를 제거. (다시 요소 push 등 안됨)
							ㄴ root 컨테이너 크기 자동 조절 )
								ㄴ root element의 컨테이너 div의 크기가 변경되면 root element가 자동으로 조절된다.
								ㄴ root.autoResize = false 로 off가능.
								ㄴ root.resize() 로 수동 리사이즈 가능.
							ㄴ 차트 준비 이벤트 ????? )
								ㄴ ?????

						</pre>
						ㄴ XY chart <button>more</button>
						<pre>
							ㄴ index, xy 모듈 필요
							ㄴ ex )
								var chart = root.container.children.push(
									am5xy.XYChart.new(root, {})
								);
							ㄴ axes )
								ㄴ ex )
									var yAxis = chart.yAxes.push(
									  am5xy.ValueAxis.new(root, {  // 필요한 타입에 맞는 Axis를 생성.
										renderer: am5xy.AxisRendererY.new(root, {})
									  })
									);
								ㄴ XYChart 인스턴스의 yAxes, xAxes 속성에 Axis 인스턴스를 push함으로써 axis를 추가할 수 있다.
								ㄴ 위의 경우, ValueAxis가 y축 axis에 추가된다.
								ㄴ axis renderer )
									ㄴ axis는 renderer를 통해 실제로 화면에 그려지게 된다.
									ㄴ AxisRendererX, AxisRendererY가 있다.
								ㄴ axis type )
									ㄴ 종류 )
										ㄴ CategoryAxis : 축의 값이 문자열일 경우.
										ㄴ CategoryDateAxis : ?????
										ㄴ DateAxis : ?????
										ㄴ ValueAxis : 축의 값이 숫자인 경우.
									ㄴ 타입에 따라 생성시 필요한 설정값들이 존재.
								ㄴ 설정들 )
									ㄴ Grid )
									ㄴ Ticks )
									ㄴ Labels )
										ㄴ renderer의 labels속성의 template 속성을 설정하여 설정.
											ㄴ ex )
												let yRenderer = yAxis.get("renderer");
												yRenderer.labels.template.setAll({
												  fill: am5.color(0xFF0000),
												  fontSize: "1.5em"
												});
							ㄴ series )
								ㄴ 이 객체에 데이터가 저장된다.
								ㄴ xy chart에서는 최소한 한개의 series를 추가해 줘야함.
								ㄴ ex )
									var series = chart.series.push(
									  am5xy.ColumnSeries.new(root, {
										name: "Series",
										xAxis: xAxis,  // 사용할 xaxis객체를 설정.
										yAxis: yAxis,  // 마찬가지.
										valueYField: "value",  // 아래 valueXFiedl와 함께 데이터와 관련된 부분.
										valueXField: "date"  // 이 두 설정값은 사용할 각 축 axis의 type과 맞아야 한다.
									  })
									);
									ㄴ data field )
										ㄴ valueYField, valueXField 부분이 series의 데이터 관련 설정이다.
										ㄴ 이 두 설정값은 사용할 각 축 axis의 type과 맞아야 한다.
											ㄴ 가령, xaxis가 valueAxis를 사용중이면 데이터 필드로 'valueXField'가 와야한다.
										ㄴ 속성의 이름으로 필드의 유형을 구분.
											ㄴ valueXField => value 타입, x축에 대한 데이터 필드.
											ㄴ categoryYField => category 타입, y축에 대한 데이터 필드.
										ㄴ DateAxis인 경우, 축에 들어갈 데이터가 timestamp(정수값)이므로 value타입 데이터 필드를 사용한다.
								ㄴ series 객체 종류 )
									ㄴ CandlestickSeries : 캔들스틱 데이터를 표현하려 할때 사용.
									ㄴ ColumnSeries : 컬럼이나 막대를 표현
									ㄴ LineSeries : 선 표현.
									ㄴ SmoothedXLineSeries : ?????
									ㄴ SmoothedXYLineSeries : ?????
									ㄴ SmoothedYLineSeries : ?????
									ㄴ StepLineSeries : ?????
								ㄴ 데이터 저장 )
									ㄴ series의 data속성의 setAll()를 사용
									ㄴ ex )
										series.data.setAll([{
										  category: "Research",
										  value: 1000
										}, {
										  category: "Marketing",
										  value: 1200
										}, {
										  category: "Sales",
										  value: 850
										}]);
								ㄴ 날짜 기반 데이터 )
									ㄴ DateAxis에 js의 timestamp를 나타내는 정수값을 넘겨주어야함.
							ㄴ Legend
							ㄴ Cursor

						</pre>

                        ㄴ Element states<button>more</button>
                        <pre>
                            ㄴ 'State'라는 객체. amChart의 다른 요소들과 마찬가지로.
                            ㄴ 다른 요소들과 마찬가지로 키/값 쌍의 setting값들을 가진다.
                            ㄴ 세팅값을 가지기만 할 뿐, 아무런 기능도 하지 않다가 특정 조건하에서 특정 요소에 적용되어 본인이 가지고 있던
                                세팅값들을 해당 요소에 적용시킨다?
                            ㄴ 특정 조건은
                                built-in state들일 수도, 사용자 정의가 될 수도 있다.
                                ㄴ built-in state
                                    ㄴ hover
                        </pre>

                        ㄴ Template<button>more</button>
                        <pre>
                            ㄴ
                        </pre>

                        ㄴ 라이센스 구매
                            ㄴ 차트별로 라이센스 별도 존재.
                                ㄴ 기본 차트, Map차트, stock 차트
                                ㄴ 가격 상이.
                            ㄴ 적용 서비스별 라이센스 등급 존재.
                                ㄴ 싱글 웹사이트, SaaS( or app?), OEM, extended OEM


					</pre>
				</pre>
				ㅡ 테이블 라이브러리<button>more</button>
				<pre>
					ㄴ CloudTables<button>more</button>
					<pre>
						ㄴ https://datatables.net/manual/index
					</pre>
				</pre>
			</pre>
		</pre>
        ㄴ 타입 스크립트 (TypeScript)
            ㄴ js위에 문법을 추가하여 만든 언어?
            ㄴ js에 정적 타입 등 여러 문법 기능을 사용할 수 있음.
            ㄴ js컴파일하여 동작하는 컴파일언어.

		jQuery<button>더보기</button>
		<pre>
			ㅇ jquery란
	    		ㅡ 자바스크립트의 라이브러리. 퓨어 자바스크립트는 코드가길고 쓰기어렵기때문에 한줄로 기능을 구현하게해주는 제이쿼리를 만듦.
	    		ㅡ 참고 : https://api.jquery.com/Types/
	    			ㄴ 제이쿼리 공식사이트
	    		ㅡ 쓰기쉽게 함수로 만들어 놓은 것이기때문에 더 디테일한 기능이나 커스터마이징이 필요한 경우 퓨어 자바스크립트가 더 편할 수도 있다.
	    			ㄴ 그러나 왠만한 기능이 다 있고 쓰기 편함.
	    		ㅡ 공식사이트에서 왼쪽카테고리에 분류가 되어있고 이곳에서 원하는 기능을 뒤져서 사용하면 된다.

	    	ㅇ 문법
	    		ㅡ 사용하기 위해서 먼저 선언해야한다.
	    			ㄴ html등의 파일에서 jquery를 사용하기 이전에 다음의 내용을 추가해준다.
	    				ㄴ < script src="http://code.jquery.com/jquery-latest.js">< /script>
	    			ㄴ 위 방법이 아니더라도 다른 방법이 몇가지 더 있다.
	    		ㅡ $( (*선택자*) ). (*액션*)() 의 형태이며,
	    			ㄴ 선택자는 html요소를 쿼리(또는 찾기)하는 부분.
	    			ㄴ 액션은 해당 요소에 대해 실행될 기능을 쓰는 부분.
	    		ㅡ 선택자)
	    			ㄴ 기본적으로 css의 선택자 형식과 같다.
	    			ㄴ 위 선택자부분에 " (*요소이름*) " 이렇게오면, 해당요소에대해 작업실행.
	    			ㄴ " # (*id이름*) " 이렇게오면 해당 id에 대하여 작업실행. (이 id는 css의 id를 말함)
	    			ㄴ " . (*클래스이름*)" 이렇게오면 해당 css클래스에대해 작업실행.
	    			ㄴ this나 다른 jQuery 객체를 집어넣어도 동작한다.
	    				ㄴ ex)
	    					var temp = $(this).after('< textarea> empty < /textarea>');
        								$(temp).on('keypress', keyEvent);
	    			ㄴ 그외 여러가지 선택자들이 있음.
	    			ㄴ 기타 추측 )
	    				ㄴ 선택자로 선택하면 해당하는 하나의 요소가 아닌 모든 요소가 선택되는 듯하다. 그리고 이에대해 이벤트bind를 하거나하면 그 모든
	    					요소에 바인드가 된다.
	    		ㅡ 액션)
	    			ㄴ 일반적으로 $() 다음에 와서 여러가지 기능을 제공하는 함수를 말함.
		    			ㄴ 여러가지 처리가 가능하며 대표적으로 예를 들어보면
		    				ex) $("p").click(function(){....});	=>모든 요소p에 대해 클릭이되었을때 function부분을
		    														수행함.
		    				$(document).ready();	=> 문서가 완전히 로드되기 이전에 제이쿼리가 실행되어 오류가 발생하는것을
		    											방지하고자 문서가완전히 로드될때까지 기다리는 작업.
		    				등등...
		    		ㄴ 쓸만한 대표적 액션들 ) <button>펼치기</button>
		    		<pre>
		    			ㄴ on( (*이벤트타입*), (*이벤트핸들러*) )
		    				ㄴ 이벤트 바인드함수. 선택자에 대해 해당 이벤트타입발생시 이벤트핸들러를 실행시킨다.
		    					ㄴ ex)
		    						$('textarea').on('keypress', function(e){
		    							~~~
		    						});
		    				ㄴ 이벤트핸들러에서 '이벤트 객체'를 넘길 수 있다. (자바스크립트와 동일)
		    				ㄴ 이벤트객체의 사용법, 이벤트 타입의 종류, 기타 다른 이벤트함수들은 공식사이트에서 확인.
		    				ㄴ bind()라는 액션이 있지만 on()과 약간 차이가 있고 bind()는 더이상 사용하지 않는 액션이라 한다.
		    			ㄴ text(), html()
		    				ㄴ html문서상의 요소의 내용을 가져오는 액션
		    			ㄴ val()
		    				ㄴ 위 text(), html()과 비슷한데 이 액션은 input에 입력된 값을 가져올 수 있따.
		    			ㄴ $().css()함수
		    				ㄴ 선택대상의 css 조작 및 값가져오는 함수.
		    				ㄴ css( (*스타일속성명*) ) : 해당 스타일값을 string으로 가져옴
		    				ㄴ css( (*스타일속성명*), (*속성값*) ) : 해당 스타일속성값 설정.
		    					ㄴ ex)
		    						if($(this).css('display') == 'block'){
					            		$(this).css('display', 'none');
					            	}
						ㄴ next() : 바로 다음 형제요소를 반환
						ㄴ after() : 바로 다음 위치에 (자식위치가아니고) 인자로 넘긴 요소 추가.
							ㄴ ex)
								$(this).after('< textarea> empty < /textarea>');
						ㄴ ajax()
							ㄴ ~~~~~
							ㄴ ex )
								$.ajax({
									url: "/more/addUserWithdrawal",  // url.
									type: "POST",  // 메소드 유형.
									headers: {  // 헤더 커스텀 입력 가능. .
										"X-CSRFTOKEN": csrfToken2,
									},
									// 요청에 같이 보낼 데이터. 'type'이 'get'같이 body를 가질 수 없는 경우, 쿼리 파라미터로 들어간다.
									data: {"feedbackChoice": feedbackChoice, "feedbackText": feedbackText },
									// 성공 응답시 호출되는 함수.
									success: function ( (*응답데이터*), String status, jqXHR jqXHR){
										~~~~~
									},
									// 에러 응답시 호출되는 함수.
									error: function ( jqXHR jqXHR, String status, String thrownError ) {~~~~~}
									// 요청에 대한 응답 완료 후 호출. success, error로 설정된 콜백함수가 호출된 뒤 호출.
									complete: function ( jqXHR jqXHR, String status ) {~~~~~}
								})
		    		</pre>

			ㅇ 타입<button>더보기</button>
			<pre>
				ㅇ JQuery 에서 사용되는 type
					ㅡ https://api.jquery.com/Types/#Element 참조.
					ㅡ Anything : 제이쿼리의 가상타입으로, 어떤한 타입이 와도 괜찮다는 의미.
					ㅡ String
						ㄴ js의 타입.
						ㄴ 비었거나, 하나 또는 여러 문자를 담을수있는 immutable한 원시타입이다.
						ㄴ 작은따옴표 안에 큰따옴표사용이 가능하고 그 반대도 가능. 같은걸쓰려면 역슬래쉬로 처리.
						ㄴ 내장 함수를 가짐. charAt(), toUpperCase(), replace(), split() 등등.
						ㄴ length 프로퍼티를 가짐. 마지막 null을 제외한 문자의 개수를 반환.
						ㄴ 빈 string은 디폴트로 false값을 가짐
					ㅡ htmlString
						ㄴ 제이쿼리의 타입.
						ㄴ string형이 jquery의 함수로 전달될때, < 태그>형태로 시작하는걸로 확인되면 html로 취급되며 내부적으로 htmlString으로 변환된다.
						ㄴ .append() 같은 함수의 인자로 전달되는 경우도 변환된다.
					ㅡ Number
						ㄴ js의 타입. 이며 string과같이 immutable한 원시타입이다.
						ㄴ c언어 기반의 모든 공통연산자를 사용할수있다한다.
						ㄴ 0이면 false를가진다.
						ㄴ js에서 Math객체를 통하여 여러기능을 제공한다. ex) Math.cos( ~~);
						ㄴ string을 파싱할수있다. ex) parseInt("123") => 123, parseInt("010") => 8, parseInt("010",10) =>10...
						ㄴ number에서 string 변환
							ㄴ string과 number을 +연산할 수 있다. string이 + 된 이후로는 string으로 변환되면 +연산역시 string의 +연산이된다.
							ㄴ ex )
								""+1+2; =>12. 처음부터 string이되고 1,2,를 string에 append.
								1+2+""; =>3. 1+2를 number로 연산후, ""를더해 string형으로 변환.
							ㄴ 확실하게하기위해 ( ) 을 사용권장.
						ㄴ js의 String 클래스를 사용하여 값을 string으로 변환가능. ex) String(1) + String(2) =>"12"
					ㅡ Boolean
					ㅡ Object
						ㄴ js의 Object형을 말함.
						ㄴ js의 모든것을 object라고는 하나
						ㄴ { } 형태로 선언하는 property : value형태의 값을 PlainObject라고 한다.
						ㄴ dot notation (.) 또는 array notation으로 프로퍼티에 접근할수있다. ex) x.name = "abc"; ,  x["name"] = "ccc";
					ㅡ Array
						ㄴ js의 array타입을 말함.
						ㄴ jQuery에서 Array< String>과 같은 형식이 가끔보이는데, 이는 보이는대로 String값이들어간 Array값을 기대한다는 의미.
					ㅡ Null
					ㅡ Date
						ㄴ js의 object.
						ㄴ 생성자를 통해 생성되며, 현재의 날짜와 시간을 나타낸다.
					ㅡ Function
					ㅡ Callback
					ㅡ Error
					ㅡ Selector
					ㅡ Event
						ㄴ 이벤트 핸들러에 자동으로 넘어가는 객체.
						ㄴ 다양한 프로퍼티들을 제공 )
							ㄴ target : 이벤트가 발생한 바로 그 요소를 가리킨다. 핸들러가 바인딩된 요소가 아니라.
					ㅡ Element
						ㄴ DOM의 element를 말함.
					ㅡ Text
						ㄴ DOM에서 요소나 속성의 글자를 나타내기위한 node.
					ㅡ JQuery
						ㄴ jquery에서 사용되는 object.
						ㄴ html string에 의해 생성된 요소나, 선택된 요소들의 collection.
						ㄴ jQuery()를 통하여 사용되나, $()로도 사용할 수 있다.
						ㄴ Array와 비슷하게 length가 있거나 []로도 접근이 가능하나 js의 Array는 아니다.
						ㄴ 대부분의 jQuery 메소드들은 같은 jQuery형태를 반환한다. 선택된 collection들을 한번더 필터링하는 식으로 자주사용되는듯하다.
							ex) $( "p" ).css( "color", "red" ).find( ".special" ).css( "color", "green" );
						ㄴ collection안에 아무 DOM도 없을 수 있으며, 이는 에러가 아니다. $()에서 아무인자도넘기지않는것을통하여 빈 jQuery object를 만들수있다.
					ㅡ XMLHttpRequest
						ㄴ jQuery의 Ajax 관련 함수들에서 사용된다.
						ㄴ ???자세한건 ajax에서..
					ㅡ 그외에도.. )
						ㄴ jqXHR, Thenable, Deferred Object, Promise Object, Callback Object, XML Document, Assert 가 있다.
			</pre>
	    	ㅇ AJAX
	    		ㅡ  전체 페이지를 다시로드하지않고 서버와데이터를교환해 페이지의 일부를 업데이트하는기술이다.

		</pre>
		Vue.js<button>더보기</button>
		<pre>
			Vue 기본<button>더보기</button>
			<pre>
				ㅇ 기초
					ex)	< div id="app">
				  			{{ message }}
						< /div>
					위는 html부분, 아래는 script부분.
						var app = new Vue({
							el: '#app',
					 		data: {
					 			message: '안녕하세요 Vue!'
					 		}
						})
					=> 대충이런식으로 Vue객체를선언하고 이를 통해 선언적으로 DOM에 데이터를 렌더링하는것이 핵심이라고한다.

				ㅇ 뷰 템플릿
					ㅡ 뷰 템플릿은 html,css 등의 마크업속성과 뷰 인스턴스에서 정의한 데이터 및 로직들을 연결하여, 사용자가 브라우저에서 볼수있는형태의 html로 변환해주는 속성.
					ㅡ 라이브러리 내부적으로 template속성에서 정의한 마크업+뷰 데이터를 가상 돔 기반의 render()함수로 변환한다. 변환된 render()는 최종적으로 사용자가 볼수있게
						 화면을 그리는 역할을 한다고한다. 변환과정에서   뷰의 '반응성'이 화면에 더해진다고한다.
					ㅡ 템플릿 속성을 사용하는 방법은 두가지로, 뷰 인스턴스에 template속성을 정의하는방법과 싱글파일 컴포넌트 체계의 < template>코드를 활용하는방법.
					ex)	전자의 예,
						new Vue({
							template: "< p>hello< /p>"
						});
						후자의예,
						< template>
							< p>hello< /p>
						< /template>

					ㅡ싱글파일 컴포넌트 체계)
						ㄴ template 옵션속성을 통해 치환될 html코드를 만들다보면 이게 문자열로 쭉 쓰는거라 보기힘들다. 그래서 싱글파일 컴포넌트 체계라는것을 이용한다.
						ㄴ ' .vue '라는 확장자를 가진 파일을 하나 만들어 이안에 컴포넌트를 정의하는것이다. 파일 하나당 컴포넌트 하나이다.
						ㄴ 문법)
							< template>
								(*치환도리내용*)	=>template 속성에 들어갈 내용이 들어간다.
							< /template>
							< script>
								export default{	=>ES6의 js모듈화와 관련된문법이라함.
									(*컴포넌트 내용*)
								}
							< /script>
							< style>
								(*template부분의 html내용의css스타일을 정의하는영역*)
							< /style>
						ㄴ 이 체계를 사용하기위해서는 브라우저가 .vue파일을 인식할수있는형태로 변환시켜주는 '웹팩(Webpack)'이나 '브라우저리파이(Browerify)'같은 도구가 필요하다.
						ㄴ 하지만 뷰에서 지원하는 CLI ( Command Line Interface) 도구를 통해 쉽게 프로젝트를 구성할수있다.

				ㅇ 데이터 바인딩 : html화면요소를 뷰 인스턴스의 데이터와 연결하는것을 의미한다. {{}}와 v-bind속성을 이용한다.
					ㅡ ex)	{{message}}	=>data속성의 message의 값이 치환된다.
					ㅡ v-bind : id,css,class같은 html요소의 속성값에 뷰 data값을 연결하려고할때사용하는 방식. 'v-bind'부분을 생략하고 ':'만 입력해도 작동한다.
						ex)	< p v-bind : (*속성이름*) = " (*뷰인스턴스의 data옵션속성의 프로퍼티 이름*) ">
					ㅡ 템플릿 안에 자바스크립트 표현식을 사용할수있다.
						ex)	{{message + "!!"}}, 또는 {{message.split('').reverse().join('')}}등등
						ㄴ 선언문이나 분기구문, 복잡한연산은 안된다.

				ㅇ 디렉티브
					ㅡ thml태그안에서 'v-'접두사를 가지는 모든 속성을 의미. v-bind같은거.	ex) < a v-if="flag">~~
					ㅡ 화면요소를 더 쉽게 조작하기위해 사용하는 기능. 데이터값이변경됨에따라 '반응형'으로 동작한다.
					ㅡ 종류)
						ㄴ {{ }} : 위에서말한 data항목안에 있는값들을 불러올수있는문법.
						ㄴ v-text = " (*뷰 인스턴스의 data옵션속성의 프로퍼티이름*) " : 태그속성으로 이값을 넣으면 해당태그내용으로 데이터값이 할당되는듯.
							ex)	< h1 v-text="name">< /h1>	=>뷰 인스턴스안에 data항목안에 name이란 데이터이름을가진 값이 < h1>의 내용으로들어감.
						ㄴ v-html = " (*뷰 인스턴스의 data옵션속성의 프로퍼티이름*) " : v-text는 그냥 값을 문자열로서 가져오는반면, 이속성값을 사용하면 데이터값을 html내용으로서 가져옴.
							즉, 내용을 html문법취급한다는말.
							ex)	< h1 v-html="name">< /h1>이고, name값이
								< p>aaa< /p>이면 < p>를 html문법취급하여 p태그를 적용시켜 값을가져온다는말. v-text속성을사용하면 그냥 < p>aaa< /p>가 그대로출력.
									(이런걸 html형식으로 렌더링?한다?고하는듯)
						ㄴ v-show = (*참거짓판별가능한값*) : 값이 참이면 해당속성이있는 태그를 보여줌.
						ㄴ v-if = (*참거짓판별가능한값*) : 위와같음 참이면 보여줌. 비슷한걸로 v-else-if, v-else도 있다.
						ㄴ v-pre : 이 속성이 있는 위치 다음에오는 속성들을 없는것으로취급한다.
						ㄴ v-cloak : 페이지가 로드될때 html부분이로드되고 js부분이 로드되는데(js가 로드되면서 Vue인스턴스가 준비됨) 이 두개가 로드되는 사이에 시간적텀이있어
							 페이지가 제대로 보여지지않는경우가있음. 이때 Vue인스턴스가 준비되기전까지 html코드를숨기고싶을때? 이 속성을사용하면된다.
						ㄴ v-once : 이 속성이 있는 해당 태그를 초기에 딱한번만 렌더링하고싶을때 사용.
						ㄴ v-on:(*이벤트종류*)=" (*메소드, 객체, 명령문*) " : 이벤트 핸들링 디렉티브. 해당 이벤트종류 발생시 실행할것들을 정할수있다.
							ㄴ 메소드를 사용할시, 해당 메소드에서 'event'라는 이름의 매개변수를 선언하면 '이벤트객체'를 사용할수있다.
						ㄴ v-model : html태그 < input>, < select>, < textarea>와 컴포넌트에 대해 양방향 바인딩 기능을 부여하는 디렉티브.

						*양방향 바인딩
							ㅡ 뷰인스턴스 data속성에서 data의 값을 바꾸면 html화면단에서 해당 값이 동적으로 바뀌는걸 볼수있는데 이때 인스턴스쪽에서 화면단으로 한쪽으로만
								데이터를 바인딩한거면 이를 단방향 바인딩이라한다.
							ㅡ 양방향 바인딩은 html요소에서 input, select등의 입력폼?에서 입력하는그대로 인스턴스data의 값이 바뀌고, 또 인스턴스 data의 값이 바뀌면 그대로
								화면단의 입력폼의 내용이 바뀌는식으로 양방향으로 데이터가 바인딩 된것을 말한다.

			</pre>
			Vue 인스턴스<button>더보기</button>
			<pre>
				ㅡ 뷰로 화면을 개발하기위해 필수적인 기본단위.
					ex)	new Vue({
							el : "#app",
							data : {
								message: "hello"
							}
						});
					ㄴ 대충 이런식으로 생겼다.
					ㄴ el, data 등은 뷰인스턴스의 속성들.

				??? 뷰 인스턴스에 대한 내용이지만 아직 잘모르겟는것들.
					ㄴ 뷰인스턴스를 생성할때 options object를 전달한다.
					ㄴ 모든 뷰 인스턴스는 뷰 컴포넌트이다.
					ㄴ 뷰 어플리케이션은 root vue 인스턴스로 이루어져있다고한다. root vue인스턴스는 new Vue를 통해 만들어지는 인스턴스.
					ㄴ 뷰가생성될때, data항목에 있는 객체들을 reactivity 시스템에 넣는다고한다. 그래서 이값들이 바뀌면 바로 반응하여 해당값들을 변경해준다고함.
						 '반응형'말하는거같음.


				ㅡ 뷰 인스턴스의 옵션속성 : 인스턴스를 생성할때 재정의할 data, el, template 등을 말함.
					ㄴ el : 뷰로 만든 화면이 그려질 시작점. 화면이그려질 DOM요소를 선택하는 속성.
					ㄴ template : 화면에 표시할 html, css등의 마크업요소를 정의하는속성. 뷰의 데이터및 기타속성들도 함께화면에 그릴수 있다.
					ㄴ methods : 화면 로직제어와 관련된 메서드를 정의하는 속성.
					ㄴ created : 뷰 인스턴스가 생성되자마자 실행할 로직을 저의하는 속성.
					ㄴ computed
						ㄴ 깔끔하고 유지보수가 쉬운 코드를 위해서 데이터 가공 등의 복잡한 연산은 인스턴스 안에서 하고 html에는 데이터를 표현하는것만 하는게 좋다.
						ㄴ 여기서 이 '복잡한' 연산부분을 computed속성에서 진행한다.
						ㄴ ex)	< div id="app">
									{{reversedMessage}}	=>이런식으로 html부분에는 간단하게 표현만진행. 아래의 복잡한 연산식부분을 넣지않는다.
								< /div>
								~~
								new Vue({
									~~
									computed:{
										reversedMessage : function(){
											return this.message.split('').reverse().join('');	=>computed속성에서 이렇게 복잡한 연산을 미리
																									 정의하여 이름만으로 출력될수있도록.
										}
									}
								})
						ㄴ computed속성은 data속성의 값변화에 따라 자동으로 연산을 다시해준다.
						ㄴ 캐싱기능도 지원한다. 캐싱이란 동일한 연산을 반복하지 않기위해 결과값을 저장해두었다가 필요할때 가져다쓰는 것을 말함.
					ㄴ watch 옵션 속성
						ㄴ computed와 비슷하게 데이터 변경이 일어날때마다 자동으로 특정 로직을 수행하는 속성.
						ㄴ data와 같은 이름의 값들을 설정해두고 해당 값에 변경이 일어나면 설정해둔 함수를 실행시킨다.
						ㄴ ex)	data:{
								number:0;
							},
							watch:{
								number: function(~~){~~}	=>data의 number의 값변경시 이 함수 실행.
							}


					*methods속성과 computed속성의 차이점
						ㅡ 전자는 호출될때만 로직수행, 후자는 데이터 변경이 일어나면 자동으로 수행.

				*뷰 인스턴스가 화면에 적용되는과정
					1. 뷰 라이브러리 파일 로딩
					2. 인스턴스 객체생성(옵션속성포함)
					3. 특정화면 요소에 인스턴스를 붙임
					4. 인스턴스내용이 화면요소로 변환
					5. 변환도니 홤녀요소를 사용자가 최종확인

				ㅡ 뷰 인스턴스의 유효범위
					ㄴ 뷰 인스턴스의 옵션속성들은 html의 특정범위 안에서만 적용이되어 나타난다. 이를 유효범위라고한다.
					ㄴ el 옵션속성에 지정한 값에 해당하는 DOM에 뷰 인스턴스가 붙게되며, 이 DOM요소가 해당 인스턴스의 유효범위가 된다.
					ㄴ 인스턴스가 해당DOM요소에 부착되고 인스턴스의 data옵션속성의 값이 해당DOM요소와 그 안의 요소에 적용되어 값이 치환된다. 당연히 이 data의 값들도 유효범위
						안에서만 사용할수있다. ex) {{ message }}같이 .

				*뷰의 반응성
					ㅡ el 속성에 지정한 요소에 인스턴스를 부착하고나면 인스턴스에 정의된 속성들이 화면 요소에 치환된다.
					ㅡ 치환된 값들은 뷰의 '반응성'을 제공하기위해 '$watch' 라는 속성으로 감시가되며
					ㅡ 감시하고있다가 데이터가 변경되면 해당값에 맞게 화면을 다시 그려준다.
					ㅡ 뷰 인스턴스가 처음 생성될때 존재했던 data 값들에 대해서만 반응성이 유지가 된다. 나중에 추가한건 해당없음.

				ㅡ 뷰 인스턴스와 라이프사이클)
					ㄴ 뷰 인스턴스도 라이프사이클을 가진다. 인스턴스가 생성되고, 화면에 부착되고, 소멸되기까지의 과정.
					ㄴ 라이플사이클속성 : 뷰인스턴스의 속성의 일종. 라이플사이클의 특정 시점들에서 호출되는 속성들. created, beforeCreate, beforeMount등등이 있다.
					ㄴ 라이플사이클 훅(hook) : 각 라이플사이클 속성에서 실행되는 커스텀 로직. (커스텀로직이란 개발자가 임의로 작성한 추가로직)
					ㄴ 크게 인스턴스의 '생성', 화면에 '부착', 인스턴스 내용의 '갱신', 인스턴스 '제거'의 4단계로 나뉘어져있다.
					ㄴ beforeCreate : 인스턴스 생성후 가장 처음으로 실행되는 단계. data속성과 methods속성이 아직 인스턴스에 정의되어잇지않고 DOM에도 접근할수없다.
					ㄴ created : beforeCreate단계다음에 실행. data속성과 methods속성의 정의되기때문에 이들을 이용할수있다. 아직부착되기는 전이라서 template에 있는DOM에는 접근 x.
					ㄴ beforeMount : created 다음단계. template속성이 제정한마크업속성을 render()로 변환후 el속성으로 지정된 요소에 인스턴스를 부착하기전에 호출되는단계.
						(render()함수는 js로 화면에 DOM을 그리는 함수)
					ㄴ mounted : 인스턴스 부착후 호출되는단계. 이제 DOM에 접근할수가있다.
					ㄴ beforeUpdate : 관찰하고있는 데이터가 변경되고나면 가상 DOM으로 화면을 다시그리기전에 호출되는단계. 변경예정인 새 데이터에 접근할수있고 관련로직을 미리넣을수있다.
					ㄴ updated : 데이터변경에따라 가상DOM으로 화면이 다시그려지고나서 호출되는 단계. 데이터변경후 화면요소제어와 관련된 로직을 추가하기에좋다.
					ㄴ beforeDestroy : 인스턴스 파괴전에 호출되는단계. 아직 인스턴스에 접근할수잇다.
					ㄴ destroyed : 인스턴스가 파괴되고나서호출되는단계.

					<img src="image/뷰 인스턴스 라이프사이클.png" style="height:600px; width:auto;">
			</pre>
			Vue 컴포넌트 <button>더보기</button>
			<pre>
				ㅇ 컴포넌트
					ㅡ 컴포넌트란 말그대로 화면의 구성요소, 즉 조합하여 화면을 구성ㅇ할수있는 블록(화면의 특정영역)을 의미한다
						ㄴ 이를 이용하면 화면을빠르게 구조화할수가잇으며
						ㄴ 재활용성, 유지보수가 편해진다.
						ㄴ 웹화면을 예를들면, <img src="image/컴포넌트 예.png" style="height:300px; width:auto;">
						Header, content, Footer이란 컴포넌트로 구성되어있고 Content안에는 또 Aside, List라는 컴포넌트로 구성이 되어있다.

					ㅡ 컴포넌트는 지역컴포넌트와 전역컴포넌트가있으며, 전자는 특정 인스턴스에서만 휴효한 범위를 갖고, 후자는 여러 인스턴스에서 공통으로 사용할수있다.
					ㅡ 컴포넌트는 재사용가능하고 이름이잇는 뷰 인스턴스라고한다.
					ㅡ컴포넌트의 data항목은 직접 객체로 존재하는게아니라 함수의 리턴값으로서 존재한다고한다.
						ex)	data:{
								count:0
							}
							이게 아니라,
							data: function(){
								return {
									count:0
								}
							}
							이런식으로.

				ㅇ 동적 컴포넌트
					ㅡ 컴포넌트를 만드는데 어떤컴포넌트인지 정해져있는게 아니라 특정 값에따라서 동적으로 결정되도록 하는 컴포넌트
					ㅡ < component> 태그를 사용하며 v-bind로 is속성을 설정시켜준다. 이 is속성의 값에 따라서 동적으로 어떤컴포넌트인지 정해진다.
					ㅡ ex)	< component v-bind:is=" (*값*) "> ~~< /~~>	=>(*값*)은 등록된 컴포넌트의 이름이 들어있는 data옵션속성의 속성이름.

					*is 속성
						ㅡ 위 동적컴포넌트 이외에도 is속성이 쓰이는 경우가 있다.
						ㅡ < ul>, < ol>, < table>, < select>요소는 문법상 그 내부에 사용자가만든 컴포넌트 이름을 사용할수없다.
						ㅡ 해서 원래 들어가야하는 요소를 일단 쓰고 속성으로 'is'를 주고 그 속성값으로 사용자가만든 컴포넌트 이름을 주는 방식으로 컴포넌트를 사용한다.

				ㅇ 컴포넌트 등록방법
					ㅡ 지역등록과 전역등록 두가지가있다고함.
					ㅡ 전역 컴포넌트등록)
						ㄴ 뷰 라이브러리를 로딩하고 나면 접근가능한 Vue변수의 component()함수를 이용해 등록한다.
							ex)	Vue.component( " (*컴포넌트이름*) ", { (*컴포넌트 내용*) } )
						ㄴ 컴포넌트이름은 html사용자 정의태그 이름을 의미. 컴포넌트 내용은 컴포넌트 태그가 실제 화면의 html요소로 변환될때 표시될 속성들을 작성하는부분이다.
							template, data, methods 등의 인스턴스 옵션속성을 정의할수잇다.
						ㄴ 컴포넌트 명명법으로 파스칼이나 카멜 표기법을쓰면 오류뜨는듯함.
						ㄴ 이유는모르겟지만 이렇게 등록한다음 뷰인스턴스를 생성해야 사용이 가능하다. 등록전에 생성한 인스턴스에 대해선 사용불가.
						ㄴ '컴포넌트이름'부분이 '커스텀 엘리먼트'라고 하며 페이지에서 해당부분이 컴포넌트의 template의 내용을 교체된다.
					ㅡ 지역컴포넌트 등록)
						ㄴ 인스턴스에 components속성을 이용해 등록한다.
						ㄴ형식)
							var v= new Vue({
								~~~,		=>그냥 뷰인스턴스정의하듯이 data나 el속성등이 온다.
								components : {	=>data, el같은 속성중 하나로서 components란 속성을 사용하여 지역컴포넌트 등록. 이 뷰인스턴스에 대해서만 컴포넌트 사용가능.
									"(*컴포넌트이름*)" : (*컴포넌트 내용*)	=>전역컴포넌트등록처럼 이름과 컴포넌트 내용을 입력한다. 근데 보통 내용부분은 따로 변수로
																		저장해주었다가 이곳에 입력하는방식으로 하는것같다.
								}
							})

						ex)	var cmp={		=>컴포넌트내용으로쓸 정보를 변수에 미리저장.
								data:function(){~~~}
								template:~~~
							}
							new Vue({
								components : {
									'my' : cmp	=>컴포넌트 내용이 저장되어있는변수를 전달.
								}
							})

			</pre>
			컴포넌트간 통신<button>더보기</button>
			<pre>
				ㅡ 뷰는 컴포넌트로 화면을 구성하고, 컴포넌트마다 자체적으로 고유한 유효범위를 가지기때문에 컴포넌트간의 직접적인 값을 참조할수가 없기때문에 같은 웹페이지상에서 데이터를 공유할수가 없는 특징이있다.
				ㅡ 해서 뷰에서는 뷰 프레임워크에서 정의한 컴포넌트 데이터 전달방식을 따라야만 데이터 공유가 가능하다.
				ㅡ 상위,하위 컴포넌트간 데이터 전달방법.
					ㄴ 앞서배운방법으로 전역,지역컴포넌트를 등록하면 해당컴포넌트는 하위컴포넌트, 이 컴포넌트들을등록한 인스턴스는 상위컴포넌트가 된다.
					<img src="image/컴포넌트 통신.png" style="height:300px; width:auto;">
					ㄴ 뷰에서 제공하는 상위,하위컴포넌트간 데이ㅣ터 전달방법은 그림과같다. 상위컴포넌트는 props라는 속성을 하위컴포넌트에게 전달할수있고 하위컴포넌트는 상위컴포넌트에게 이벤트만 전달할수있다.
					ㄴ 상위에서 하위컴포넌트로 통신 : props 속성)
						ㄴ 먼저 하위컴포넌트에 props라는 이름의 속성을 정의해야한다.
							ex)	Vue.component("~~", {
									props : [ " (*props 속성이름*) " ],
									~~
								});
						ㄴ 그다음 컴포넌트 태그에서 v-bind속성을 통해 props속성값을 넘겨주어 데어터를 전달한다.
							ex)	<~~ v-bind:props (*속성이름*)=" (*상위컴포넌트의data속성*) ">< /~~>
								=> 속성이름 부분에는 props속성이름이 와야한다.
					ㄴ 하위에서 상위컴포넌트로 통신 : 이벤트전달)
						ㄴ 기본적으로 하위에서 상위컴포넌트로의 데이터전달은 되지않는다. 뷰의 단방향 데이터 흐름에 어긋나는 방법이기때문에. 하지만 이후나오는 '이벤트 버스'를 사용하여 구현이 가능하기는 하다.
						ㄴ 하위컴포넌트에서 상위컴포넌트로의 통신은 이벤트를 상위컴포넌트로 전달하는 방식을 이용한다.
						ㄴ 이벤트 발생과 수신)
							ㄴ발생)
								$emit( " (*이벤트명*) " )을 이용하여 (*이벤트명*)이란 이름의 이벤트를 발생시킨다.
								보통 하위컴포넌트의 특정 메소드 내부에서 발생시킨다.
								ex)	this.$emit("show-log");	=>show-log라는 이름의 이벤트 발생.

							ㄴ수신)
								v-on : (*이벤트명*) = " (*상위컴포넌트의 메소드명*) " 을 통해 이벤트를 수신한다.
								이유는 잘모르겟지만 하위컴포넌트 요소에 대해 이벤트 수신설정을 해야지만 제대로 작동한다. 위의 $emit로 발생시킨 이벤트명이 (*이벤트명*)부분에 오게되며 $emit로 이벤트를 발생시키면 v-on으로 수신설정해둔곳으로 이벤트가전달된다. 그럼 (*상위컴포넌트의메소드명*)부분이 실행되는방식.
								ex)	<(*컴포넌트이름*) v-on: show-log="printText">< /~~>	=>show-log라는 이름의 이벤트발생시, printText라는 메소드실행.
									~~
									Vue.component('simple-counter', {
									  template: '< button v-on:click="showLog">haha< / button>',
									  methods:{
									  	showLog:function(){
									    	this.$emit("show-log");	=>show-log라는 이름의 이벤트를 발생시킴.
									    }
									  }
									})

									new Vue({
									  el: '#example-2',
									  methods:{
									  	printText:function(){
									    	console.log("mmm"+(this.num2++));
									    }
									  }
									})

					ㄴ 같은레벨 컴포넌트간 통신
						ㄴ 공통의 상위컴포넌트로 전달후(없으면 만들어서) 그 상위컴포넌트에서 props속성으로 데이터를 내려주는방식으로 진행된다. 근데 복잡해서 잘안쓰임.

				ㅡ 이벤트 버스형식 컴포넌트간 통신
					ㄴ 컴포넌트가 많아지면 통신을 위해 상,하위 컴포넌트들이 많아져 데이터전달이 매우 복잡해진다.
					ㄴ 그래서 이벤트버스형식을이용해 바로 직접적으로 데이터를 주고받음.
					ㄴ 임의의 새로운 뷰 인스턴스를 만들고 그 인스턴스에 대해 이벤트를 발생시키고 수신하는 방식을 사용한다.
					ex)	var eventBus = new Vue();
						~~
						(값을 전달하려는 컴포넌트 안에서)
						eventBus.$emit( "(*이벤트명*)", (*전달할값*) );	=>임의로만든 인스턴스에 대해 (*이벤트명*)이름을 가진 이벤트를 발생시키며 값을전달한다.
						~~
						(값을 받으려는 컴포넌트 안에서)
						eventBus.$on( "(*이벤트명*)", function( (*매개변수*) ) {	=>매개변수부분에 위 $emit()를통해 전달된값이 저장된다.
							(*실행할 내용*)
						});
			</pre>
			트랜지션 및 애니메이션<button>더보기</button>
			<pre>
				ㅇ 트랜지션 기본
					ㅡ 뷰에서는 transition이라는 컴포넌트를 이용해 요소가 생성되고 제거될때마다 발생하는 효과를 쉽게 설정할수있다. 트랜지션효과란 장면전환효과 같은것.
					ㅡ < transition > : 트랜지션 래퍼 컴포넌트. 이태그로 감싸진 요소가 생성되고 제거될때마다 발생하는 트랜지션을 설정할수있다.
						ㄴ 하나의 컴포넌트나 html요소에 대해서만 트랜지션 설정이 가능하다.
						ㄴ v-if, v-else 등을 이용해 여러컴포넌트,요소간 트랜지션 설정이 가능하다.
							ex)	< transition>
									< table v-if="~~">
									~~
									< /table>
									< p v-else>~~< /p>
								< /trasition>

							 	(html에서)
								< transition name=" (*이름*) ">	=>발생시킬트랜지션효과 이름지정. css에서 해당이름의 트랜지션클래스와 연결이된다.
									(*트랜지션 발생시킬부분*)
								< /transition>
								~~
								(css에서)
								.(*이름*)-enter-active { (*원하는 css효과*) }	=>트랜지션 name에 해당하는 트랜지션클래스
								.(*이름*)-leave { (*원하는 css효과*) }

				ㅇ 트랜지션 설정하기
					ㅡ 트랜지션 클래스)
						ㄴ 트랜지션 클래스는 트랜지션 효과를 설정해주는 css클래스이며, 6종류가 있고  각각 적용되는 타이밍이있다. 클래스이름은 < transition>에서 부여한 name속성값을
							앞에 붙여주는 형태이다.
						ㄴ 트랜지션 클래스 종류
							ㄴ (*이름*)-enter : 요소가 삽입되기전에 적용되고 한프레임 후에 제거.
							ㄴ (*이름*)-enter-active : 요소가 나타나는 트랜지션이 진행되는동안 적용
							ㄴ (*이름*)-enter-to : 요소가 나타나는 트랜지션이완료될때 적용
							ㄴ (*이름*)-leave : 요소가 사라지기시작할대 적용
							ㄴ (*이름*)-leave-active : 요소가 사라지느 트랜지션이 진행되는 동안 적용
							ㄴ (*이름*)-leave-to : 요소가 사라지는 트랜지션이 완료될때적용
						ㄴ css클래스이기때문에 트랜지션클래스의 내용으로는 css에서쓰는 트랜지션이나 애니메이션효과를 사용할수있다.

					ㅡ 트랜지션 설정하기 방법2)
						< transition>에 다음 속성들을 추가하는 방식으로 커스텀 트랜지션 클래스를 설정할수도있다. 외부 css라이브러리와 연결할때 유용하다고한다.
							ㄴ enter-class, enter-active-class, enter-to-class, leave-class, leave-active-class, leave-to-class

					ㅡ 트랜지션 설정하기 방법3)
						ㄴ < transition>에 js훅을 이벤트 등록하여 트랜지션효과를 설정할수도있다.
						ㄴ 제공되고있는 js훅은 다음과같다.
							before-enter, enter, after-enter, enter-cancelled, before-leave, leave, after-leave, leave-cancelled
						ㄴ ex)	< transition
									v-on:before-enter="beforeEnter"
									v-on:enter="enter"
									v-on:after-enter="afterEnter"
									v-on:enter-cancelled="enterCancelled"

									v-on:before-leave="beforeLeave"
									v-on:leave="leave"
									v-on:after-leave="afterLeave"
									v-on:leave-cancelled="leaveCancelled"
								>
							  	<!-- ... -->
								< /transition>
						ㄴ 속성값들을 인스턴스의 methods로 정의하면 된다.
						ㄴ enter, leave훅에 대해서는 해당 속성값인 함수안에 done()를 추가해야한다고한다.
						ㄴ v-bind:css="false"를 추가하여 css부분이 아예무시되도록 확실하게 설정하는것도 좋은방법이다.

					ㅡ 트랜지션효과와 애니메이션효과를 동시에쓸경우 주의사항)
						뷰가 내부 시스템상에서 트랜지션 효과가 끝났음을 알아야하는데, 이를 transitionend나 animationend로 파악을한다. 해서 트랜지션효과로 둘중 하나만사용하면
						문제가없지만, 둘다 사용하는경우 어떤동작이 끝났을때가 트랜지션효과가끝난건지를 결정해주어야한다고한다. 이를 < transition>의 type속성값으로 animation또는
						transition을 주어 결정해준다.

					ㅡ 트랜지션 래퍼 컴포넌트에 duration속성을 사용하여 트랜지션 지속시간을 설정할수있다.
						ex)	< transition :duration="1000">~~

				ㅇ 최초 렌더링시 효과부여
					ㅡ 요소 또는 컴포넌트가 최초 렌더링될때 트랜지션 효과가 나타나도록 설정할수있다.
						ㄴ 트랜지션 래퍼 컴포넌트에 'appear' 속성을 입력하면된다(속성값없이 그냥 appear만)
						ㄴ 또는 '트랜지션설정하기 방법2'처럼 커스텀 트랜지션 클래스를 지정할수도잇다.
							< transition
							  appear
							  appear-class="custom-appear-class"
							  appear-to-class="custom-appear-to-class" (2.1.8+)
							  appear-active-class="custom-appear-active-class"
							>
						ㄴ '트랜지션설정하기 방법3'처럼 js훅을 이용할수도있다.
							< transition
							  appear
							  v-on:before-appear="customBeforeAppearHook"
							  v-on:appear="customAppearHook"
							  v-on:after-appear="customAfterAppearHook"
							  v-on:appear-cancelled="customAppearCancelledHook"
							>

				ㅇ html요소 간 트랜지션
					ㅡ < transition>안에는 요소나 컴포넌트 하나만 와야하지만, 예에서 보는것처럼 v-if등을 이용해서 여러 요소를 넣어놓고 동작시킬수있다.
						ㄴ단, 트랜지션 래퍼 컴포넌트 안에 같은이름의 태그가 겹치면 태그에 key라느 속성값을 주어 구분ㅇ이가능하도록해야한다.
					ㅡ ex)	< transition>
						  		< table v-if="items.length > 0">
						   			<!-- ... -->
						  		< /table>
						  		< p v-else>Sorry, no items found.< /p>
							< /transition>

				ㅇ 컴포넌트 간 트랜지션
					ㅡ 컴포넌트를 트랜지션할때)
						ㄴ 요소들간 트랜지션과 마찬가지로 < transition>내에는 하나의 컴포넌트만 올수있는데 '동적컴포넌트'를 이용하면 이런 제약을 좀 해결할수있다.

				ㅇ 트랜지션 모드
					ㅡ 트랜지션 래퍼 컴포넌트의 특징중 하나는 요소가 삽입되는과정과 제거되는과정이 동시에 이루어진다는것이다.
					ㅡ 이게 보기에 원하는 효과일수도있지만 아닐수도있다. 이때 트랜지션 모드를 이용하면 이를 조절할수있다.
					ㅡ < transition>태그에 'mode'라는 속성을 추가하고 속성값으로 'in-out' 또는 'out-in'을 준다.
					ㅡ in-out : 새로운 요소가 삽입된뒤, 제거될요소가 제거된다.
					ㅡ out-in : 위의 반대.

				ㅇ 리스트 트랜지션
					ㅡ 한꺼번에 여러개의 요소나 컴포넌트들을 동시에 트랜지션 설정하고자 할때 < transition-group>컴포넌트를 사용하면된다.
					ㅡ < transition>이 DOM요소를 직접랜더링하지않고 단순히 트랜지션 동작만 건드렸다면, < transition-group>은 DOM요소 자체를 랜더링한다. tag속성의
						속성값에 해당하는 요소하나를 랜더링한다. 기본값은 span.
					ㅡ 트랜지션 모드는 이것에선 의미가 없다.
					ㅡ 내부의 모든요소들은 key속성을 가져야한다. (key값은 리터럴 안됨)
					ㅡ ex)	< transition-group name="list" tag="p">      	=>< p>를 랜더링하며 그 내부에 아래의 내용들이 들어간다.
							< span v-for="item in items" v-bind:key="item" class="list-item">
								{{ item }}
							< /span>
						< /transition-group>
					ㅡ 리스트 트랜지션은 요소의 움직임에 대한 트랜지션 효과부여도 가능하다. css에 ' (*트랜지션name*)-move ' 형태로 클래스를 정의하면 트랜지션 래퍼 컴포넌트
						안의 요소가 움직일때 적용할 틀내지션 효과를 설정할수있다.
						ex)	< transition-group name="flip-list"~~>		=>name은 flip-list.
							~~
							(css에서)
							.flip-list-move{		=>이런식으로 이름을 사용.
								transition:transform 1s;
							}

				ㅇ 트랜지션 재사용
					ㅡ 컴포넌트로 트랜지션 내용을 미리 등록해놓고 재사용할수있다.
					ㅡ ex)
						Vue.component('my-special-transition', {
						  template: '\
						    < transition\
						      name="very-special-transition"\
						      mode="out-in"\
						      v-on:before-enter="beforeEnter"\
						      v-on:after-enter="afterEnter"\
						    >\
						      < slot>< /slot>\	=>이 slot태그부분이 지금만든 컴포넌트 안에 입력할 태그로 대체될부분.
						    < /transition>\
						  ',
						~~
						(html에서)
						< my-special-transition>
							< p>haha< /p>	=>slot부분이 이 p부분으로 대체된다.
						< /my~~>

					ㅡ 이런식의 트랜지션 재사용은 컴포넌트부분에설명되어있는 'functional component' 와 잘 맞는다.

				ㅇ 상태 트랜지션
					ㅡ 요소나 컴포넌트뿐만 아니라 데이터값이나 css, svg노드의 위치?, 사이즈와 요소ㅇ의 다른속성들에 대해서도 트랜지션효과를 적용할수있다. 이 문서에서는 서드파이 라이브러리를 사용하였다.
					ㅡ watch 옵션속성을 사용하여 데이터 변화에 대한 애니메이션을 설정할수있다.
					ㅡ 예제1에서는 데이터 값의 변경에 대한 애니메ㅣㅇ션 효과를 넣고있고, 예제2에서는 css같은 색변화에 대해 애니메이션 효과를 넣굉ㅆ다.
					ㅡ예제 3은 뭘말하고싶은지모르겟음
					ㅡ 이런 상태 트랜지션이 많아질수록 코드의 복잡도가 빠르게증가하는데, 상태트랜지션을 하위컴포넌트로 분리해 정의하는것으로 이를 해결할수있다.

			</pre>
			재사용성과 컴포지션?<button>더보기</button>
			<pre>
				ㅇ Mixin
					ㅡ mixin 객체를 말한다. 이 객체는 컴포넌트가 가지는 옵션속성들을 모두 가질수있으며, 이후에 컴포넌트의 옵션속성으로 삽입되면 가지고있던
						 모든 옵션속성들이 그 컴포넌트에 포함된다.
					ㅡ ex)	// define a mixin object
							var myMixin = {
							  created: function () {
							    this.hello()
							  },
							  methods: {
							    hello: function () {
							      console.log('hello from mixin!')
							    }
							  }
							}

							// define a component that uses this mixin
							var Component = Vue.extend({
							  mixins: [myMixin]
							})

					ㅡ 컴포넌트의 재사용성을 높이는 유연한 기능이다.
					ㅡ 옵션속성의 중복시)
						ㄴ mixin의 옵션속성과 믹스인이 포함되는 컴포넌트의 옵션속성의 내용이 겹치면 특정 규칙에 의해 통합된다.
						ㄴ data옵션속성의 내용이 겹치면 컴포넌트가 가지고있느느 내용이 우선권을가지고 덮어씌여진다.
						ㄴ 훅(hook)이 겹치면 두개의 훅이 배열로써 통합되고 둘다 호출된다. 믹스인의 훅이 먼저 호출된다.
						ㄴ methods, components, directives와 같은 객체형태의 옵션속성들은 하나의 객체로 통합되며, 충돌시 컴포넌트의 내용이
							우선권을 가지고 덮어씌여진다.

					ㅡ 뷰의 Global Config인 'Vue.config.optionMergeStrategies'을 이용하면 통합규칙을 설정할수있다고한다.
						(어떻게쓰는지는 이해가 안감.)

				* 커스텀 옵션속성, custom option
					ㅡ 뷰 컴포넌트에 직접 만든 옵션속성을 추가할수있다.
					ㅡ 방법)
						1. 그냥 다른 옵션속성 정의하듯이 원하는 이름과 'Object'형태의 값을가지는 옵션속성을 정의한다.
							ex)	new Vue({
									el:"#app",
									mycustomoption1 : 'hello',
									mycustomoption2 : {
										x1:"haha",
										x2:"hehe"
									}
								}
								=> 'mycustomoption1'과 'mycustomoption2'를 커스텀옵션속성이름으로 정하고 값으로 문자열 'hello'
									와 객체 {x1:"haha",x2:"hehe"}를 주엇다.
						2. 정의한 커스텀 옵션속성을 인스턴스 내에서 '$options'키워드를 이용해 사용할수있다.
							ex)	~~~
								methods:{
									xxx:function(){
										console.log(this.$options.mycustomoption1);
										console.log(this.$options.mycustomoption2.x2);
									}
								}
								=>콘솔로 'mycustomoption1'의 문자열과 'mycustomoption2'의 x2값을 출력하였다.
					ㅡ 주의)
						ㄴ 문서를 읽고안게 아니라 대충예시보고 해보면서 안거라 정확하지 않을수있다.

				ㅇ 글로벌 Mixin
					ㅡ 글로벌 컴포넌트처럼 믹스인도 글로벌로 등록할수있다.
					ㅡ 주의)
						ㄴ 등록하면 이후에 생기는 모든 뷰 인스턴스에 이 믹스인이 포함되므로(third party까지) 매우 주의해서 사용해야한다
						ㄴ 보통 커스텀 옵션속성에 대한 로직처리로만 사용한다고한다. 아래 예와 같은
							ex)
								// inject a handler for `myOption` custom option
								Vue.mixin({
								  created: function () {
								    var myOption = this.$options.myOption
								    if (myOption) {
								      console.log(myOption)
								    }
								  }
								})

								new Vue({
								  myOption: 'hello!'
								})
								// => "hello!"

				ㅇ custom directive (커스텀 지시자)
					ㅡ v-model, v-show 등과 같은 뷰 지시자들을 직접 만들수있다.
					ㅡ 방법)
						ㄴ 역시 글로벌 커스텀 지시자와 로컬 커스텀 지시자의 등록방법이있다.
							ㄴ 글로벌 커스텀 지시자 등록)
								ex)	Vue.directive( " (*커스텀지시자이름*) ", { (*커스텀 지시자 내용*) });
							ㄴ 로컬 커스텀 지시자 등록)
								ㄴ 옵션속성으로 'directives'옵션속성을 사용하면된다.
								ex)	~~
									directives:{
										(*커스텀지시자1이름*):{ (*커스텀지시자 내용*) },
										(*커스텀지시자2이름*):{ (*커스텀지시자 내용*) }
									}
						ㄴ (*커스텀지시자 내용*)으로 오는것들은 지시자를 정의할때 제공하는 hook function들이있다.
							ㄴ bind : 커스텀 지시자가 요소에 바운드될때 한번만 호출되는 함수.
							ㄴ inserted :
							ㄴ update :
							ㄴ componentUpdated :
							ㄴ unbind :
						ㄴ 그리고 이 hook function들은 자동적으로 다음과 같은 인자를 받는다.
							ㄴ el
							ㄴ binding : 다음의 프로퍼티들을 포함하고있는 객체.
								ㄴ name
								ㄴ value
									ㄴ 어떠한 자바스크립트 표현식도 값으로 받을수있다.
								ㄴ oldValue
								ㄴ expression
								ㄴ arg
									ㄴ 받는 값이 동적으로 바뀐다.
								ㄴ expression
								ㄴ modifiers
							ㄴ vnode
							ㄴ oldVnode

			</pre>

		</pre>
		React<button>더보기</button>
		<pre>
			ㅡ 리액트 공식홈페이지 문서 참고
			ㅇ 기본 개념<button>더보기</button>
			<pre>
				ㅡ 기타 기본) <button>더보기</button>
				<pre>
					ㄴ DOM vs virtual DOM )
						* DOM이란?
							ㅡ document object model
							ㅡ 브라우저 상에서, html이나 xml문서를 '노드'형태로 구조화하여, 각 노드에 접근하고 상호작용할 수 있게 해주는 api.
								ㄴ 노드란, html의 div같은 요소나 문자열 등이라 볼 수 있다.
								ㄴ js와 같이 자주 사용되지만 js와 dom은 독립적이다. 가령, 파이선에서도 dom이 존재한다.
						ㄴ 일반 DOM 조작 )
							ㄴ dom이란, 문서 객체 모델이라 하여, html의 요소들을 js가 이용할 수 있는 객체형태로 나타낸 것
							ㄴ 브라우저는 DOM을 그려서 웹 페이지를 보여준다.
							ㄴ js등으로 dom을 조작하게 되면 브라우저는 dom을 다시그리고, dom에 css을 다시 입혀서 화면을 보여준다.
								ㄴ 작은 변화가 생길때마다 브라우저가 dom을 다ㅣㅅ그리고 css를 입히는 식으로 불필요한 작업량이 많아진다.
								ㄴ 이 과정에서 성능이슈가 생길 수 있다.
						ㄴ 리액트의 virtual DOM 조작 )
							ㄴ 리액트에서는 실제DOM의 사본을 만들어(virtual dom) 이를 조작하는 방식으로 화면을 조작한다.
							ㄴ 가상 dom은 js코드이므로, 실제 dom보다 업데이트하는 속도가 매우 빠르다.
							ㄴ 가상 dom을 수정한후, 리액트가 실제 dom과 가상 dom의 차이를 확인하고 다른 부분만 업데이트 시켜주는 방식으로 동작.
							ㄴ 불필요하게 화면 전체의 dom을 다시그리지 않아 성능이슈가 해결된다.
 							ㄴ 리액트에서는 이 가상 dom이 '리액트 엘리먼트'로 이루어져 있다. 이 리액트 엘리먼트와 dom과의 차이를 비교해서 다시그려주는 작업을 해주는게 '리액트 dom'이라 한다.
								ㄴ ex) const element = < h2>hello< /h2>
				</pre>
				ㅡ JSX )<button>펼치기</button>
				<pre>
					* JSX<button>더보기</button>
					<pre>
						ㅡ js로 컴파일되는 statically-typed, object-oriented 프로그래밍 언어이다.
						ㅡ js보다 더 강력한 언어를 만들기 위해, 그리고 js의 성능향상을 위해 만들어졌다.
							ㄴ 그래서 statically-typed이고
							ㄴ 'inline expansion'이라는 기능으로 js의 성능을 향상시켜준다.
								ㄴ 'inline expansion'은 함수의 바디가 그 함수가 호출되는 곳으로 확장되는 것? { ()=>{ ~~~~ } } 이런걸 말하나?
						ㅡ 문법과 표현이 js와 많이 닮았다.
						ㅡ ????? 이건 DeNA Co의 JSX? 리액트에서 사용하는 JSX랑 다른건가? 똑같을거같은데..
					</pre>
					ㄴ js의 일종. js를 확장한 문법이라함.
					ㄴ 리액트에서 js코드로 '리액트 엘리먼트'를 쉽게 생성하게 하기위해 추가된 문법이다. 아래 예제와 같이 문법에 맞게 작성하면
						'Babel'컴파일러가 이를 React.createElement()로 적절하게 변환해주어 '리액트 엘리먼트'를 생성할 수 있게 된다.
					* Babel <button>더보기</button>
					<pre>
						ㅡ https://babeljs.io/docs/en/index.html
						ㅡ js 컴파일러
						ㅡ 주로, 현재와 이전 브라우저, 환경에서 ECMAScript 2015+코드를 이전버전js로 변환하는데 사용되는 도구모음.
						ㅡ 기능
							ㄴ 변환 구문
							ㄴ 대상 환경에서 누락된 기능들
							ㄴ 소스코드 변환
							ㄴ 기타 등등
						ㅡ 이 안에 React의 JSX를 변환해 주는 기능이 포함되어 있다.
					</pre>
					ㄴ 구체적으로 어떻게 변환되는지는 안알아봄.
					ㄴ 'XML-Like js'라 하여 'JSX'라 불린다한다.
						ㄴ html요소들이 나열된 코드가 xml같이 생겼는데, 이런 html요소들을 js에서 작성하여 사용하는 형식이 xml하고 비슷하다해서..
					ㄴ ????? 위에서 아주 간략하게 설명한 JSX와 동일한건지는 잘 모르겠다.
					ㄴ ex)	const name = 'aaa';
						const element = < h1>hello, {name}< /h1>
						ㄴ name이라는 변수를 JSX의 중괄호 안에 넣었다.
						ㄴ JSX의 중괄호 안에는 모든 'js의 표현식'을 넣을 수 있다.
							ㄴ 수식, 함수 등등
					ㄴ jsx자체도 js의 표현식.
					ㄴ 중괄호 뿐만 아니라 큰 따옴표로도 값을 부여할 수 있다. ex)	const element = < div tabIndex="0">< /div>
					ㄴ ????? jsx의 주입공격 방지 )
						ㄴ ????? React DOM은 jsx에 삽입된 값을 렌더링하기 전에 '이스케이프'한다.
					ㄴ 자식 태그를 포함할수있다.
						ㄴ ex)	const element = (
								< div>
									< h1>hello< /h1>
									< h2>good to see you< /h2>
								< /div>
							);
					ㄴ 리액트에서는 JSX를 React.createElement()를 호출해 컴파일한다.
						ㄴ 대략 다음과 같이 생긴 객체를 생성한다.
							const element = {
							  type: 'h1',
							  props: {
								className: 'greeting',
								children: 'Hello, world!'
							  }
							};
							ㄴ 이러한 객체를 'React 엘리먼트'라고 한다.
							ㄴ 리액트는 이러한 객체를 읽어 DOM을 구성 및 최신상태로 유지한다.
				</pre>
				ㅡ 엘리먼트 렌더링 )<button>펼치기</button>
				<pre>
					ㄴ 엘리먼트란?
						ㄴ React의 가장 작은 단위.
						ㄴ ex)	const element = < h2>hello< /h2>; =>element를 리액트의 '엘리먼트'라고 한다.
						ㄴ html의 < h2>hello< /h2>와 같은 브라우저DOM엘리먼트가 아닌 일반 객체(plain object)이다.
						ㄴ 화면에 표시할 내용에 대해 기술하는 단위?
						ㄴ 'React DOM'은 'React 엘리먼트'와 일치하도록 DOM을 업데이트한다.
						ㄴ '컴포넌트'와는 다르다.
					ㄴ 루트 dom 노드?????
					ㄴ 리액트 엘리먼트를 루트dom노드에 렌더링하려면 ReactDOM.render()를 호출하면서 인자로 넘기면 된다.
					ㄴ 리액트 엘리먼트는 '불변객체'이다. 한번 생성한 후에는 자식이나 속성을 변경할수없다.
					ㄴ 리액트 DOM은 해당 엘리먼트와 그 자식엘리먼트를 이전 엘리먼트와 비교하여 DOM을 원하는 상태로 만드는데 있어서 변경이 필요한 부분만 dom을 업데이트한다.
					ㄴ ReactDOM.render(element, container[, callback])
						ㄴ 인자로 전달받은 '리액트 엘리먼트(element인자)'를 실제 DOM(container인자)에 붙여서 렌더링한다.
						ㄴ ex)
							↓ html코드
							< body>
								< div id="root">< /div>
								< div id="root2"> < /div>
							< /body>
							----------------------------------------
							ReactDOM.render(	//root div에 App 리액트 컴포넌트를 붙이고 있다.
								< React.StrictMode>
									< App />
								< /React.StrictMode>,
							  document.getElementById('root')
							);
							ReactDOM.render(//root2 div에 App2 리액트 컴포넌트를 붙이고 있다.
								< React.StrictMode>
									< App2 />
								< /React.StrictMode>,
								document.getElementById('root2')
							);
						ㄴ ?????
						ㄴ 컨테이너 노드 자체를 수정하지 않고, 그 하위 노드들만 수정한다.
					ㄴ ReactDOM.render ( (*리액트 엘리먼트*), (*DOM엘리먼트??*) )를 수행하면 (*DOM엘리먼트*)에 (*리엑트 엘리먼트*)에서 나타내는 내용을 리액트에서 알아서 잘 랜더링을 해주는식인듯함.
					ㄴ 엘리먼트는 변수 안에 저장 가능하다.
					ㄴ < div>hello< /div>와같은 일반 DOM 리액트 엘리먼트도 있지만,
						사용자 정의 컴포넌트와 같이 ( < MyComponent props={props}/> ) Component 리액트 엘리먼트도 있다.
				</pre>
				ㅡ 컴포넌트 )<button>펼치기</button>
				<pre>
					ㄴ js의 함수와 유사하다.
					ㄴ 'props'라는 입력값을 받아 React엘리먼트를 반환한다.
					ㄴ 함수 컴포넌트 )
						ㄴ ex)	function Welcom(props){
								return < h1>hello, {props.name}< /h1>;
							}
						ㄴ 'porps'라는 객체인자를 받아서 리액트 엘리먼트를 반환하므로 유효한 리액트 컴포넌트???
						ㄴ 이 컴포넌트는 js함수이기때문에 '함수 컴포넌트'라고 부른다.
					ㄴ ES6 class를 사용한 컴포넌트 )
						ㄴ ex)	class Welcome extends React.Component {
								render() {
									return < h1>hello, {this.props.name}< /h1>;
								}
							)
						ㄴ ES6 class를 사용하지 않고도 리액트 컴포넌트를 사용할 수 있다.
					ㄴ React는 사용자 정의 컴포넌트가 나오면, JSX의 속성과 자식을 컴포넌트에게 단일 객체로 전달한다. 이 객체를 'props'라고 한다.
					ㄴ React는 props를 전달하면서 해당 컴포넌트를 호출한다.
					ㄴ 컴포넌트에서 리액트 엘리먼트가 반환되고 React는 이를 DOM에 적절히 업데이트한다.
					ㄴ 컴포넌트는 내부에서 다른 컴포넌트를 참조할 수 있다.
						ㄴ ex)
							function App() {
							  return (
								< div>
								  < Welcome name="Sara" />
								  < Welcome name="Cahal" />
								  < Welcome name="Edite" />
								< /div>
							  );
							}
					ㄴ '훅'이 나오기 이전에는 '컨테이너 컴포넌트'(전체 state, 라이프사이클, 로직 담당)로서 클래스형 컴포넌트를 사용하고
						'뷰 컴포넌트?'(화면에 보여지는 부분만 담당)으로 함수형 컴포넌트를 주로 사용했다고 한다.
					ㄴ 컴포넌트는 대문자로시작해야하는듯??
					ㄴ 컴포넌트 추출 )
						ㄴ 컴포넌트를 재사용가능한 요소로서 만들어 적절하게 모듈화?같이 사용해라.
						ㄴ ex)
							function Comment(props) {
							  return (
								< div className="Comment">
								  < div className="UserInfo">
									< img className="Avatar"
										 src={props.author.avatarUrl}
										 alt={props.author.name}
									/>
									< div className="UserInfo-name">
									  {props.author.name}
									< /div>
								  < /div>
								  < div className="Comment-text">
									{props.text}
								  < /div>
								  < div className="Comment-date">
									{formatDate(props.date)}
								  < /div>
								< /div>
							  );
							}
							ㄴ 위와 같이 복잡하게 커다란 컴포넌트를 만들지 말고, 적절하게 여러 컴포넌트들로 나누어서 재사용될수있고 단순하게 만들어라.
					ㄴ props는 변경되어서는 안된다. 읽기만 해야한다.
					ㄴ null반환시 아무것도 랜더링되지 않는다.
				</pre>
				ㅡ State와 lifecycle )<button>펼치기</button>
				<pre>
					ㄴ 틱톡 컴포넌트 예제 )
						ㄴ
						ㄴ 클래스형 리액트 컴포넌트 )
							ㄴ
						class (*이름*)
					ㄴ State 업데이트는 constructor를 제외하고는 this.state를 통해 직접 넣을경우, 리액트는 컴포넌트를 다시 랜더링하지 않는다.
						ㄴ setState()를 사용해야한다.
					ㄴ State 업데이트는 한번에 여러개가 될수있지만 비동기적일 수 있기때문에 각 업데이트가 props, state에 의존해서는 안된다.
					ㄴ State 병합 )
						ㄴ State에 부여한 객체들은 독립적으로 존재한다?
						ㄴ 내부적으로 이 객체들은 State안으로 병합된다.
						ㄴ ex)
						  constructor(props) {
							super(props);
							this.state = {
							  posts: [],
							  comments: []
							};
						  }	=>이렇게 posts, comments라는 객체를 State가 가지고있다하면,
						componentDidMount() {
							fetchPosts().then(response => {
							  this.setState({
								posts: response.posts		=>State안의 comments에는 전혀 영향이없다.
							  });
							});

							fetchComments().then(response => {
							  this.setState({
								comments: response.comments
							  });
							});
						  }	=>이런식으로 따로따로 setState()를 하여도 State안에있는 다른객체에 영향을 주지않는다. 그리고 병합된다.
					ㄴ 컴포넌트 내부의 자식 컴포넌트에게 State를 인자로 넘겨줄수있다. 위로는 안된다 (하향식 데이터 흐름)
						ㄴ 자식은 이게 state인지 다른것인지 전혀모른다.
					ㄴ setState()
						ㄴ state에 대해 수정요청을하고 리액트에게 바뀐값에 맞게 다시 랜더링 되어야한다고 알린다.
						ㄴ 즉각ㅈ적으로 수행되지 않는다. setState()는 요청을 넣기만하고 리액트에서 이후에 다시 랜더링하는 방식.
						ㄴ 얕은 update만 수행한다.
							ㄴ 무슨말이냐하면,
								this.state = {
									id : 1,
									list : { num : 2, sum : 10 }
								}
								위와같이 state내부에 또다른 객체가있으면 setState()시, list의 내부값까지 수정할수 없다. setState()로 list를 수정할 경우, 그 수정하는 값으로 완전히 대체된다.
						ㄴ 프로퍼티부분에 '계산된 속성명(computed property name)'을 사용할수있다.
					ㄴ 실무적인 팁 )
						ㄴ 컴포넌트 내의 어떤 값이 props나 state로부터 계산될수있는값이면 굳이 그 값을 props나 state로 만들어두지 말라고한다. 최소한의 props, state만 남겨두고 이것들로부터 계산할수있는것들은 render()안에서 props,state로부터 계산하여 사용하라고 한다.
				</pre>
				ㅡ 이벤트 처리 )<button>펼치기</button>
				<pre>
					ㄴ ex)
						< button onClick={activateLasers}>
						  Activate Lasers
						< /button>
						ㄴ 리액트에서는 이베트처리시, 문자열이 아닌 JSX를 이용해 함수를 값으로 전달한다.
					ㄴ 리스너함수에서 false를 반환하더라도 이벤트 기본동작을 막을수없다. 명시적으로 priventDefault()를 호출해야한다.
					ㄴ 리스너 함수 정의시 인자로 'SyntheticEvent'를 받을 수있다.
					ㄴ 클래스형 컴포넌트 사용시 일반적인 리액트의 이벤트 처리 방식은, 이벤트 핸들러를 컴포넌트의 메소드로 만드는것이다.
					ㄴ ?????onClick={(*함수*)}에서 (*함수*)부분에 함수명과같은 식별자를 전달하지 않고 '함수명()'과 같은형식으로 함수를 실행하면 무한루프에 빠진다고한다.
					ㄴ 이벤트 인자 전달하기 )
						ㄴ < button onClick={(e) => this.deleteRow(id, e)}>Delete Row< /button>
							ㄴ 화살표함수를 사용하여 인자전달. 이벤트인자(e)를 명시적으로 전달해주어야한다.
						ㄴ < button onClick={this.deleteRow.bind(this, id)}>Delete Row< /button>
							ㄴ Funtion.prototype.bind()를 이용하여 인자전달. 이벤트인자(e)가 자동으로 전달된다고 한다.
				</pre>
				ㅡ 조건부 랜더링 )<button>펼치기</button>
				<pre>
					ㄴ js의 if문과 같은 조건부연산자를 이용하여 조건부 랜더링이 가능하다.
					ㄴ ex)
						function Greeting(props) {
						  const isLoggedIn = props.isLoggedIn;
						  if (isLoggedIn) {
							return < UserGreeting />;
						  }
						  return < GuestGreeting />;
						}

						ReactDOM.render(
						  // Try changing to isLoggedIn={true}:
						  < Greeting isLoggedIn={false} />,
						  document.getElementById('root')
						);
					* js 논리연산자 &&, ||
						ㄴ expr1 && expr2 : expr1이 true인경우 expr2반환. 아니면 expr1반환.
						ㄴ expr1 || expr2 : expr1이 true인경우 expr1반환. 아니면 expr2반환.
						ㄴ !expr : expr이 true이면 false반환. 아니면 true.
					ㄴ 논리연산자 &&, || 또는 삼항 논리연산자 () ? () :() 도 사용가능하다.
				</pre>
				ㅡ 리스트와 key )<button>펼치기</button>
				<pre>
					* js 의 Array의 map()
						ㅡ ex)	array1.map( x => x*2 );
						ㅡ 배열 안의 각 요소에 대해 map()안에정의된 콜백함수를 수행하여 새로운 배열을 반환한다.
					ㄴ 리액트에서 여러개의 컴포넌트를 렌더링하는 방법은 js의 map()이용하는것과 비슷하다.
						ㄴ ex)
							const numbers = [1, 2, 3, 4, 5];
							const listItems = numbers.map((number) =>
							  < li>{number}< /li>
							);
							ReactDOM.render(
							  < ul>{listItems}< /ul>,
							  document.getElementById('root')
							);
							ㄴ listItems에는 엘리먼트배열이 저장된다.
							ㄴ 그리고 이걸 < ul>안에 랜더링하면된다.
					ㄴ  일반적으로는 컴포넌트 안에서 엘리먼트 리스트를 만드는식으로 개발한다고함.
						ㄴ ex)
							function NumberList(props) {
							  const numbers = props.numbers;
							  const listItems = numbers.map((number) =>
								< li key={number.toString()}>
								  {number}
								< /li>
							  );
							  return (
								< ul>{listItems}< /ul>
							  );
							}
					ㄴ 리액트에선 리스트 엘리먼트 등에 대해 '키'값을 부여해주어야 한다.
						ㄴ 항목들에 대해 변경,추가,삭제하는걸 돕는다.
						ㄴ 해당 항목을 고유하게 실별할수있는 문자열을 사용해야한다.
							ㄴ 보통 데이터의 id를 사용한다.
							ㄴ 아니면 최후의 수단으로 항목의 인덱스를 key로 사용한다.
								ㄴ 항목의 순서가 바뀔수있으므로 권장하지않는다함.
						ㄴ ?????키값은 반복되는 각 항목에 지정하는게 아닌, 배열부분에 지정해주어야한다??
							ㄴ map()함수 안에있는 엘리먼트에 지정해주는게 일반적으로 좋다함
							ㄴ ex)
								const listItems = numbers.map((number) =>
									// 맞습니다! 배열 안에 key를 지정해야 합니다.
									< ListItem key={number.toString()} value={number} />
								  );
											ㄴ 키값은 형제 사이에서만 고유하면된다.
											ㄴ 키값은 컴포넌트 내부로 전달되지 않는다. key의 값이 필요하면 동일한 값의 다른 속성을 선언하여 넘겨주어야한다.
												ㄴ ex)
								const content = posts.map((post) =>
								  < Post
										  key={post.id}
										  id={post.id}
										  title={post.title} />
								);
								ㄴ key는 컴포넌트 내부에서 사용할수없다. 전달되지 않는다.
								ㄴ kdy와 같은값이 필요하면 id라는 이름의 다른 props를 선언하여 넘겨주어야한다.
				</pre>
				ㅡ <a name="React_기본개념_form">form</a> )<button>펼치기</button>
				<pre>
					ㄴ html의 < input>, < textarea>, < select>등은 고유의 상태값을 가지고, 이는 사용자의 입력값에따라 변경된다.
					ㄴ 리액트에서는 state가 존재하고 이는 setState()에 의해서 변경된다.
					ㄴ 리액트의 state를 'single source of truth'로 만들어 위의 두 요소를 결합할 수 있다고 한다.
						ㄴ 이를 통해 리액트 컴포넌트에서 form에서 발생하는 사용자 입력값을 제어할 수 있다고 한다.
						ㄴ 이러한 폼 엘리먼트르 ㄹ'제어 컴포넌트'라고 한다.
					ㄴ ex)
						class NameForm extends React.Component {
						  constructor(props) {
							super(props);
							this.state = {value: ''};

							this.handleChange = this.handleChange.bind(this);
							this.handleSubmit = this.handleSubmit.bind(this);
						  }

						  handleChange(event) {
							this.setState({value: event.target.value});
						  }

						  handleSubmit(event) {
							alert('A name was submitted: ' + this.state.value);
							event.preventDefault();
						  }

						  render() {
							return (
							  < form onSubmit={this.handleSubmit}>
								< label>
								  Name:
								  < input type="text" value={this.state.value} onChange={this.handleChange} />	=>value값이 항상 컴포넌트의 state.value가 된다. 그리고 input에 값을 입력할때마다 handleChange가 호출되어 입력된 값을 컴포넌트의 state.value에 업데이트하므로, input의 value값은 항상 현재 바로 그순간에 입력되어있는값이 되며, 이를 통해 컴포넌트에서 이값을 처리하거나 다른컴포넌트로 넘길수도있다.
								< /label>
								< input type="submit" value="Submit" />
							  < /form>
							);
						  }
						}
					ㄴ < textarea >의 폼제어의 경우)
						ㄴ html의 < textarea > 는 바로 아래있는 자식text dom을 내용으로 가진다.
						ㄴ 리액트에서는 자식text dom이 아닌 < textarea >의 value속성값을 주어 form과 똑같이 컨트롤한다.
							ㄴ ex)
								render() {
									return (
									  < form onSubmit={this.handleSubmit}>
										< label>
										  Essay:
										  < textarea value={this.state.value} onChange={this.handleChange} />
										< /label>
										< input type="submit" value="Submit" />
									  < /form>
									);
								  }
					ㄴ < select>의 폼제어의 경우 )
						ㄴ 아는 select와 동일...
						ㄴ 리액트에서는 < select value={this.state.id}>와 같이 < select>안에 value속성을 가질수있다.
					ㄴ file input )
						ㄴ < input type="file">은 사용자만 값을 입력할수있는 읽기전용이기때문에 '비제어 컴포넌트'이다.
						ㄴ '고급 안내서'의 '비제어 컴포넌트'에서 더 자세하게 나온다.
					ㄴ 모든 폼의 값에 대하여 이벤트처리로 리액트의 state에 값을 반영하는식으로 입력값을 제어하는게(즉, 제어컴포넌트 사용) 너무반복작업일경우 '비제어 컴포넌트'가 대체기술이 될수있다고한다.
					ㄴ Formik : 가장 대중적인 리액트 form 라이브러리. 유효성검사, 방문한 필드추적, 제출처리 등 다양한 기능 제공.
						ㄴ '제어 컴포넌트'와 state관리를 원리로 만들어졌다고 한다.
				</pre>
				ㅡ 컴포넌트간 state전달. state끌어올리기 )<button>펼치기</button>
				<pre>
					ㄴ 컴포넌트간 데이터를 전달하는게 필요할때 사용할수있는 방법을 소개한다.
					ㄴ 부모,자식 관계의 컴포넌트간 데이터 전달 방법 )
						ㄴ 부모 컴포넌트에서 자식컴포넌트로 props를 전달할때, 부모 컴포넌트의 state와 그 state를 변경할수있는 메소드를 같이 넘겨준다.
						ㄴ 자식 컴포넌트에서는 원래props을 수정할수없지만, 같이넘겨받은 메소드를 호출하여 부모컴포넌트의 state를 변경할수있다.
					ㄴ 이런식의 하향식 데이터 흐름으로 컴포넌트간 데이터를 주고받음으로서 버그를 더 찾기쉽다고한다.
				</pre>
				ㅡ 합성, 상속 )<button>펼치기</button>
				<pre>
					ㄴ 합성 )
						ㄴ 리액트에서 합성이란, 한 컴포넌트에서 여러컴포넌트들을 사용하여 컴포넌트를 구성하는것.
							ㄴ 그냥 render안에서 다른 컴포넌트 가져와 사용하는걸말함.
							ㄴ ex)
								function App() {
								  return (
									< SplitPane
											left={
										< Contacts />
									  }
									  right={
										< Chat />
									  } />
								  );
								}
						ㄴ 다른 컴포넌트를 props로 받을수도있다고 한다.
					ㄴ 상속 )
						ㄴ extends를 사용하여 컴포넌트를 만드는 방식.
						ㄴ 공식문서에서는 추천하지 않는다고한다.
							ㄴ 합성을 사용하는것만으로도 충분히 대부분의 기능구현이 가능하고
							ㄴ 합성이 더 유연하고 안전하다.
							ㄴ ui부분이 아닌 js함수와 같은 로직을 재사용하기를 바란다면, 이건 상속할필요없이 js파일을 따로만들고 import하는 방식으로도 가능하다.
				</pre>
				ㅡ 리액트 간단 실습 )<button>펼치기</button>
				<pre>
					ㄴ 먼저 컴포넌트 구성을 설계한다 )
						ㄴ 전체컴포넌트를 어떻게 구성할건지, 아마 계층형으로 구성하게될거고, 컴포넌트마다 이름을 붙이고, 그런단계
						ㄴ 컴포넌트 결정에 있어서 하나의 원칙은 '단일책임원칙'이다. 하나의 컴포넌트는 하나의 책임만 맡아야한다.
							ㄴ 마치 html페이지에서 div로 페이지 부분부분을 세분화하듯이 컴포넌트를 나누는 느낌이다.
					ㄴ '정적인' 버전을 만든다 )
						ㄴ 데이터를 가져와 뿌려주고, 전체 페이지가 렌더링되어 완전하게 나오기는 하되, 동적인 동작이 없는 것부터 만드는것.
							ㄴ 동적인 부분이 없기때문에 state는 사용하지 않는다함. state는 동적인 상호작용에 쓰이는거라함.
							ㄴ props를 통해 데이터를 전달하며 정적버전을 만들게됨.
						ㄴ '상향식'과 '하향식' 방식 )
							ㄴ 하위 계층의 컴포넌트부터 만들어가는게 상향식. 상위의 전체 컴포넌트부터 만드는게 하향식.
							ㄴ 간단한거면 하향식이 좋지만 크고 복잡한 프로젝트는 상향식으로 테스트를 해가며 개발하는게 좋다함.
					ㄴ 최소한의 state 찾기 )
						ㄴ 동적인 부분을 만들기 위해 state를 사용할건데, 이때 필요로하는 state의 최소집합을 찾아야 한다.
						ㄴ '중복배제'의 원칙을 생각하며 찾는다.
						ㄴ 최소한의 state를 찾고 나머지는 이 state들로 계산이나 로직을 통해 사용하도록 하라.
						ㄴ 또한 props에 있는 값이면 제외시켜라.
					ㄴ state를 가지는 컴포넌트 결정 )
						ㄴ 동적인 부분을 위해 필요한 최소한의 state값들을 어떤 컴포넌트가 가져야 하는가를 결정.
						ㄴ 참고사항 )
							ㄴ 그 state를 가지고 렌더링을 하는 모던 컴포넌트를 찾는다.
							ㄴ 이 컴포넌트들의 공통 조상컴포넌트인 '공통 소유 컴포넌트'를 찾는다.
							ㄴ 공통 조상일수록 그 state를 가지는게 좋다.
					ㄴ 역방향 데이터흐름 추가 )
						ㄴ 위에서 배운 'state 끌어올리기'를 통해 역방향 데이터 흐름을 필요시에 만든다.
				</pre>
				ㅡ 리액트 어플리케이션 구조 )<button>펼치기</button>
				<pre>
					ㄴ 크게 node_modules, public, src로 이루어짐.
						ㄴ 개발은 주로 src/App.js와 src아래에 하위폴더를 만들어 이 안에 Component별 js파일을 생성하며 진행된다.
					ㄴ src/index.js : App의 엔트리 포인트. 루트 컴포넌트를 DOM에 마운팅하는 역할.
				</pre>

			</pre>
			ㅇ 고급 안내서<button>더보기</button>
			<pre>
				ㅇ 접근성<button>더보기</button>
				<pre>
					ㅡ ????? 무슨 신체적 장애를 가진 사람들도 웹페이지에 쉽게 접근할수있도록 해야한다???

				</pre>
				ㅇ 코드분할<button>더보기</button>
				<pre>
					ㅡ ~~~~~
					ㅡ 웹팩, 번들 사용과 관련하여 번들이 너무 커지지 않도록 동적? 지연로딩? 같이 사용하는 방법 등을 통해
						'코드 분할'을 하는 방법을 설명하는듯하다.

				</pre>
				ㅇ Context <button>더보기</button>
				<pre>
					ㅡ 간단하게 리액트 컴포넌트 사이의 전역변수같은 느낌의 데이터를 사용하게 해주는것.
					ㅡ 간단 사용법 )
						ㄴ ex)
							const ThemeContext = React.createContext('light');	//context생성
							~~~
							< ThemeContext.Provider value="dark">
								< Toolbar />
							< /ThemeContext.Provider>	//이런식으로 context로 컴포넌트를 감싸주면, 해당 컴포넌트와
														그 하위에 있는 컴포넌트에서 context에 접근할수있다.
							< Toolbar>하위의 컴포넌트에서 context를 사용하려면,
							static contextType = ThemeContext; //contextType으로 context를 지정.
							render() {
								return < Button theme={this.context} />; //context값 사용. 위에서 지정한 'dark'값이 적용.
							}
					ㅡ api )
						ㄴ React.createContext( (*디폴트context값*) )
							ㄴ ex) const MyContext = React.createContext(defaultValue);
							ㄴ context객체 생성.
							ㄴ context의 범위 안에있는 컴포넌트를 랜더링할때 리액트는 부모쪽으로 가장 가까운 'Provider'를 찾아
								그 값을 읽어들인다.
							ㄴ (*디폴트context값*) : 적절한 Provider를 찾지 못했을때 사용되는값.
						ㄴ < (*context객체*).Provider value = { (*값*) } />
							ㄴ context객체 안의 Provider 컴포넌트를 이용해, 하위의 context범위 안의 컴포넌트들에게 context값의
								변화를 알린다.
								ㄴ context값을 찾을때 부모쪽으로 가장 가까운 Provider를 찾아 그 값을 사용한다했으므로,
									이 아래의 컴포넌트들에는 Provider가 제공한 (*값*)이 context에 사용되는것.
							ㄴ context의 범위 아래의 컴포넌트들은 (*값*)이 바뀔때마다 랜더링된다.
							ㄴ ????? Provider로부터 하위 consumer(.contextType와 useContext을 포함한)로의 전파는
								shouldComponentUpdate 메서드가 적용되지 않으므로, 상위 컴포넌트가 업데이트를 건너 뛰더라도
								consumer가 업데이트됩니다.
							ㄴ ?????내부적으로 context값이 변경되었는지 아닌지의 기준은 js의 Object.is()의 메커니즘과 동일하다고 한다.
						ㄴ (*컴포넌트 클래스*).contextType
							ㄴ 컴포너트 클래스의 contextType 프로퍼티에 context객체를 주어서 해당 클래스 안에서 context를 사용하도록
								할 수있다.
							ㄴ ex)	class MyClass extends React.Component {
									  componentDidMount() {
										let value = this.context;
										/* MyContext의 값을 이용한 코드 */
									  }
									  componentDidUpdate() {
										let value = this.context;
										/* ... */
									  }
									  componentWillUnmount() {
										let value = this.context;
										/* ... */
									  }
									  render() {
										let value = this.context;
										/* ... */
									  }
									}
									MyClass.contextType = MyContext;
							ㄴ context 값을 찾는 방식은 동일하다.
						ㄴ  Context.Consumer
							ㄴ ex)	< MyContext.Consumer>
									  {value => /* render something based on the context value */}
									< /MyContext.Consumer>
							ㄴ context객체의 컴포넌트 Consumer. 위와같이 Consumer컴포넌트 내부에 함수를 정의하면 이 함수의
								인자로 context값이 넘어간다.
							ㄴ 함수형 컴포넌트 안에서 context를 사용하는데에 쓰인다.
							ㄴ context의 값을 찾는 방법은 동일하다.
						ㄴ ????? Context.displayName
					ㅡ 단점 )
						ㄴ 컴포넌트 재사용성이 어려워지므로 주의해서 사용.
							ㄴ context보다 컴포넌트 '합성'이 더 좋을수도있다.
					ㅡ 여러 context값을 사용하는 경우 )
						ㄴ ?????'render props 컴포넌트'를 사용하라고 한다.
					ㅡ 주의사항 ?????
					ㅡ 실무 )
						ㄴ Provider의 value를 컴포넌트의 state값을 주어서 state가 변화할때마다 context를 사용하는 하위의
							컴포넌트들이 다시 랜더링되는식으로 사용.
						ㄴ 아주 깊숙히 있는 컴포넌트에서 context의 값을 변경하려면, props로 함수를 넘겨 자식컴포넌트가 상위 컴포넌트의
							state값을 변경시켜주듯이, context의 값에 함수를 넘겨주고, 그 함수에서 context값을 변경시켜주면된다.
				</pre>
				ㅇ 에러 경계 <button>더보기</button>
				<pre>
					ㅡ 개요 )
						ㄴ 에러 경계란? 렌더링 과정에서 발생하는 하위 컴포넌트에서 발생하는 에러를 주시하고있다가 발생시, 에러로 인해
							깨진 컴포넌트 대신 폴백ui를 보여주는 React 컴포넌트이다.
					ㅡ 기본 사용법 )
						ㄴ ex) 	class ErrorBoundary extends React.Component {
								  constructor(props) {
									super(props);
									this.state = { hasError: false };
								  }

								  static getDerivedStateFromError(error) {
									// 다음 렌더링에서 폴백 UI가 보이도록 상태를 업데이트 합니다.
									return { hasError: true };
								  }

								  componentDidCatch(error, errorInfo) {
									// 에러 리포팅 서비스에 에러를 기록할 수도 있습니다.
									logErrorToMyService(error, errorInfo);
								  }

								  render() {
									if (this.state.hasError) { //에러가 발생하여 hasErorr값이 true일경우 대체ui를 렌더링할수있도록.
									  // 폴백 UI를 커스텀하여 렌더링할 수 있습니다.
									  return < h1>Something went wrong.< /h1>;
									}

									return this.props.children;
								  }
								}
								~~~~~
								에러 경계 사용시,
								< ErrorBoundary>
								  < MyWidget />
								< /ErrorBoundary>	//이런식으로 에러를 확인하려는 대상 컴포넌트를 에러경계로 감싸주면 된다.
						ㄴ getDerivedStateFromError()나 componentDidCatch()를 사용하여 하위의 컴포넌트에서 발생한 에러를 받아
							처리를 할 수 있다.
							ㄴ getDerivedStateFromError( error )
								ㄴ 생명주기 메소드.
								ㄴ 하위의 컴포넌트에서 에러 발생시 호출된다.
								ㄴ 매개변수로 에러를 받는다.
								ㄴ 갱신된 state값을 반드시 반환해야 한다.
								ㄴ ?????랜더링 단계에서 호출되므로 부수효과를 발생시켜서는 안된다.
							ㄴ componentDidCatch( error, info )
								ㄴ 생명주기 메소드.
								ㄴ 하위 컴포넌트에서 에러 발생시 호출된다.
								ㄴ 매개변수로 에러와 어떤 컴포넌트가 에러를 발생시켰는지에 대한 정보 등이 담긴 객체를 받는다.
								ㄴ ????? 커밋단계에서 호출되므로 getDerivedStateFromError()와 다르게 부수효과를 발생시켜도 된다.
					ㅡ 다음과 같은 에러는 포착하지 않는다.
						ㄴ 이벤트 핸들러의 에러
							ㄴ 이벤트 핸들러 내에서 에러를 잡아야 할경우 js의 try-catch문을 사용하라.
						ㄴ 비동기적 코드의 에러
						ㄴ 서버 사이드 렌더링
						ㄴ 에러 경계 자체에서 발생한 에러.
					ㅡ 클래스형 컴포넌트만이 에러경계가 될 수 있다.
					ㅡ React 16부터는 에러 경계에 포착되지 않은 에러 발생시, 전체 React컴포넌트의 마운트가 해제된다.
						ㄴ 문제가있는 컴포넌트를 그래도 렌더링하는것보다는 아예 안나오게하는게 더 낫다고 판단했기때문이라함.
				</pre>
				ㅇ Ref와 DOM <button>더보기</button>
				<pre>
					ㅡ 개요 )
						ㄴ Ref라는것을 하위 컴포넌트에게 전달하는 기술을 말함.
						ㄴ 대부분의 컴포넌트에서는 사용할일이 없지만, 재사용 라이브러리와 같은 일부 컴포넌트에서 유용하게 사용된다.
						ㄴ ~~~~~
					ㅡ 기본 사용법 )<button>펼치기</button>
                    <pre>
						ㄴ ex)	class CustomTextInput extends React.Component {
								  constructor(props) {
									super(props);
									// textInput DOM 엘리먼트를 저장하기 위한 ref를 생성합니다.
									this.textInput = React.createRef();	//React.createRef()를 통해 Ref생성.
									this.focusTextInput = this.focusTextInput.bind(this);
								  }

								  focusTextInput() {
									// DOM API를 사용하여 명시적으로 text 타입의 input 엘리먼트를 포커스합니다.
									// 주의: 우리는 지금 DOM 노드를 얻기 위해 "current" 프로퍼티에 접근하고 있습니다.
									this.textInput.current.focus();	//current속성에 < input>이 담겨있고, 이 input에 focus설정을해주고있다.
								  }

								  render() {
									// React에게 우리가 text 타입의 input 엘리먼트를
									// 우리가 생성자에서 생성한 `textInput` ref와 연결하고 싶다고 이야기합니다.
									return (
									  < div>
										< input
												type="text"
												//생성한 Ref가 들어있는 textInput을 DOM에 ref속성값으로 넘김.
												//그러면 textInput에 들어있는 Ref의 current속성에 이 input DOM이 담긴다.
												//그러면 이 ref값을 현재 컴포넌트CustomTextInput에서 사용가능하다.
												ref={this.textInput} />
										< input
												type="button"
												value="Focus the text input"
												onClick={this.focusTextInput}
										/>
									  < /div>
									);
								  }
								}
						ㄴ html DOM에 ref속성을 주었다면 Ref의 current에는 그 DOM엘리먼트가 들어가고, 컴포넌트에 ref속성을 주었다면
							컴포넌트의 인스턴스가 Ref의 current에 들어간다.
						ㄴ 함수 컴포넌트는 인스턴스가 없기때문에 컴포넌트에 ref속성을 부여하여 current로 받아올 수 없다.
							ㄴ ex)  < MyFunctionComponent ref={this.textInput} />와 같이 MyFUnctionComponent 컴포넌트가 함수형
									컴포넌트라면 ref사용 못함.
							ㄴ 함수형 컴포넌트 안에서 Ref를 정의하고 그 하위 컴포넌트 등으로 ref속성을 넘기는 등, Ref를 사용하는건 된다.
								함수형 컴포넌트를 Ref로 참조하는게 안되는것.
							ㄴ 사용하려면 forwardRef(), useImperativeHandle()을 사용하라함.
						ㄴ 이 Ref의 current를 이용해 이안에 들은 엘리먼트나 인스턴스를 직접 조작할 수 있다.
					</pre>
					ㅡ 컴포넌트 마운트시, current에 요소가 들어오며, 마운트 해제시, current가 null로 세팅된다.
					ㅡ 부모 컴포넌트에게 DOM ref 공개하기 )
						ㄴ ?????
						ㄴ 다음챕처에 나오는 'Ref 전달하기' 방법이 권장된다함.
					ㅡ 콜백 ref )
						ㄴ Ref를 설정하는 방법 중 하나. (위에서는 React.createRef()를 사용)
						ㄴ 참조하려는 컴포넌트 또는 DOM요소에 ref속성값으로 Ref가 아닌 콜백 함수를 넘겨준다. 이 콜백함수는 리액트에 의해
							인자로 해당 컴포넌트 인스턴스나 DOM요소를 전달받는다.
							ㄴ 더 정확하게는 마운트시, 해당 컴포넌트나 DOM요소와 함께 콜백함수가 호출되고, 마운트해제시 null과함께
								콜백함수가 호출된다.
						ㄴ ref 콜백은 componentDidMount(), componentDidUpdate()이전에 호출된다.
						ㄴ ref 사용시 주의사항 )
							ㄴ 마운트 해제시 null과함께 호출되고 마운트시 해당 컴포넌트나 DOM요소화 함께 호출된다고 하였으므로,
								컴포넌트 업데이트시, null로 함번 호출되고 해당 컴포넌트나 DOM요소화 함께 호출되어 두번 호출됨을 기억.
						ㄴ ex)	class CustomTextInput extends React.Component {
								  constructor(props) {
									super(props);

									this.textInput = null;

									this.setTextInputRef = element => {
									  this.textInput = element;
									};

									this.focusTextInput = () => {
									  // DOM API를 사용하여 text 타입의 input 엘리먼트를 포커스합니다.
									  if (this.textInput) this.textInput.focus();
									};
								  }

								  componentDidMount() {
									// 마운트 되었을 때 자동으로 text 타입의 input 엘리먼트를 포커스합니다.
									this.focusTextInput();
								  }

								  render() {
									// text 타입의 input 엘리먼트의 참조를 인스턴스의 프로퍼티
									// (예를 들어`this.textInput`)에 저장하기 위해 `ref` 콜백을 사용합니다.
									return (
									  < div>
										< input
												type="text"
												ref={this.setTextInputRef}
										/>
										< input
												type="button"
												value="Focus the text input"
												onClick={this.focusTextInput}
										/>
									  < /div>
									);
								  }
								}
					ㅡ 문자열 ref : 문자열을 이용해 ref를 사용하는 방법인데 없어질예정이라함.


				</pre>
				ㅇ Ref 전달 <button>더보기</button>
				<pre>
					ㅡ 말 그대로 ref를 다른곳으로 전달하는 방법에 대해 배운다.
					ㅡ 말단 컴포넌트인 버튼이나, input컴포넌트 등에서 이것들을 계속 재사용하게될때 이 컴포넌트(또는 요소)들에 대한 ref값이 상위에서 필요할 때가 있다.
						이때 ref전달하기가 유용하게 쓰인다고한다.
					ㅡ ????? 이해못함.
					ㅡ 기본 사용법 )
						ㄴ ex)	//2. FancyButton컴포넌트에서 React.forwardRef()메소드를 통해 ref를 전달하고있다. ref인자에 상위로부터 받은 ref가 넘겨진다.
								const FancyButton = React.forwardRef((props, ref) => (
								//3. 함수 내부에서 컴포넌트나 DOM요소에 상위컴포넌트에서와 같이 ref속성을 주고 값으로 인자로받은 ref를 넘겨주면 'ref전달하기'가 된다.
								//이제 상위 컴포넌트에서 ref.current사용시, FancyButton컴포넌트가 아닌 < button>요소가 나온다.
								  < button ref={ref} className="FancyButton">
									{props.children}
								  < /button>
								));

								// You can now get a ref directly to the DOM button:
								const ref = React.createRef();
								//1. ref사용을 위해 < FancyButton>컴포넌트에 ref속성에 Ref객체를 넘겨준다. 이것만있다고보면 여기까지는 이전 챕터에서
								//배운것처럼 일반적인 ref사용법이다. ref.current에는 FancyBUtton 컴포넌트가 들어있다.
								< FancyButton ref={ref}>Click me!< /FancyButton>;
							ㄴ 즉, 일반적인 Ref사용하는것과 비슷한데, React.forwardRef()를 통해 Ref객체를 한단계 더 아래로 전달함으로서
								더 아래단계에 있는 DOM요소(또는 컴포넌트)를 Ref의 참조값으로 넣을수있는것.
					ㅡ ????? Note for component library maintainers
						ㄴ ?????


				</pre>
				ㅇ Fragment<button>더보기</button>
				<pre>
					ㅡ 컴포넌트가 여러 엘리먼트를 반환하게 해주는 기능.
						ㄴ 일반적으로 컴포넌트는 하나의 엘리먼트(여러개일경우 하나의 엘리먼트로 묶어서)반환해야한다.
						ㄴ 그러나 여러 엘리먼트를 반환해야하는 경우는 많으며 이때 사용되는 기능이다.
							ㄴ ex)
								render() {
								return (
								  < table>
									< tr>
									  < Columns />
									< /tr>
					    	 	  < /table>
								);
							  }
								ㄴ 이 경우 Column컴포넌트는 여러개의 < td>를 반환해야 한다.
					ㅡ 사용법 )
						ㄴ < React.Fragment>로 감싸거나, (빈 태그와 유사한) < >, < />로 감싸주어 반환하면 된다.
						ㄴ ex)
							render() {
								return (
								  < React.Fragment>
									< td>Hello< /td>
									< td>World< /td>
								  < /React.Fragment>
								);
							  }
						ㄴ ex)
							render() {
								return (
								  <>
									< td>Hello< /td>
									< td>World< /td>
								  < />
								);
							  }
					ㅡ Fragment의 key
						ㄴ 반환하는 여러 요소들이 key를 가져야 한다면, < React.Fragment>를 이용해야한다.
						ㄴ ex)
							return (
								< dl>
								  {props.items.map(item => (
									// React는 `key`가 없으면 key warning을 발생합니다.
									< React.Fragment key={item.id}>
									  < dt>{item.term}< /dt>
									  < dd>{item.description}< /dd>
									< /React.Fragment>
								  ))}
								< /dl>
							  );
                    ㅡ 배열로 반환 )
                        ㄴ 배열형태로 엘리먼트를 반환할 수도 있다.
                        ㄴ ex)
                            render() {
                              // No need to wrap list items in an extra element!
                              return [
                                // Don't forget the keys :)
                                    < li key="A">First item< /li>,
                                    < li key="B">Second item< /li>,
                                    < li key="C">Third item< /li>,
                              ];
                            }
				</pre>
				ㅇ Higher-Order Components, HOC<button>더보기</button>
				<pre>
					ㅡ 개요 )
						ㄴ 컴포넌트를 받아서 새로운 컴포넌트를 반환하는 함수를 말한다.
							ㄴ ex) const EnhancedComponent = higherOrderComponent(WrappedComponent);
							ㄴ React의 API가 아닌, 패턴이다.
								ㄴ 그냥 일반적인 함수이다. 함수가 어떤 컴포넌트를 받아서 다른 컴포넌트를 반환하도록 함수를 정의한 것뿐이다.
						ㄴ third-party 리액트 라이브러리에서 자주 사용된다. ex) Redux의 connect, Relay의 createFragmentContainer 등
					ㅡ 기본 사용법 )
						ㄴ ex)
							HOC의 사용.
							const CommentListWithSubscription = withSubscription(	//withSubscription()이 HOC 함수.
																					인자로 컴포넌트와 화살표함수를 넘기고있다.
							  CommentList,
							  (DataSource) => DataSource.getComments()
							);

							const BlogPostWithSubscription = withSubscription(
							  BlogPost,
							  (DataSource, props) => DataSource.getBlogPost(props.id)
							);

							HOC 정의
							// This function takes a component...
							function withSubscription(WrappedComponent, selectData) {	//함수의 인자로 컴포넌트를 받고 원하는 형식의 데이터를 받는다.
							  // ...and returns another component...
							  return class extends React.Component {	//container 컴포넌트를 반환.
								constructor(props) {
								  super(props);
								  this.handleChange = this.handleChange.bind(this);
								  this.state = {
									data: selectData(DataSource, props)	//넘어온 인자로 함수를 호출하여 state에 데이터 저장.
								  };
								}

								componentDidMount() {
								  // ... that takes care of the subscription...
								  DataSource.addChangeListener(this.handleChange);
								}

								componentWillUnmount() {
								  DataSource.removeChangeListener(this.handleChange);
								}

								handleChange() {
								  this.setState({
									data: selectData(DataSource, this.props)
								  });
								}

								render() {
								  // ... and renders the wrapped component with the fresh data!
								  // Notice that we pass through any additional props
								  return < WrappedComponent data={this.state.data} {...this.props} />;
																				//인자로 넘어온 WrappedComponent를 랜더링.
																				props로 필요한 데이터들을 넘겨줌.
								}
							  };
							}
					ㅡ 입력받은 컴포넌트를 수정해서는 안된다.
						ㄴ ex)
							//다음은 InputComponent을 수정하고 반환하는HOC이다.
							function logProps(InputComponent) {
							  InputComponent.prototype.componentDidUpdate = function(prevProps) {
								console.log('Current props: ', this.props);
								console.log('Previous props: ', prevProps);
							  };
							  // 원본의 입력을 반환한다는 것은 이미 변형되었다는 점을 시사합니다.
							  return InputComponent;
							}

							// EnhancedComponent 는 props를 받을 때 마다 log를 남깁니다.
							const EnhancedComponent = logProps(InputComponent);
						ㄴ ex)
							//위 예제와 같이 입력컴포넌트를 수정하는게 아니라, 새컴포넌트로 감싸서 반환함으로서 똑같은 기능을 구현할 수 있다.
							function logProps(WrappedComponent) {
							  return class extends React.Component {
								componentDidUpdate(prevProps) {
								  console.log('Current props: ', this.props);
								  console.log('Previous props: ', prevProps);
								}
								render() {
								  // 들어온 component를 변경하지 않는 container입니다. 좋아요!
								  return < WrappedComponent {...this.props} />;
								}
							  }
							}
					ㅡ ????? 래핑된 컴포넌트를 통해 관련없는 prop전달하기.
					ㅡ ????? 잘모르겠다. 번역본이 이해가 안간다.
				</pre>
				ㅇ 다른 라이브러리와 통합하기<button>더보기</button>
				<pre>
					ㅡ 리액트를 다른 어플리케이션에 포함시키거나 리액트 안에 다른 어플리케이션을 포함시킬 수 있다.
					ㅡ DOM 조작 플러그인과 통합하기 )
						ㄴ 리액트는 그 내부적인 데이터에 기반하여 업데이트를 하므로, 리액트 외부에서 DOM에 적용된 변화들은 알지 못하고, 충돌의 가능성이 있다.
						ㄴ 해서 이렇게 다른 곳에서 접근하는 DOM에 대한 충돌을 막기위해, 리액트에서 비어있는 < div/>를 반환하는 방법이 있다.
							ㄴ 비어있는 < div/>반환시 리액트엘리먼트가 아무것도 변화될게 없으므로 리액트는 이를 업데이트하지 않고, 따라서
								충돌걱정없이 외부 라이브러리가 DOM에 접근하여 사용할 수 있다.
						ㄴ 유의사항 )
							ㄴ jQuery와 같이 사용하는 경우, 위와같은 방식으로 빈 < div/>를 반환하여 jQuery가 DOM을 조작할수있게하는건 좋은데 다 사용하고나서
								해당 DOM에 부착된 이벤트 리스너 등을 모두 떼어내어 이후에 충돌이 발생할 소지를 없애야한다.
					ㅡ ????? 먼소린지

				</pre>
				ㅇ JSX 이해하기 <button>더보기</button>
				<pre>
					ㅡ JSX는 React.createElement(component, props, ...children) 함수를 약간 편하게 사용하는 정도의 기능을 하는것뿐이라한다.
						ㄴ JSX의 다음 코드는
							< MyButton color="blue" shadowSize={2}>
							  Click Me
							< /MyButton>
						ㄴ 컴파일되어 다음과 같이 바뀐다
							React.createElement(
							  MyButton,
							  {color: 'blue', shadowSize: 2},
							  'Click Me'
							)
					ㅡ JSX의 첫번째 부분이 리액트 엘리먼트의 타입을 결정한다.
						ㄴ 대문자로 시작하면 JSX는 리액트 컴포넌트를 의미하게된다. 이 JSX태그는 named 변수에 대한 참조로 컴파일되기때문에,
							해당이름이 '스코프' 안에 존재해야한다.
					ㅡ JSX는 React.createElement()를 호출하여 컴파일을 진행하기때문에, React library또한 JSX가 사용된 코드의 스코프 안에 존재해야한다.
						ㄴ ex)
							//아래에서 < CustomButton>을 사용하려면 JSX가 이를 컴파일하기 위해 React.createElement()를 사용하므로 import React from 'react'가
							// 필요하고, CustomButton에 대한 참조변수가 생성되어야하기때문에 import CustomButton from './CustomButton'이 필요하다.
							import React from 'react';
							import CustomButton from './CustomButton';

							function WarningButton() {
							  // return React.createElement(CustomButton, {color: 'red'}, null);
							  return < CustomButton color="red" />;
							}
					ㅡ ????? JSX에서 Dot Notation 사용하기 )
						ㄴ JSX안에서 dot notation( . )으로 리액트 컴포넌트를 가리킬 수 있다고 하는데 잘 이해가 안간다.
					ㅡ 소문자로 시작하는 엘리먼트 타입은 < div>, < span>등과 같은 내장된 컴포넌트를 의미하게 된다. 그리고 React.createElement()의
						인자로 'div', 'span'과 같은 형식으로 넘어가게 된다.
						ㄴ 대문자로 시작하는 리액트컴포넌트는 컴포넌트명이 'Foo'라고 하면, React.createElement(Foo)같이 그대로 넘어간다.
					ㅡ JSX의 엘리먼트 타입부분에 js의 일반표현식을 사용할 수 없다.
						ㄴ ex)
							const components = {
							  photo: PhotoStory,
							  video: VideoStory
							};

							function Story(props) {
							  //이런식으로 jsx의 엘리먼트타입부분에 component[props.storyType]와 같이 일반표현식을 사용할 수 없다.
							  return < components[props.storyType] story={props.story} />;
							}
						ㄴ 저런식으로 사용하고자한다면 components[porps.storyType]을 대문자로 시작하는 변수에 넣어서 엘리먼트타입으로 주는식으로
							사용해야 한다.
							ㄴ ex)
								function Story(props) {
									// Correct! JSX type can be a capitalized variable.
									const SpecificStory = components[props.storyType];
									return < SpecificStory story={props.story} />;
								}
					ㅡ JSX에서의 props )
						ㄴ 어떠한 js expression이라도 넣어서 props로 넘겨줄 수 있다. ex) < MyComponent foo={1 + 2 + 3 + 4} />
						ㄴ string literal )
							ㄴ jsx안에 써서보내든 일반 문자열을 보내든 동일하다. ex) < MyComponent foo={'hello'} />, < MyComponent foo="hello" />
							ㄴ string literal은 html코드로 넘겨지기때문에 html 특수문자 코드를 넘겨도 상관없다.
						ㄴ props에 아무 값도 주지 않으면 true값이 넘어간다. 혼동의 여지가 있기때문에 추천하지 않는다함.
						ㄴ spread 연산자 (...)
							ㄴ 넘기려는 prosp가 객체형태이면, '...'연산자를 통해 한번에 넘길 수 있다.
							ㄴ ex) 아래 두코드는 동일한 props가 넘어가게 된다.
								function App1() {
								  return < Greeting firstName="Ben" lastName="Hector" />;
								}

								function App2() {
								  const props = {firstName: 'Ben', lastName: 'Hector'};
								  return < Greeting {...props} />;  //
								}
							ㄴ js의 '구조 분해 할당'을 사용하여 props를 주고받을 수도 있다.
					ㅡ JSX의 Children )
						ㄴ jsx로 표현한 태그 사이의 내용은 props의 일종으로 취급된다. props.children
							ㄴ ex) < MyComponent> hello < /MyComponent> //hello는 MyComponent에게 props.children으로 넘어가게된다.
						ㄴ props.children으로 넘어가는 데이터 유형 )<button>더보기</button>
					<pre>
							ㄴ string literal )
								ㄴ jsx 태그 사이에 문자열을 넣을 경우, string literal이 넘어간다.
								ㄴ 공백이나, white space에 대해 jsx가 임의로 처리를 한다. 다음과 같다.
									ㄴ 문자열 맨 처음과 마지막에 있는 white space를 제거한다.
									ㄴ 아무내용이 없는비어있는 줄을 제거한다.
									ㄴ 태그에 인접해있는 새 라인쓰기는 제거된다.
									ㄴ 문자열 중간에 존재하는 새 라인쓰기는 하나의 white space로 대체된다.
							ㄴ 또다른 jsx )
								ㄴ 또다른 jsx 엘리먼트를 children으로 넘길 수 있다.
									ㄴ ex)
										< MyComponent>
											< MyFirstComponent/>
											< MySecondComponent/>
										< /MyComponent>
							ㄴ js expression )
								ㄴ { }로 감싸서 js 표현식을 children으로 넘길 수 있다. ex) < MyComponent>{'foo'}< /MyComponent>
							ㄴ 함수 )
								ㄴ props.children은 일반 props처럼 사용될 수 있기때문에 함수를 children으로 넘겨서 이를 받은 컴포넌트에서 콜벡용도로 사용할 수 있다.
								ㄴ ex)
									function Repeat(props) {
									  let items = [];
									  for (let i = 0; i < props.numTimes; i++) {
										items.push(props.children(i));
									  }
									  return < div>{items}< /div>;
									}

									function ListOfTenThings() {
									  return (
															   < Repeat numTimes={10}>
										  {(index) => < div key={index}>This is item {index} in the list< /div>}
										< /Repeat>
									  );
									}
							ㄴ booleans, null, undefined 값들 )
								ㄴ 전달될 수 있으나, 아무것도 렌더링되지 않고 무시된다.
								ㄴ 단, 일부 js의 falsy value는 무시되지 않고 렌더링된다. 가령 0 같은것들.
									ㄴ ex)
									   < div>
											//props.messages가 비어있는 경우에 0이 렌더링된다. 0은 falsy value이지만 리액트에선 이를 렌더링하기때문.
										   {props.messages.length &&
										   < MessageList messages={props.messages} />
										   }
									   < /div>
							ㄴ 위의 children에 올수있는 유형들은 섞여서 사용될 수 있다.
						</pre>
				</pre>
				ㅇ 성능 최적화 <button>더보기</button>
				<pre>
					ㅡ ~~~~~

				</pre>
				ㅇ Portals<button>더보기</button>
				<pre>
					ㅡ 컴포넌트의 children을 현재 컴포넌트 계층 안에 없는 다른 DOM으로 넣어줄수있게 해주는 기능.
					ㅡ ~~~~~
				</pre>
				ㅇ Profiler API<button>더보기</button>
				<pre>
					ㅡ 리액트 어플이 얼마나 자주 렌더링되는지 측정하여 프로그램에서 느린부분을 식별하고 최적화에 도움을 주는 기능이다.
					ㅡ ~~~~~
				</pre>
				ㅇ ES6가 없는 리액트 <button>더보기</button>
				<pre>
					ㅡ ES6가 없는 경우 리액트를 사용하는 방법에 대해 나옴.
					ㅡ ~~~~~
				</pre>
				ㅇ JSX가 없는 리액트<button>더보기</button>
				<pre>
					ㅡ ~~~~~
				</pre>
				ㅇ Reconciliation <button>더보기</button>
				<pre>
					ㅡ ?????
				</pre>
				ㅇ render props <button>더보기</button>
				<pre>
					ㅡ ~~~~~
				</pre>
				ㅇ static type checking<button>더보기</button>
				<pre>
					ㅡ 코드를 실행하기전에 js코드를 검사해주는 기능을 제공해주는 툴들이 있다.
						ㄴ ex) Flow, TypeScript
					ㅡ ~~~~~

				</pre>
				ㅇ Strict Mode<button>더보기</button>
				<pre>
					ㅡ 코드상에서 좀더 엄격하게 경고를 표시하는 기능.
						ㄴ 어플에 영향을 미치거나 추가적인 렌더링 없이 그냥 경고만 추가한다.
					ㅡ ~~~~~

				</pre>
				ㅇ TypeChecking with PropTypes<button>더보기</button>
				<pre>
					ㅡ Flow, TypeScript와 같은 도구를 사용하지 않더라도 리액트 안에서 props에 대한 typecheck를 할 수 있다.
					ㅡ 컴포넌트의 propTypes 속성을 이용하면 된다.
					ㅡ ~~~~~
				</pre>
				ㅇ Uncontrolled Components<button>더보기</button>
				<pre>
					ㅡ 대부분의 경우에는 리액트에서 form사용시, <a href="#React_기본개념_form">일반적인 리액트에서 form사용</a>처럼
						form의 값이 컴포넌트에 의해 controlled되는 controlled component 방식을 추천한다고함.
					ㅡ 근데, 드문 몇몇 경우에, form의 값이 컴포넌트에 의해서가 아닌, dom자체에 대해서 컨트롤되는 'uncontrolled component'가 필요.
					ㅡ 이를 위해, form에 'ref'를 사용하면 된다고함.
					ㅡ ~~~~~
				</pre>
				ㅇ Web Components<button>더보기</button>
				<pre>
					ㅡ web component와 리액트를 같이 사용하는 것에 대한 내용.
					ㅡ ~~~~~
				</pre>

			</pre>
			ㅇ API 참고서 <button>더보기</button>
			<pre>
				ㅡ React<button>더보기</button>
				<pre>
					ㄴ 컴포넌트<button>더보기</button>
					<pre>
						ㄴ React.Component<button>더보기</button>
						<pre>
							ㄴ React.Component Api<button>더보기</button>
							<pre>
								ㄴ class형태로 React component를 생성하려면 React.Component를 상속해야한다.
								ㄴ 컴포넌트 생명주기 <button>더보기</button>
								<pre>
									 <img src="image/리액트컴포넌트_생명주기.png"/>
									ㄴ 렌더링 단계 )
										ㄴ dom과 관계없이 리액트 내부적으로만 처리하는 단계.
									ㄴ 커밋단계 )
										ㄴ 리액트가 리액트 엘리먼트를 가지고 실제 dom을 업데이트하는 단계. dom에 접근이 가능하여 dom관련 작업이 가능하다.
									ㄴ 마운트 )<button>더보기</button>
									<pre>
										ㄴ 마운트란? ReactDOM이 리액트 엘리먼트를 실제 DOM으로 적절하게 만들어서 DOM에 추가하는 작업.
											ㄴ ex)
												html코드
												< body>
													< noscript>You need to enable JavaScript to run this app.</noscript>
													< div id="root">< /div>
												< /body>
												---------------------------------
												index.js 코드
												ReactDOM.render(
												  < React.StrictMode>
														< App />
												  < /React.StrictMode>,
												  document.getElementById('root')
												);
												----------------------------------
												ㄴ App 컴포넌트에서 < div>hello < /div>를 반환하고 있다고치면,
													App에 의해 반환된 < div>hello< /div>라는 리액트 엘리먼트가 js 객체로 존재하다가
													ReactDOM.render()에 의해 root div아래에 < div>hello< /div>가 실제 DOM으로 생성되어
													추가되는 과정이 '마운팅'.
										ㄴ 1. constructor()
											ㄴ 컴포넌트 마운트 이전에 호출.
											ㄴ 몸체에 가장 최우선으로 super(props)를 호출해야함. 컴포넌트의 this.props을 정의하기위함.
											ㄴ 일반적인 사용목적 )
												ㄴ state초기화, 이벤트 처리 메소드 바인딩.
											ㄴ 몸체에서 setState()를 호출해서는 안된다.
											ㄴ 이 안에서만 this.state를 직접 할당할 수 있다.
										ㄴ 2. getDerivedStateFromProps()
											ㄴ 최초 마운트할때와 컴포넌트 업데이트할때, render()호출 직전에 호출된다.
											ㄴ ?????
										ㄴ 3. render()
											ㄴ 클래스형 컴포넌트에서 반드시 구현되어야하는 메소드.
											ㄴ this.props와 this.state의 값들을 활용하여 다음중 하나를 반환한다.
												ㄴ React 엘리먼트 : 일반적으로 JSX를 사용하여 생성된다.
													ㄴ ex) < div/>, < MyComponent/> 등. < div> DOM노드나 사용자가만든 < MyComponent>라는
														리액트 컴포넌트를 반환하는 리액트 엘리먼트이다.
												ㄴ 배열, Fragment : 여러개의 리액트 엘리먼트를 반환한다.
												ㄴ Portal : ?????
												ㄴ 문자열과 숫자 : 텍스트 노드로서 렌더링된다.
												ㄴ Boolen, null : 아무것도 렌더링하지 않는다.
											ㄴ ????? 이함수는 순수해야 한다고함. state를 변경하지도, 브라우저와 상호작용하지도 않고
												호출시마다 동일한 결과를 반환해야 한다고 한다.
										ㄴ componentDidMount()
											ㄴ 컴포넌트가 마운트된 직후 호출된다.
												* 마운트란? 리액트 컴포넌트가 DOM트리상에 삽입되는것을 말한다. dom트리상에 삽입되었으므로 화면에 그려지게된다.
											ㄴ ????? ajax등의 네트워크 데이터를 불러오기 좋은 위치라고하는데 잘 이해가 안간다. 왜 좋은위치라는건지.
											ㄴ 이 안에서 setState()를 호출하는 경우가 있다.
												ㄴ 렌더링이 한번더 호출되어 성능상의이슈가 있을수도 있다고 한다.
									</pre>
									ㄴ 업데이트 )<button>더보기</button>
									<pre>
										ㄴ 1. static getDerivedStateFromProps()
											ㄴ ?????
										ㄴ 2. shouldComponentUpdate(nextProps, nextState)
											ㄴ props, state가 갱신되어 다시 렌더링되기 직전에 호출된다.
											ㄴ 디폴트 반환값은 true.
											ㄴ 새로 갱신되는 props, state값을 인자로 받아 다시렌더링을 할지 확인한후 false를 반환하여 업데이트를 생략할 수있다.
											ㄴ '성능 최적화'를 위해서만 사용해야한다. 버그로 이어지기 쉽다.
											ㄴ 이 메소드 대신 PureComponent를 사용하는걸 추천한다함.
										ㄴ 3. render()
										ㄴ 4. getSnapshotBeforeUpdate( prevProps, prevState)
											ㄴ render()이후에, 리액트가 dom을 업데이트하기 직전에 호출된다.
											ㄴ 이 메소드 호출 후, dom이 업데이트 되고, 그 다음 componentDidUpdate()가 호출되는것.
											ㄴ ????? 어디에써야할지는 아직 잘모르겠음.
											ㄴ 값을 리턴해야한다. 반환값을 componentDidUpdate()에서 snapshot이라는 인자로 받게된다.
												ㄴ ????? 그냥 반환만하면되는지 잘모르겠다.
										ㄴ 5. componentDidUpdate( prevProps, prevState, snapShot )
											ㄴ dom 업데이트가 일어난 직후에 호출된다.
											ㄴ 내부에서 setState()호출시, 무한루프가 돌게되므로 prevProps, prevState인자로 조건체크를 해주어야한다.
									</pre>
									ㄴ 언마운트<button>더보기</button>
									<pre>
										ㄴ 컴포넌트의 마운트가 해제되어 제거되기 직전에 호출된다.
										ㄴ ????? render()안에 return에서 안보이면 언마운트 되는듯하다.
									</pre>
									ㄴ 오류 처리<button>더보기</button>
									<pre>
										ㄴ 다음 메소드들은 자손컴포넌트가 렌더링, 생명주기메소드호출, 생성자 호출시에 오류발생시 호출되는 메소드들이다.
										ㄴ static getDerivedStateFromError( error )
											ㄴ 매개변수로 해당 오류를 전달받는다.
											ㄴ 업데이트된 state를 반드시 반환해야한다.
											ㄴ '렌더링 단계'에서 호출된다.
										ㄴ componentDidCatch( error, info )
											ㄴ 매개변수 )
												ㄴ error : 오류
												ㄴ info : 어떤 컴포넌트가 오류를 발생시켰는지에 대한 정보를 포함한 componentStack 키를 가지고있는 객체.
											ㄴ '커밋 단계'에서호출된다.
									</pre>
								</pre>
								ㄴ 기타 api )<button>더보기</button>
								<pre>
									ㄴ setState( updater, [callback])<button>더보기</button>
									<pre>
										ㄴ 컴포넌트 state변경사항을 대기열에 넣고 리액트에게 해당컴포넌트와 그 자식컴포넌트들이 다시 렌더링 되어야 한다고알린다.
											ㄴ 즉각적인 갱신이 아닌, '요청'으로 생각하라함. 바로 바뀌는게 아니다.
											ㄴ 따라서 setState()직후 바로 state에 접근하는게 오류가생길수도있다.
											ㄴ [callback]이나 ?????componentDidUpdate를 사용하라고한다.
										ㄴ 화면상의 성능을 위해, 매 setState()마다 화면을 리렌더링하지는 않는다. 적절하게 한꺼번에 처리할 수도 있다.
										ㄴ shouldComponentUpdate()가 false를 반환하지 않으면 setState()는 항상 다시 렌더링을 발생시킨다.
										ㄴ updater
											ㄴ 다음과 같은 형태의 함수이다.
											ㄴ (state, props) => (*새로운 state를 '표현'하는 객체*)
											ㄴ 인자로 받는 state, props는 최신값이 보장된다.
											ㄴ 반환값으로 state를 '표현'하는 객체를 반환하면 이에 맞게 state가 갱신된다.
												ㄴ ex ) setState( (state,props) => {
															return{ count: 1 };
														}); //state의 count프로퍼티가 1로 업데이트된다.
											ㄴ 함수형태가 아닌 (*새로운 state를 '표현'하는 객체*)를 그대로 updater부분에 전달해도 똑같이 적용된다.
												ㄴ ex) setState( {count: 1} );
										ㄴ callback
											ㄴ setState가 실행완료되고 컴포넌트가 다시 렌더링된후 실행될 함수이다.
											ㄴ 생략가능하다.
										ㄴ 기타 )
											ㄴ setState는 왜, 언제 일괄처리되는가?
												ㄴ https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973
											ㄴ this.state는 왜 즉시 실행되지 않는가
												ㄴ https://github.com/facebook/react/issues/11527
									</pre>
									ㄴ forceUpdate( callback )
										ㄴ 다시 렌더링을 수행하게 한다.
										ㄴ shouldComponentUpdate()가 생략되고 render()가 호출된다.
										ㄴ 자식컴포넌트들에서는 일반적인 생명주기가 실행된다.
								</pre>
								ㄴ 클래스 프로퍼티 )<button>더보기</button>
								<pre>
									ㄴ defaultProps )
										ㄴ props에 값이 제공되지 않을경우 사용할 디폴트 props를 설정할 수 있다.
										ㄴ ex) class NoName extends React.Component{
												~~~~~
												NoName.defaultProps = {
													color: 'blue'
												}
											   }
											ㄴ NoName에 color props가 전달되지 않았다면 'blue'가 설정된다.
									ㄴ displayName )
										ㄴ ~~~~~
								</pre>
								ㄴ 인스턴스 프로퍼티<button>더보기</button>
								<pre>
									ㄴ props )
									ㄴ state )
								</pre>
							</pre>
						</pre>
						ㄴ React.PureComponent<button>더보기</button>
						<pre>
							ㄴ ?????
						</pre>
						ㄴ React.memo<button>더보기</button>
						<pre>
							ㄴ 고차컴포넌트이다.
							ㄴ 컴포넌트를 인자로 받아서, 이컴포넌트를 '메모이징'해둔다. (그대로 저장해둔다는 의미인듯하다)
								이후 해당 컴포넌트의 props이 변경되지 않았다면 메모이징해두었던 내용을 그대로 보여준다.
							ㄴ state, context 등에 대해서는 일반적인경우과 같이 리렌더링을 한다.
							ㄴ 성능최적화를 위해서만 사용해야한다.
						</pre>
					</pre>
					ㄴ 리액트 엘리먼트 생성<button>더보기</button>
					<pre>
						ㄴ JSX를 사용하여 생성하는게 일반적인 경우이다.
						ㄴ JSX없이 직접 생성하려는 경우, 사용되는 메소드들은 다음과 같다.
							ㄴ React.createElement( type, [props], [...children] )
								ㄴ JSX를 사용하여 엘리먼트생성시 호출되는 메소드이다.
								ㄴ type에는 html 태그이름, 리액트 컴포넌트, 리액트 Fragment 중 하나가 올수있다.
							ㄴ React.createFactory( type )
								ㄴ createElement()와 동일한 type을 인자로 받는다.
								ㄴ type에 해당하는 리액트 엘리먼트를 반환하는 함수를 반환한다.
								ㄴ 레거시 기능이다.
					</pre>
					ㄴ 리액트 엘리먼트 조작 api들<button>더보기</button>
					<pre>
						ㄴ cloneElement( element, [props], [...children] )<button>더보기</button>
						<pre>
							ㄴ element가 리액트 엘리먼트를 의미하며, props, children인자들을 이용해 element를 복사한다.
							ㄴ 복사되어 생성된 리액트 엘리먼트의...
								ㄴ props은 원래의 props와 cloneElement()의 인자로넘긴 props가 얕게 병합된 props를 가진다.
								ㄴ children은 cloneElement()의 인자로넘긴 children으로 대체된다.
								ㄴ key와 ref는 원래의 element와 동일하다.
							ㄴ 사실상 cloneElement()는 다음구문과 동일하다 (ref와 key에 대한것만제외하고)
								ㄴ < (*엘리먼트 type*) (*기존props들...*) (*새 props*)> (*새children*) < /~~~>
						</pre>
						ㄴ isValidElement( object ) : object가 리액트 엘리먼트인지 판별
						ㄴ React.Children <button>더보기</button>
						<pre>
							ㄴ 리액트 엘리먼트의 children을 다루는 함수들을 제공한다.
							ㄴ React.Children.map
							ㄴ React.Children.forEach
							ㄴ React.Children.count
							ㄴ React.Children.only
							ㄴ React.Children.toArray

						</pre>
					</pre>
					ㄴ Fragment )
					ㄴ Refs )<button>더보기</button>
					<pre>
						ㄴ React.createRef
						ㄴ React.forwardRef )
							ㄴ ~~~~~
					</pre>
					ㄴ Suspense<button>더보기</button>
					<pre>
						ㄴ ~~~~~
					</pre>
				</pre>
				ㅡ ReactDOM<button>더보기</button>
				<pre>
					ㄴ
				</pre>
				ㅡ ~~~~~
				ㅡ

			</pre>
			ㅇ 훅 Hook<button>더보기</button>
			<pre>
				ㅡ React 16.8부터 새로 추가된 기능.  class를 사용하지 않아도 리액트를 사용할 수 있게해준다.
				ㅡ 소개 <button>더보기</button>
				<pre>
					ㄴ 등장 배경 )
						ㄴ 기존에 함수형 컴포넌트에서는 리액트 컴포넌트의 라이프 사이클과 state를 사용할 수 없었다.
						ㄴ 훅이 등장하면서 이것들이 가능해진 것인데
						ㄴ 기존의 클래스형 컴포넌트로는 상태와 관련된 로직을 재사용하기 까다롭다는 문제가 있었다.
							ㄴ HOC와 render props를 사용하여 재사용했었음.
						ㄴ 해서 함수형컴포넌트에 state와 라이프사이클을 사용할 수 있게 함으로써 상태관련 로직을 재사용하기 쉽게 만들었다고한다.
					ㄴ 특징 )
						ㄴ 선택적 사용. 기존코드 수정없이 훅을 사용하거나 사용안할 수 있다.
					ㄴ ?????
				</pre>
				ㅡ 개요<button>더보기</button>
				<pre>
					ㄴ 훅이란?
						ㄴ 함수 컴포넌트에서 state와 생명주기를 연동(hook)할 수 있게해주는 함수.
						ㄴ class안에서는 동작하지 않음.
						ㄴ 내장된 hook들이 존재하며, 직접 만드는것도 가능하다.
					ㄴ 훅 규칙<button>더보기</button>
					<pre>
						ㄴ 반복문, 조건문 등의 안에서가 아닌 최상위레벨에서만 훅을 호출해야한다.
						ㄴ React 함수컴포넌트 내에서만 훅을 호출해야한다.
					</pre>
					ㄴ 커스텀 훅 만들기<button>더보기</button>
					<pre>
						ㄴ 공통로직을 빼는데 사용한다고한다.
						ㄴ 일반적인 함수와 다를바가 없지만, 커스텀 훅은 내부에서 다른 훅을 호출할 수 있다는 특징이 있다.
						ㄴ 이름이 'use'로 시작하는 js함수를 만들면 이는 커스텀 훅이 된다.
					</pre>
					ㄴ Hook Api 참고서<button>더보기</button>
					<pre>
						ㄴ 참고 ) 리액트 훅 flow
							<img src="image/리액트 훅 flow.png" height="600"/>
						ㄴ useState<button>더보기</button>
						<pre>
							ㄴ 함수형 컴포넌트에서 useState훅을 사용하여 state를 사용할 수 있다.
								ㄴ 원래는 함수형 컴포넌트 내에서는 state를 못썼음.
							ㄴ 사용법 ) <button>더보기</button>
							<pre>
								ㄴ const [count, setCount ] = useState(0)
									ㄴ useState()는 class형 컴포넌트에서의 state와 똑같은 state 변수와 이 변수를 업데이트할 수있는 함수를 반환해준다.
									ㄴ useState()의 인자는 해당 state변수값의 초기값이다.
										ㄴ 함수를 주어서 이 함수의 리턴값으로 초기화 할 수 있다.
											ㄴ ex)
												const [count, setCount] = useState( ()=>{
													//초기값 계산 로직
													return (*계산한 초기값*);
												})
									ㄴ 일반적으로 위와같이 js의 '구조분해할당'을 이용하여 생성,할당받는다.
								ㄴ 사용을 위해선 그냥 변수명을 사용하면된다. class형 컴포넌트와 같이 'this.state.count' 이렇게 안해도된다.
									ㄴ ex)    < p>You clicked {count} times< /p>
								ㄴ 업데이트를 위해선 useState()에서 반환받은 함수를 사용하면된다.
									ㄴ ex)
										< button onClick={() => setCount(count + 1)}>
    										Click me
										< /button>
									ㄴ set함수의 인자로 함수를 주어도 된다.
										ㄴ 인자로 함수를 줄 경우, 이 함수는 첫 번째 인자로 기존의 state값을 받게 된다.
										ㄴ 함수의 반환값이 state에 저장되게 된다.
										ㄴ setCount( ( aaa, bbb )=>{
												console.log(aaa); //기존의 count state의 값.
												console.log(bbb); //인자로는 기존의 state값만 받으므로 bbb는 undefined.
												return aaa + 1; //setCount( aaa+1 ) 과 동일하다.
											}
									ㄴ state값에 변화가 없을 경우, 리렌더링을 건너뛴다.
									ㄴ state가 객체인 경우, 클래스형 컴포넌트의 setState()처럼 자동으로 병합해주지 않는다.
										ㄴ ex)
											const [obj, setObj] = useState( { num1: 111, num2: 222 });
											setOjb( { num3: 333 }); // state obj는 { num1:111, num2:222, num3:333 }가 아닌 { num3: 333 }이 된다.
										ㄴ '객체 전개 연산자'를 이용하여 병합 효과를 낼 수 있다.
											ㄴ ex)
												setObj( preState => {
													return { ...preState, (*객체에 추가할 프로퍼티*) }
												}
										ㄴ useReducer 훅을 사용할 수도 있다.
							</pre>
						</pre>
						ㄴ useEffect <button>더보기</button>
						<pre>
							ㄴ 기본 <button>더보기</button>
							<pre>
								* side effect
									ㅡ 데이터를 가져오거나, dom을 업데이트하거나, 구독(네트워크를 연결하여 지속적으로 데이터를 받아오거나 보내는작업?) 등의
										작업을 side effect라고 한다.
									ㅡ componentDidMount(), componentDidUpdate()등에서 ajax으로 데이터를 가져와 다시렌더링해주는 등의 작업이 포함된다.
								ㄴ clean up이 필요없는 side effect의 경우 )
								ㄴ useEffect 훅은 이러한 side effect를 수행할수있도록 만들어진 훅이다.
								ㄴ useEffect( (*함수*), [ (*데이터 배열*) ] )
								ㄴ 함수형 컴포넌트에서 DOM이 그려진 이후(렌더링 이후)에 호출되어 인자로 넘어간 함수를 호출한다.
									ㄴ 넘어간 함수를 effect라고 부른다.
									ㄴ 호출시마다 새로운 effect가 대체되어 전달되고 실행된다.
										ㄴ 최신값들이 적용되어 로직이 돌아갈수있도록 하기 위해서.
								ㄴ effect 동작 시점 )
									ㄴ ????? 화면이 모두 그려지고 난 뒤?
								ㄴ 조건부 effect 실행
									ㄴ 두번째 인자로 배열을 넘길 경우, 해당 배열의 데이터들이 변경된 경우에만 useEffect()가 호출된다.
									ㄴ 불필요한 리렌더링을 막는 용도이다.
									ㄴ 이 두번째 인자를 사용하는 경우, effect안에서 사용되는 모든 데이터들이 배열안에 포함되는지 확인해야 한다.
										ㄴ 기본적인 값들과 그 값들로부터 파생되는 모든 값들도 포함시켜야한다.
									ㄴ 빈 배열([])을 전달하면, 한번만 실행되게 된다.
									ㄴ 주의 사항 )
										ㄴ 의존하는 데이터를 빼먹는 것 )
											ㄴ ex)
												function doSomething() {
													console.log(someProp);
											  	}

												useEffect(() => {
													doSomething();
											  	}, []);
												ㄴ doSomething()안에서 someprop를 사용하지만 함수가 분리되어있어 추적하기어려워 실수의 여지가 있다.
											ㄴ 해서, effect내부에서 필요한 함수는 effect안에서 선언하여 사용하는걸 권장한다고 한다.
											ㄴ 또는 eslint-plugin-react-hooks 패키지의 일부로 exhaustive-deps 규칙을 사용하면 의존하는 데이터들을 추적하여 표시해준다.
											ㄴ 또는 effect내부에서 사용하는 함수들을 useCallback()훅을 이용하여 만들어 놓고, useEffect()의 의존성 인자로 해당 함수를 줄 수 있다.
												그러면, useCallback()의 함수가 관련 데이터에 따라 다시 정의될것이고 그러면 해당 함수가 변했으므로 useEffect()도 호출이 된다.
								ㄴ useEffect()는 함수를 반환할 수 있다.
									ㄴ 함수 반환시, 해당 함수는 componentWillUnmount()의 시점과 동일한 시점에서 호출된다.
									ㄴ 컴포넌트에서 '구독'을 하고있는경우, 이를 이용하여 구독을 해제할 수 있다.
								ㄴ 함수형 컴포넌트 내부에 있기때문에 당연히 함수컴포넌트의 props와 state에 접근가능하다.
								ㄴ componentDidMount(), componentDidUpdate(), componentWillUnmount()와 유사한 기능을 한다고 보면된다.
									ㄴ 처음 렌더링시, 이후 업데이트시마다 호출된다.
								ㄴ 이런 기능을 통해, class형태에서 componentDiDMount(), componentDidUpdate(), componentWillUnmount()에서
									나누어져 수행되던 기능을 한 함수 안에서 사용할 수 있다.
								ㄴ ex)
									import React, { useState, useEffect } from 'react';

									function Example() {
									  const [count, setCount] = useState(0);

									  useEffect(() => {
										document.title = `You clicked ${count} times`;
									  });

									  return (
										< div>
										  < p>You clicked {count} times< /p>
										  < button onClick={() => setCount(count + 1)}>
											Click me
											< /button>
										< /div>
									  );
									}
							</pre>
							ㄴ 더 알아보기<button>더보기</button>
							<pre>
								ㄴ class형 컴포넌트의 라이프사이클 메소드 안에서 여러 로직들이 모두 들어가있는 경우가 많다.
									useEffect를 여러개 사용하면 관련있는 로직끼리 한 useEffect함수안에 넣어두어 코드를 깔끔하게 할 수 있다.
									ㄴ ex)<button>더보기</button>
									<pre>
										클래스 라이프사이클 메소드를 사용하는 경우,
										class FriendStatusWithCounter extends React.Component {
										  constructor(props) {
											super(props);
											this.state = { count: 0, isOnline: null };
											this.handleStatusChange = this.handleStatusChange.bind(this);
										  }

										  componentDidMount() {
											document.title = `You clicked ${this.state.count} times`;
											ChatAPI.subscribeToFriendStatus(
											  this.props.friend.id,
											  this.handleStatusChange
											);
										  }

										  componentDidUpdate() {
											document.title = `You clicked ${this.state.count} times`;
										  }

										  componentWillUnmount() {
											ChatAPI.unsubscribeFromFriendStatus(
											  this.props.friend.id,
											  this.handleStatusChange
											);
										  }

										  handleStatusChange(status) {
											this.setState({
											  isOnline: status.isOnline
											});
										  }
										  // ...

										useEffect를 사용하는 경우,
										function FriendStatusWithCounter(props) {
										  const [count, setCount] = useState(0);
										  useEffect(() => {	//페이지의 title변경 로직이 들어있음.
											document.title = `You clicked ${count} times`;
										  });

										  const [isOnline, setIsOnline] = useState(null);
										  useEffect(() => {	//구독 연결, 해제관련 로직이 들어있음.
											function handleStatusChange(status) {
											  setIsOnline(status.isOnline);
											}

											ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
											return () => {
											  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
											};
										  });
										  // ...
										}
										ㄴ 이렇게 관련있는 로직끼라 하나의 useEffect()안에 넣어둘수있다.
									</pre>
								ㄴ effect가 업데이트시마다 실행되는 이유<button>더보기</button>
								<pre>
									ㄴ
								</pre>
							</pre>
						</pre>
						ㄴ useContext<button>더보기</button>
						<pre>
							ㄴ ex)
								const value = useContext( MyContext );
							ㄴ 클래스형 컴포넌트에서 context 사용시 static contextType = (*context변수명*) 을 했었는데, 이 부분이
								함수형 컴포넌트에서 위와 같음. 나머지는 동일( Provider사용하고 등등.. )
						</pre>
						ㄴ useReducer<button>더보기</button>
						<pre>
							ㄴ useState() 훅의 대체 함수. 유사하게 state를 업데이트 해주는 기능을 하나, 좀 더 복잡한 업데이트가 가능하게 한다.
							ㄴ 사용법 )
								ㄴ const [ (*state값*), (*dispatch함수명*) ] = useReducer( (*reducer함수*), (*state초기값*), (*state초기값반환함수*) )
								ㄴ ex)
									const initialState = {count: 0};

									function reducer(state, action) {
									  switch (action.type) {	//dispatch()에서 인자로 들어간 데이터가 그대로 action에 들어온다.
										case 'increment':
										  return {count: state.count + 1};
										case 'decrement':
										  return {count: state.count - 1};
										default:
										  throw new Error();
									  }
									}

									function Counter() {
									  const [state, dispatch] = useReducer(reducer, initialState);
									  return (
										<>
										  Count: {state.count}
										  < button onClick={() => dispatch({type: 'decrement'})}>-< /button>	//dispatch()호출시, reducer가 호출되어 state가 갱신된다.
										  < button onClick={() => dispatch({type: 'increment'})}>+< /button>
										< />
									  );
									}

								ㄴ (*dispatch함수명*)이 useState()훅 사용할때 const [count, setCount]=useState()에서 setCount()같은 부분이다.
								ㄴ (*state초기값*) 부분에 초기값을 바로 입력할 수 있고, 또는 (*state초기값반환함수*)를 통해 초기값을 계산하여 설정 할 수 있다.
								ㄴ (*reducer함수*)
									ㄴ ( (*이전state값이 들어갈 인자*), (*dispatch함수에서 설정한 action이 들어갈 인자*) ) => (*새로운 state값*) 형태의 함수.
									ㄴ 두 인자를 받아서 원하는 로직대로 새로운 state값을 계산하여 반환하면 state가 반환값으로 설정된다.
								ㄴ dispatch함수는 dispatch( (*reducer함수의 action에 들어갈 데이터*) ) 형태로 사용한다.
									ㄴ 데이터에는 정해진 형식이나 제한이 없다.
									ㄴ dispatch()호출시, state와 action을 가지고 reducer가 호출되어 state가 업데이트된다.
						</pre>
						ㄴ useCallback<button>더보기</button>
						<pre>
							ㄴ const func = useCallback( (*함수*), (*의존하는 데이터의 배열*) )
							ㄴ 일반적인 함수정의처럼 (*함수*)를 정의하여 func에 저장한다.
								그리고 이를 '메모이제이션'하여 저장해둔다.
								useEffect에서와 비슷하게 의존하는 데이터의 배열을 두번째 인자로 넘긴다. 그리고 이 데이터들이 변화하지 않는 한,
								func호출시 '메모이제이션'된 함수를 계속 사용한다. 의존하는 데이터들이 변할시, (*함수*)를 다시 정의하여 저장해둔다.
							ㄴ useEffect에서의 주의점처럼, (*의존하는 데이터의 배열*)에 의존되는 모든 데이터가 포함되어야 한다.
						</pre>
						ㄴ useMemo<button>더보기</button>
						<pre>
							ㄴ const value = useMemo( (*함수*), (*의존하는 데이터의 배열*) )
							ㄴ useCallback과 유사하다. (*함수*)에서 계산하여 반환한 값을 value에 저장한 뒤, (*의존하는 데이터의 배열*)의 값들이
								변하지 않는 한, 똑같은 값을 사용한다. 값들이 변하면 (*함수*)를 다시 호출하여 값을 계산해준다.
							ㄴ useMemo()에서 사용되는 (*함수*)는 렌더링시에 호출되어 값이 계산된다.
							ㄴ useEffect에서의 주의점처럼, (*의존하는 데이터의 배열*)에 의존되는 모든 데이터가 포함되어야 한다.
						</pre>
						ㄴ useRef<button>
						<pre>
							ㄴ 클래스형 컴포넌트에서 React.createRef()와 동일한 기능을 한다.
							ㄴ ?????
						</pre>
						ㄴ useImperativeHandle<button>더보기</button>
						<pre>
							ㄴ useImperativeHandle( ref, createHandle, [deps] )
							ㄴ 일반적으로 forwardRef()와 같이 사용된다.
							ㄴ 부모 컴포넌트로 전달될 ref참조값을 'createHandle'에 넘길 함수에서 반환하는 값으로 설정 할 수 있다.
								ㄴ 공식문서에서는 부모 컴포넌트에게 전달될 ref참조값을 '커스텀' 할 수 있다 고 표현하고있다.
							ㄴ ex)
								const NoName2 = React.forwardRef( (props, ref)=>{//ref참조를 부모로부터 받음.
									let localRef = useRef();
									useImperativeHandle(ref, ()=> {
										if(localRef.current.value === '1'){return localRef;}//value가 1일 경우, input에 대한 참조를 하고있는 localRef참조를 ref에 전달.
										else return function (){localRef.current.value = 'hehe';}//value가 1이 아닐경우, value를 수정하는 함수를 ref에 전달.
									});
									return(
										<>
											< label>name< /label>< input type='text' ref={localRef} value='1'/>
										< />
									)
								})

								부모 컴포넌트..
								< button onClick={()=>{
									// parentRef.current();//함수를 전달받은 경우 이런식으로 사용한것.
									console.log(parentRef.current.current.value);//parentRef.current안에는 NoName2에서 받은 localRef참조가 들어있고 이 localRef.current안에 input에 대한 참조가 들어있는것.
								}}>button4< /button>
								< NoName2 ref={parentRef}/>//ref를 자식인 NoName2에게 전달.
						</pre>
						ㄴ useLayoutEffect<button>더보기</button>
						<pre>
							ㄴ 형식은 useEffect()와 동일하다. 기능도 대부분 동일한데, 호출 시기만 다르다.
							ㄴ 위의 리액트 훅 flow에서 볼 수 있듯이, useEffect의 effect는 브라우저가 화면을 그린 이후에 호출되는데 반면,
								useLayoutEffect는 브라우저가 화면을 그리기 이전에 '동기적'으로 호출된다.
								ㄴ 따라서 useEffect()를 이용해 화면에 보여줄 데이터를 설정하는 경우, 유저가 보기에 약간의 딜레이가 생기지만,
									useLayoutEffect를 사용하면 이런 것 없이 유저에게 화면을 보여 줄 수 있다.
						</pre>
						ㄴ useDebugValue<button>더보기</button>
						<pre>
							ㄴ ????? 디버깅용. 개발자 툴에서 뭐 표시하는 기능..?
						</pre>
					</button>
					</pre>
				</pre>
			</pre>
			ㅇ Redux<button>더보기</button>
			<pre>
				ㅡ 리액트 훅의 useReducer와 유사한 형식인듯하다.
					ㄴ reducer가 최조 한번 무조건 실행된다함. 이때의 state값은 undefined.
					ㄴ reducer에서 반환할때는 기존의 state를 그대로 반환하지 말고, 이를복제하여 새로운 state값을 리턴하라함. 권장임.
					ㄴ '구독' 개념 )
						ㄴ 특정 함수를 '구독'하게 해두면, state가 변경될 때마다, 해당 함수를 호출해준다.
						ㄴ store.subscribe( (*함수*) )
				ㅡ redux dev tool )
					ㄴ 공식문서에 설정 방법
					ㄴ redux store에 저장된 state의 변화를 깃 버전관리하듯이 히스토리를 볼 수 있다.
				ㅡ 공식 홈페이지 참고
				ㅡ 설치 및 설정<button>더보기</button>
				<pre>
					ㄴ redux toolkit )<button>더보기</button>
					<pre>
						ㄴ redux사용에 도움을 주는 도구.
						ㄴ 이를 사용하면 redux를 좀더 손쉽게 사용 할 수 있으며, 사용하기를 추천한다함.
						ㄴ 설치 )
							ㄴ npm install @reduxjs/toolkit, yarn add @reduxjs/toolkit
							ㄴ
					</pre>
					ㄴ redux 코어
						ㄴ npm install redux, yarn add redux
				</pre>
				ㅡ 추가적인 공부 자료들 )
					ㄴ https://ko.redux.js.org/introduction/learning-resources 참고
				ㅡ redux 생태계 )
					ㄴ 리덕스를 중심으로 하여 추가되고 확장되는 다양한 라이브러리, 에드온, 도구들을 말하는 듯 하다.
					ㄴ 이것들의 목록은 https://ko.redux.js.org/introduction/ecosystem#table-of-contents 참고.
				ㅡ redux 예제들 )
					ㄴ https://ko.redux.js.org/introduction/examples 참고
				ㅡ redux란? )<button>더보기</button>
				<pre>
					ㄴ 어플리케이션 전반적으로 사용되는 state를 'action'을 통해 한 곳에서 중앙집중적으로 관리하는 패턴, 라이브러리.
					ㄴ 이런 state들이 예상되는 대로 변경되도록 해주고, 언제, 어디서, 왜, 어떻게 변경되는지를 알아보기 쉽게 해준다.
					ㄴ 사용해야할 때 )
						ㄴ 어플에서 state가 많은 부분에서 사용되고 state가 많을때
						ㄴ 시간이 지남에 따라 state가 빈번하고 업데이트될때
						ㄴ state업데이트 로직이 복잡할 때
					ㄴ redux는 standalone js 라이브러리이다.
					ㄴ 다른 패키지들과 자주 같이 사용된다.
						ㄴ React-Redux :
						ㄴ Redux Toolkit
						ㄴ Redux DevTools Extenstion
				</pre>
				ㅡ 주요 용어 및 개념<button>더보기</button>
				<pre>
					ㄴ 주요 개념<button>더보기</button>
					<pre>
						ㄴ state 관리
							ㄴ ~~~~~ 그냥 위에서도 나왔던 리덕스의 핵심 개념 이야기.
						ㄴ 불변성 )
							ㄴ 리덕스에서는 모든 state의 업데이트가 불변성을 보장해야한다.
					</pre>
					ㄴ 주요 용어<button>더보기</button>
					<pre>
						ㄴ state )
							ㄴ store에 저장된 데이터를 말함.
							ㄴ plain js value만 할당 할 수 있음. (js객체, arrays, 원시자료형 등만 가능. 함수, class인스턴스 등은 안됨)
						ㄴ actions )
							ㄴ 'type'이라는 필드를 가지고있는 plain js 객체이다.
							ㄴ 리덕스에서 의미상으로 어플에 어떤 일을 발생시키는 '이벤트'라고 봐도 무방하다.
							ㄴ 'type'필드는 해당 action을 표현하는 string값이어야 한다.
								ㄴ 보편적인 형태는 다음과 같다. ex) "todos/todoAdded"
								ㄴ 슬래쉬 앞부분은 기능이나 카테고리를 의미하고, 두번째는 발생한 일을 의미한다.
							ㄴ 'type'필드 이외에 다른 필드들을 추가하여도 된다. 보편적으로 'payload'라는 필드안에 넣는다.
								ㄴ ex )
									const addTodoAction = {
									  type: 'todos/todoAdded',
									  payload: 'Buy milk'
									}
						ㄴ action creators )
							ㄴ action을 반환하는 함수. 이를 따로 만듦으로써 매번 action객체를 만들지 않아도 된다.
							ㄴ ex)
								const addTodo = text => {
								  return {
									type: 'todos/todoAdded',
									payload: text
								  }
								}
						ㄴ reducers )
							ㄴ 리액트 훅의 useReducer( reducer, initialState )에서 reducer와 매우 유사하다.
							ㄴ (state, action) => newState 형태의 함수이다.
							ㄴ 리덕스에서는, 'action'이라는 '이벤트'에 대한 '이벤트 리스너'라고 봐도 무방하다.
							ㄴ reducers가 따라야 하는 규칙 )
								ㄴ state, action에 기반해서만 새로운 state를 계산해야한다.
								ㄴ 기존의 state를 변경해서는 안된다. state의 불변성을 보장해야하므로 새로운 state를 복사하여 업데이트, 반환하는식이어야 한다.
								ㄴ 비동기 로직을 포함해서는 안되고, 랜덤값을 계산해서는 안된다. 'side effect'를 수행해서도 안된다.
								ㄴ 이유 )
									ㄴ 리덕스의 목표중 하나는 코드가 예측가능하도록 하는 것이다. 함수의 결과값이 인풋값에만 영향을 받으면 코드를 예측하기 쉽우며,
										반면, 결과값이 외부의 변수에 의존하거나 랜덤하게 동작하면 예측하기 어렵다.
									ㄴ 함수가 인자를 포함한 다른 값을 수정하면 어플리케이션이 의도치 않게 동작할 위험이 있다.
									ㄴ state의 불변성을 보장하지 않으면,
										ㄴ 업데이트되지 않은 값으로 ui가 보여지거나, state추적이 어려워지거나, 테스트 작성이 어려워지거나, devtool의 'time-travel debuggin'을
											사용 할 수 없게되거나, 리덕스의 핵심 패턴과 정반대로 가게된다.
							ㄴ 전형적으로 reducer는 다음의 로직을 따른다.
								ㄴ reducer가 해당 action에 관련이 있는것인지 체크. 있다면, state를 복사하여 새로운 state를 계산하여 반환.
								ㄴ 관련이 없다면, 기존에 존재하던 state를 그대로 반환.
						ㄴ Store )
							ㄴ 현재 state가 저장되어있는 객체.
							ㄴ reducer를 인자로 받으며 생성 가능하다.
							ㄴ getState() 메소드를 가지고 있으며, 이는 현재의 state값을 반환해준다.
						ㄴ Dispatch )
							ㄴ store는 dispatch() 메소드도 가지고 있으며, 이는 state를 업데이트 할 수 있는 유일한 방법이다.
							ㄴ dispatch()메소드는 인자로 'action'객체를 받는다.
							ㄴ ex ) store.dispatch( { type: 'counter/increment' })
							ㄴ 리덕스에서는, dispatch()를 'action'이라는 '이벤트'를 발생시키는 '트리거'라고 봐도 무방하다.
							ㄴ 전형적으로, dispatch()의 인자로 'action'을 주기 위해 'action creator'를 사용한다고 한다.
								ㄴ ex)
									const increment = () => {
									  return {
										type: 'counter/increment'
									  }
									}

									store.dispatch(increment())
						ㄴ Selectors )
							ㄴ state에서 필요한 값을 가져와주는 일반 함수를 의미함.

					</pre>
					ㄴ 리덕스 어플리케이션의 데이터 흐름<button>더보기</button>
					<pre>
						ㄴ 초기 세팅 )
							ㄴ store가 root reducer를 인자로 받아 생성된다.
							ㄴ store가 맨 처음 한번 root reducer를 호출하고 초기 state를 저장한다.
							ㄴ UI가 이 state를 가지고 처음으로 렌더링된다.
						ㄴ 업데이트 )
							ㄴ dispatch() 호출
							ㄴ store가 reducer호출. state가 새롭게 설정됨.
							ㄴ store가 자신을 '구독'하고 있는 모든 UI 부분들에게 이를 알림.
							ㄴ 해당 store의 데이터가 필요한 UI컴포넌트들은 자신이 필요한 데이터가 변경되었는지 확인.
							ㄴ 필요한 데이터가 변경되었다면, 새 데이터를 사용해 리렌더링.
					</pre>
				</pre>
				ㅡ 기초 사용법 <button>더보기</button>
				<pre>
					ㄴ 리덕스 dev tool )
						ㄴ
					ㄴ 기초 사용법 )
						ㄴ redux toolkit의 configureStore )
							ㄴ store를 생성하는데 사용된다.
							ㄴ 인자로 reducer필드를 포함하는 객체를 넘겨야 한다.
							ㄴ reducer 필드 안에는 reducer들이 들어있는 객체를 넘긴다. 여기에서의 키값은 state의 키값이 된다.
								ㄴ ex)
									import { configureStore } from '@reduxjs/toolkit'
									import counterReducer from '../features/counter/counterSlice'

									export default configureStore({
									  reducer: {
										counter: counterReducer
									  }
									})
								ㄴ 이 경우, state에서 state.counter부분이 생긴다.
								ㄴ 값으로 넘어간 counterReducer는 state.counter부분을 담당하게 된다.
							ㄴ 리덕스에서는 store 설정을 'middleware', 'enhancers'등의 다른 플러그인으로 커스텀 할 수 있게 해준다.
						ㄴ redux Slices )
							ㄴ 'slice'란, state에서 한 feature, category를 위한 로직, action의 모음을 의미한다.
							ㄴ 일반적으로 하나의 파일에 한 slice를 작성한다.
							ㄴ 생성 )
								ㄴ redux toolkit의 createSlice()를 사용하여 생성한다.
								ㄴ ex)
									import { createSlice } from '@reduxjs/toolkit'

									export const counterSlice = createSlice({
									  name: 'counter',
									  initialState: {//state값 초기화에 사용될 필드.
										value: 0//초기화 값을 0으로 설정.
									  },
									  reducers: {
										increment: state => {//'increment'에 해당하는 reducer함수.
										  state.value += 1
										},
										decrement: state => {//'decrement'에 해당하는 reducer함수.
										  state.value -= 1
										},
										incrementByAmount: (state, action) => {
										  state.value += action.payload
										}
									  }
									})

									export const { increment, decrement, incrementByAmount } = counterSlice.actions

									export default counterSlice.reducer
								ㄴ state에서 name에 해당하는 필드가 추가된다.
								ㄴ createSlice()의 인자로 넘긴 객체에 담긴 정보를 가지고 slice가 만들어진다.
								ㄴ name필드는 action의 type에서 앞부분에 해당하고, reducers필드의 키값들은 뒷부분에 해당한다.
									ㄴ 해당 앞부분과 뒷부분이 일치하는 action이 dispatch되면 slice에 정의된 reducer가 호출된다.
								ㄴ slice는 자동으로  action creator를 생성해준다. (*slice명*).actions.(*reducers필드의 타입명*)이 action creator함수이다.
									ㄴ ex) counterSlice.actions.increment()
							ㄴ 내부적으로 'Immer'라는 라이브러리를 사용하여 reducer에서 반환 state의 불변성을 유지하도록 보장해준다.
								ㄴ 따라서, redux toolkit의 createSlice(), createReducer()안에서는 state의 불변성 보장을 위해 별도의 작업을 해 줄 필요가 없다.
								ㄴ 인자로 받은 state를 변경시키기만 하면 알아서 불변성을 보장하며 새 state를 반환해준다.
						ㄴ thunk )
							* Redux middleware<button>더보기</button>
							<pre>
								ㅡ dispatch의 동작을 커스텀 하게 해주는 리덕스 에드온.
								ㅡ Express, Koa 등에서 '미들웨어'란, 프레임워크가 request를 받고 response를 만들어내는 사이에 끼워 넣을 수 있는 코드를 말한다.
								ㅡ 미들웨어의 가장 큰 특징은, 체인형으로 구성 가능하다는 것이다. 즉, 여러개의 미들웨어들을 독립적으로 붙여 구성 할 수 있다.
								ㅡ 리덕스 미들웨어도 이와 유사하다. 'action'을 dispath하고 reducer가 실행되기 사이에 중간지점을 끼워넣는다.
								ㅡ 일반적으로 logging, 비동기 작업 등에 자주 사용한다고 한다.
							</pre>
							ㄴ 개요 )
								ㄴ thunk는 'redux-thunk' 라이브러리의 미들웨어로, 리덕스에서 가장 흔히 사용되는 비동기 미들웨어이다.
								ㄴ 비동기 로직을 담을 수 있는 리덕스 함수.
							ㄴ 사용법 )
								ㄴ 다음 형식에 맞는 plain js function을 정의한다
									ㄴ dispath, getState를 받아 비동기 로직을 수행하는 내부 함수와 이 함수를 반환하는 외부함수로 구성된다고함.
									ㄴ ex)
										const logAndAdd = amount => {//내부함수를 반환하는 외부함수.
										  return (dispatch, getState) => {//dispatch, getState를 인자로 받는 내부함수.
											const stateBefore = getState()
											console.log(`Counter before: ${stateBefore.counter}`)
											dispatch(incrementByAmount(amount))
											const stateAfter = getState()
											console.log(`Counter after: ${stateAfter.counter}`)
										  }
										}

										store.dispatch(logAndAdd(5))
								ㄴ 정의한 thunk함수를 dispath()의 인자로 넘겨준다.
									ㄴ ex) store.dispatch(logAndAdd(5))
									ㄴ 당연히, thunk함수에 인자를 넘길 수도있다.
								ㄴ thunk함수를 dispatch함으로써 thunk함수가 실행되고, thunk함수 내에서 원하는 로직을 수행한 뒤, 인자로 받은 dispatch()를
									이용해 dispatch해주면 된다.
								ㄴ 보편적으로, 관련 'action'이 있는 slice파일에 같이 정의하여 해당 'action'들을 사용할 수 있게 한다고 함.
								ㄴ 보편적으로, state에 'status', 'error'와 같은 이름의 필드를 두어서 비동기 작업의 결과상태를 저장해둔다.
							ㄴ Redux toolkit의 createAsyncThunk() )
								ㄴ ?????
								ㄴ 생성될 action type을 나타내는 문자열과 'Promise'또는 데이터를 반환하는 함수를 인자로 받는다.
									ㄴ ex)
										export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {
										  const response = await client.get('/fakeApi/posts')
										  return response.posts
										})
									ㄴ 첫번째 인자는 createAsyncThunk가 자동으로 생성할 action의 type의 앞부분이다.
										ㄴ 비동기 수행 결과에 따라, 'posts/fetchPosts/pending', 'posts/fetchPosts/fulfilled' 등이 붙는다.
									ㄴ 자동으로 생성되는 action에는 비동기요청에 대한 상태값 등 여러 메타정보가 포함된다.
									ㄴ 요청 성공시, 두번째 인자 함수에서 반환하는 데이터가 action의 payload에 포함되어 reducer에 전달된다.
									ㄴ 두 번째 인자는 실행할 비동기 로직이 포함 된 함수이다.
									ㄴ
								ㄴ 일반적으로 두번째 인자인 함수에서는 ajax을 이용하여 async/await문으로 데이터를 받아온다함.
							ㄴ redux tookit의 configureStore안에 자동으로 포함되어 있다함.
							ㄴ thunk를 standard 사용법대로 사용하기를 권장한다함.
							ㄴ ????? 그냥 형식만 지키면 thunks라는 건지, 왜 이걸 이용해 비동기 로직을 넣으라는 건지 모르겠음. 그냥 일반함수같은데?
							ㄴ ????? 추가 문서 확인 필요
						ㄴ 리액트, 리덕스 )
							ㄴ React-Redux library에는 ㅣㄹ액트 컴포넌트가 리덕스 store와 상호작용할 수 있게해 주는 커스텀 훅들이  들어있다.
							ㄴ 리액트에서는 리덕스 store에 직접 접근할 수 없기 때문에????? 훅을 사용한다.
							ㄴ useSelector 훅 )
								ㄴ 리덕스 'store'에서 필요한 데이터를 추출할 수 있게 해주는 훅.
								ㄴ 리덕스에서는 state에서 필요한 데이터를 가져와주는 함수를 'selector'라는 용어로 불렀다.
									ㄴ ex) export const selectCount = (state) => state.counter.value;
								ㄴ useSelector훅에 리덕스의 'selector'를 넘겨주면 'selector'함수를 store.getState()를 인자로 넘기며 호출하여 결과값을 반환해 준다.
									ㄴ ex) useSelector(selectCount)
								ㄴ 사전에 정의된 'selector'뿐만 아니라 useSelector 훅 인자에 'selector'함수를 정의해도 된다.
									ㄴ ex) useSelector( state => state.counter.value )
								ㄴ 'action'이 dispatch되거나 redux store가 업데이트 되면, useSelector가 'selector'를 재실행하고, 결과값이 다를 경우,
									useSelector가 컴포넌트가 리렌더링 되도록 해준다.
							ㄴ useDispatch 훅 )
								ㄴ ex) const dispatch = useDispatch()
								ㄴ 리덕스 store의 dispatch메소드를 반환해주는 훅. 반환받은 dispatch를 사용하면된다.
							ㄴ 리액트 state와 리덕스 store
								ㄴ 어플 전체에서 사용되는 값들은 리덕스 store에 저장하는게 맞지만, 특정 컴포넌트들만 관심있는 값들은 컴포넌트 state에만 존재하는 게 맞다.
							ㄴ 리액트에 redux store를 제공하는 법 )
								ㄴ 리액트 앱 상위에서 react-redux의 'Provider'를 사용하여 store를 넘겨준다.
									ㄴ ex)
										import store from './app/store'	//단순하게 configureStore()를 통해 store를 생성하고 export하는 js파일.
										import { Provider } from 'react-redux'
										import * as serviceWorker from './serviceWorker'

										ReactDOM.render(
										  < Provider store={store}>
											< App />
										  < /Provider>,
										  document.getElementById('root')
										)
									ㄴ App 하위의 리액트 컴포넌트들에선 useSelector, useDispatch등을 사용하여 redux store와 상호작용 할 수 있다.
				</pre>
				ㅡ
			</pre>
			ㅇ Mobx<button>더보기</button>
			<pre>
				ㅡ 공식 홈페이지 참고 (https://mobx.js.org/README.html)
				ㅡ 설치 및 설정<button>더보기</button>
				<pre>
					ㄴ npm install --save mobx, yarn add mobx
					ㄴ Babel 사용시 )
						ㄴ 바벨최소버전 7.12
						ㄴ ["@babel/plugin-proposal-class-properties", {"loose" : false}]
					ㄴ TypeScript 사용시 )
						ㄴ 컴파일러 옵션 중, "useDefineForClassFields" : true
					ㄴ js버전이 오래된 경우 )
						ㄴ Mobx는 호환성과 최적화를 위해 프록시를 사용한다.
						ㄴ 'Proxy'가 지원되지 않는 js버전의 경우, Mobx는 ES5와 호환되는 버전의 구현체로 변경될 수 있다.
							ㄴ import { configure } from 'mobx'
								configure({ useProxies: 'never' })
						ㄴ 이러한 오래된 버전의 예로는, Edge이전의 인터넷익스플로어, 6이전의 Node.js, 10이전의 iOS, RN 0.59이전의 안드로이드 등이 있다.
					ㄴ mobx의 'decorators'
						ㄴ @observable 과 같은 문법?을 mobx에서 'decorator'라 부르는데, 6버전부터 지양한다고한다. 표준 js와의 호환성을 위하여.
				</pre>

				ㅡ 핵심 개념들<button>더보기</button>
				<pre>
					ㄴ 전체적인 뷰?

					ㄴ Observable state<button>더보기</button>
					<pre>
						ㄴ 프로퍼티, 객체, 배열, map, set 데이터들이 observable 가능하다.
						ㄴ 프로퍼티마다 어노테이션을 명시함으로서 observable 설정을 할 수 있다.
						ㄴ array, map, set같은 컬렉션들은 자동으로 observable이 된다.
						ㄴ 주요 어노테이션
							ㄴ observable : state에 저장되는 값들.
							ㄴ action : state를 수정하는 메소드
							ㄴ computed :
						ㄴ makeObservable )
							ㄴ makeObservable ( (*타겟데이터*), (*어노테이션정보*), (*옵션*) )
								ㄴ (*타겟데이터*) : 어떠한 js object도 가능. class 인스턴스 포함.
							ㄴ (*타겟데이터*)의 존재하는 properties
							ㄴ 일반적으로 makeObservable은 클래스의 constructor에서 사용되면서 (*타겟데이터*)에 this를 넣는다.
							ㄴ ?????
						ㄴ makeAutoObservable )
							ㄴ makeObservable과 유사.
							ㄴ makeAutoObservable( (*타겟데이터*), (*override*), (*옵션*) )
							ㄴ 디폴트로, 모든 properties를 추척한다.
							ㄴ (*override*)인자를 통해 makeObservable에서 하던 것 처럼 properties들을 개별적으로 어노테이션으로 명시할 수 있다.
								ㄴ false를 사용하여 추적대상에서 완전히 제외시킬 수 있다.
							ㄴ 함축된 규칙들 )
								ㄴ 모든 프로퍼티들은 observable이다
								ㄴ 모든 getter는 computed이다.
								ㄴ 모든 setter는 action이다.
								ㄴ 모든 prototype 함수는 autoAction이다.
								ㄴ 모든 prototype의 generator함수는 flow이다.
								ㄴ (*override*)에 false로 표시된 멤버는 아무 어노테이션이 붙지 않는다.
							ㄴ 상속되는 클래스에서는 사용할 수 없다.
						ㄴ observable )
							ㄴ observable어노테이션은 함수로 사용될 수도 있다.
							ㄴ observable( (*타겟데이터*), (*override*), (*옵션*) )
							ㄴ (*타겟데이터*)에 오는 객체는 모든 멤버가 observable이 되며, (*override*)를 통해 개별적으로 선언 할 수 있다. (makeAutoObservable과 유사하게)
							ㄴ observable함수에서 반환되는 객체는 'Proxy'가 된다. 이후에 그 객체에 추가되는 properties들이 똑같이 observable이 됨을 의미한다.

						ㄴ 가능한 어노테이션 목록 )<button>더보기</button>
						<pre>
							ㄴ observable, observable.deep )
								ㄴ
						</pre>

						ㄴ 유의사항<button>더보기</button>
						<pre>
							ㄴ
						</pre>

						ㄴ (*옵션*) <button>더보기</button>
						<pre>
							ㄴ
						</pre>


					</pre>

					ㄴ Actions <button>더보기</button>
					<pre>
						ㄴ state를 수정하는 어떠한 코드조각을 의미.
						ㄴ action은 'transaction'안에서 수행된다. 따라서 수행되는 중에 어떠한 observer도 업데이트 되지 않는다.
						ㄴ action 이외의 부분에서 state를 수정하는 것이 불가하다.
						ㄴ 'state를 수정하는 함수'에서만 'action'어노테이션이 사용되어야 한다. 조회나 탐색, 정렬 등은 해당되지 않는다.
						ㄴ action wrapping function )
							ㄴ action을 이벤트 핸들러로 사용하려는 경우 등을 위해, action은 어노테이션 뿐만 아니라 함수로서 호출하여 action을 만들 수 있다.
							ㄴ ex)
								const ResetButton = ({ formState }) => (
									< button
											onClick={action(e => {
											formState.resetPendingUploads()
											formState.resetValues()
											e.stopPropagation()
										})}
									> Reset form < /button>
								)
							ㄴ 인자와 함께 action함수를 호출 할 수 있으며, 이는 action으로 wrap한 함수를 반환한다.
						ㄴ ????? action.bound )
							ㄴ
						ㄴ runInAction( (*함수*) )
							ㄴ 즉시 호출될 임시 action을 생성할때 사용.
							ㄴ ex)
								import { observable, runInAction } from "mobx"

								const state = observable({ value: 0 })

								runInAction(() => {
									state.value++
									state.value++
								})
						ㄴ ????? action의 상속
							ㄴ prototype에 정의된 action들만 subclass에서 overriden될 수 있다.
						ㄴ 비동기 action )
							ㄴ
						ㄴ flow 어노테이션 )
							ㄴ async, awati에 대한 대안이다.
							ㄴ ?????
						ㄴ

					</pre>

					ㄴ Computeds <button>더보기</button>
					<pre>
						ㄴ computed 어노테이션, computed( (*옵션*) ) 어노테이션, computed( (*함수*), (*옵션*) ) 함수
						ㄴ ~~~~~
						ㄴ 권장 규칙 )
							ㄴ side effect나 다른 observable을 업데이트해서는 안된다.
							ㄴ 새로운 observable을 생성하거나 반환하지 말아라.
						ㄴ (*옵션*) )
							ㄴ
					</pre>

					ㄴ Reactions <button>더보기</button>
					<pre>
						ㄴ ?????
						ㄴ 다음의 api들은 직접 사용되는 일이 매우 드물다. 보통 다른 mobx관련 라이브러리에 (mobx-react 등) 추상화되어 들어있다.
							하지만 mobx이해를 위해 다룬다고함.
						ㄴ 가장 단순한 방법으로 autorun이 있고, 그 이외에 'reaction', 'when'이 있다.
						ㄴ Autorun )
							ㄴ autorun( effect: (reaction) => void )
							ㄴ 관찰중인 것들이 변화하면 매번 실행될 함수를 하나 인자로 받는다.
								ㄴ 관찰중인 것들이란, 앞에서 나온 observable, computed 들
							ㄴ autorun을 생성할 때, 최초로 한 번 실행된다.
						ㄴ Reaction )
							ㄴ reaction( ()=> value, ( value, previoutValue, reaction ) => {sideEffect}, option? )
							ㄴ autorun과 유사하나, observable에 대한 좀 더 세밀한 추적과 실행이 가능하다.
							ㄴ 첫번째 인자인 함수는 두번째인자인 함수에서 사용될 데이터를 반환한다.
							ㄴ 두번째 인자인 함수는 이 반환받은 데이터를 가지고 원하는 로직을 작성하여 실행할 수 있다.
							ㄴ autorun과 달리, 맨 처음 생성시 한번 실행되지 않는다.
						ㄴ When )
							ㄴ when ( ()=> boolean, ()=> void, (*옵션*) 또는 when ( ()=> boolean, (*옵션*) )
							ㄴ 첫번째 함수가 관찰되고 있다가, true를 반환하면 두번째 인자의 함수가 호출된다.
							ㄴ 두번째 함수 인자가 없으면 when은 'Promise'를 반환한다.
						ㄴ Rules )
							ㄴ reaction은 action이 끝난 직후에 동기적으로 실행된다.
							ㄴ autorun은 인자로 넘어온 함수에서 '동기적'으로 실행되는데 사용되는 값들만 추적한다.
							ㄴ autorun, reaction, when으로 전달된 함수들은 그것들이 관찰 중인 객체들이 모두 garbage로 수집될때 그제서야
								garbage로 수집된다. 또는 이들이 반환하는 disposer()함수를 호출하면 된다.
							ㄴ Reaction을 사용할 만한 상황
								ㄴ ????? 직접적인 인과관계가 없는 곳에만 사용하라??
									ㄴ input값들이 입력된 form 을 submit하는 경우와 같이 제한적인 소수의 이벤트, action에 reaction을 사용하는 것보다,
										직접 필요한 effect를 호출하는 게 낫다.
									ㄴ input값들을 매번 입력할 때마다 필요한 로직같은건, 매번 effect를 호출하는 것 보다는 reaction을 사용하는게 낫다.
								ㄴ reaction 안에서는 다른 observable을 업데이트해서는 안된다.
									ㄴ reaction안에서 업데이트 할거면 그 값은 'computed'로 annotated되는 게 맞다.
								ㄴ reaction은 다른 reaction과 독립적이어야 한다.
									ㄴ mobx는 reaction들간의 실행 순서를 보장하지 않는다.
									ㄴ 어떤 reaction이 다른 reaction에 의존적이라면, 두 reaction을 하나로 합치는게 낫다.
						ㄴ (*옵션*) )
							ㄴ ~~~~~

					</pre>
				</pre>

				ㅡ MobX & React <button>더보기</button>
				<pre>
					ㄴ ex)
						import { observer } from 'mobx-react-lite' //또는 'mobx-react'

						const (*컴포넌트명*) = observer( (*props*) => (*리액트컴포넌트*) )
					ㄴ observer )
						ㄴ observer는 리액트의 HoC이다.
						ㄴ 리액트 컴포넌트 렌더링에 사용되는 observable한 모든 데이터를 자동으로 관찰한다.
						ㄴ 관찰되고 있는 값이 변경되면 자동으로 리렌더링 된다.
						ㄴ 컴포넌트 안에서 사용되나, 렌더링 중 사용되지 않는 값들이 변하면 리렌더링을 하지 않는다
						ㄴ 꼭 인자로 넘어간 데이터가 아닌 컴포넌트의 state나 해당 파일의 전역데이터나 리액트의 context에 대해서도 렌더링에 사용된다면 자동으로 관찰하고 리렌더링해준다.
						ㄴ 지역 컴포넌트에 대해 mobx observable을 사용하기보다는, 여러 컴포넌트 사이에서 공유되는 데이터들에 대해 사용하기를 권장한다.
						ㄴ observer는 사용된 해당 컴포넌트에서만 적용되고 그 하위의 컴포넌트에는 자동으로 적용되지 않는다. 따라서 observerable이 사용되는 모든 컴포넌트에 observer를
							붙여주어야 한다.
						ㄴ observer이 아닌 하위 컴포넌트에 observable을 전달하려면 이를 plain js 객체로 변경한 뒤 전달하라고 한다.
							ㄴ ????? 왜 그래야 하는지는 잘 모르겠다. 그냥 observable을 넘겨도 관찰되고 리렌더링 안될뿐이지 오류가 뜨거나 하지는 않는다.
						ㄴ 하위 컴포넌트로 callback함수를 props으로  전달하려 할때, 이 callback함수에 대해서도 관찰이 유지되고 리렌더링이 되기를 바란다면, 그냥 전달하는 것이 아닌,
							< Observer/>로 컬백함수를 감싸서 전달하면 된다. 그럼 해당 콜백함수 안에서의 observable에 대해 관찰이 유지되고 리렌더링이 된다.
							ㄴ ex)
								// WRONG: GridRow.onRender won't pick up changes in todo.title / todo.done
								//        since it isn't an observer.
								return < GridRow onRender={() => < td>{todo.title}< /td>} />

								// CORRECT: wrap the callback rendering in Observer to be able to detect changes.
								return < GridRow onRender={() => < Observer>{() => < td>{todo.title}< /td>}< /Observer>} />
						ㄴ ????? observer는 객체 참조를 전달해 주어 observer안에서 이 객체 참조에 대해 역참조를 하여 동작할 때 가장 잘 동작한다고 한다.
							ㄴ 이는 역참조를 미리 하여 최소한 원시값같은 작은 단위의값을 전달하는게 좋은 react-redux와는 다른 방식이라함.
					ㄴ 최적화 )
						ㄴ ~~~~~
				</pre>
				ㅡ 팁 <button>더보기</button>
				<pre>
					ㄴ data store<button>더보기</button>
					<pre>
						ㄴ 'store'라는 코드모음?을 분리하여서 어플 전체에서 재사용하기 좋고, 테스트하기 좋은 모듈?같은 것을 만들 수 있다.
						ㄴ 일반적으로 '도메인 store', 'UI store'로 분류된다.
						ㄴ 도메인 store )
							ㄴ 어플에서 사용하는 모든 데이터를 저장하는 store를 의미. todo item, use, book, order 등.
							ㄴ 하나의 도메인 스토어는 보통 하나의 도메인을 맡는다. book 도메인 스토어, order 도메인 스토어 등등.
							ㄴ
					</pre>
				</pre>

				ㅡ ex)<button>더보기</button>
				<pre>
					import React from "react"
					import ReactDOM from "react-dom"
					import { makeAutoObservable } from "mobx"
					import { observer } from "mobx-react"

					// Model the application state.
					class Timer {
						secondsPassed = 0

						constructor() {
							makeAutoObservable(this)
						}

						increase() {
							this.secondsPassed += 1
						}

						reset() {
							this.secondsPassed = 0
						}
					}

					const myTimer = new Timer()

					// Build a "user interface" that uses the observable state.
					//observer에 의해 감싸진 부분 안에서 mobx에 의해 이 요소가 timer.secondsPassed란 값에 의존한다는게 자동으로 체크가 되고
					// 이 값이 변할때마다 자동으로 렌더링을 한다고한다.
					const TimerView = observer(({ timer }) => (
						< button onClick={() => timer.reset()}>Seconds passed: {timer.secondsPassed}< /button>
										))

					ReactDOM.render(< TimerView timer={myTimer} />, document.body)

					// Update the 'Seconds passed: X' text every second.
					setInterval(() => {
						myTimer.increase()
					}, 1000)

				</pre>
				ㅡ 이진희님 mobx 코드
					ㄴ 여러 store에 observable객체를 정의하여 store겸 observable로 사용하고 있는 듯 하다.

			</pre>

            ㅇ React Native <button>more</button>
            <pre>
                ㅡ 개요 )
                    ㄴ ??? react 기반의 앱 개발 도구?
                    ㄴ ??? java로 안드로이드 개발하고 swift로 ios개발하듯, react native로 앱 개발
                    ㄴ
                ㅡ ~~~
                ㅡ 'view'라는 react component를 중심으로 앱상의 화면을 구성.
                    ㄴ ImageView, TextView 등, 여러 view 위에 화면 요소들이 구성.
                ㅡ use debugging
                    ㄴ 안드로이드 > 설정 > 디바이스정보 > 소프트웨어정보 > 빌드번호
                ㅡ ~~~
                ㅡ Expo<button>more</button>
                <pre>
                    ㄴ 개요 )
                    ㄴ react-native의 'react-native-create-app' 라이브러리가 통합된 것.
                    ㄴ ~~~
                    ㄴ standalone app 설치
                        ㄴ android
                            ㄴ 프로젝트 루트 디렉토리에서 expo build:android 명령
                            ㄴ 패키지명 입력, 키?관리 등 물어보는 것 체크.
                            ㄴ 빌드 중, 보이는 url로 expo의 빌드 진행 상황 페이지로 들어갈 수 있고, 빌드 완료 후
                                apk앱을 다운받을 수 있다.
                            ㄴ 모바일 기기에서 이를 다운 후 설치.
                                ㄴ 설치시 플레이스토어를 통해 받은 앱은 아니라 여러가지 경고창이 뜸.
                            ㄴ 완료. 앱 실행.

                </pre>

                ㅡ React Native CLI를 통한 시작 )
                    ㄴ nodejs(14이상), jdk(11이상) 설치.
                        ㄴ 설치 안 되어 있을 시, 'chocolatey' 이용 추천한다함
                    ㄴ 안드로이드 스튜디오 설치
                        ㄴ 다운
                        ㄴ 세팅 )
                            ㄴ react native app 빌드에는 android sdk 12가 필요하다함.
                                하여 이를 사용하도록 설정
                            ㄴ ~~~
                    ㄴ react native cli
                        ㄴ react native cli 모듈을 글로벌로 설치하고 관리하기보다, npx react-native (*명령어*) 사용 추천한다함.
                        ㄴ 그때그때 적절한 버전의 모듈을 사용해줌.
                    ㄴ 프로젝트 생성 )
                        ㄴ npx react-native init (*플젝명*)
                    ㄴ 기기에서 실행
                        ㄴ 실 기기에서 실행 )
                            ㄴ 1. 안드로이드폰 > 설정 > 디바이스정보 > 소프트웨어정보 > 빌드번호 7번 클릭
                            ㄴ 2. 설정 > 개발자옵션 항목 추가됨.
                            ㄴ 3. 설정 > 개발자 옵션 > use디버깅 on
                            ㄴ device와 use연결
                            ㄴ 4. cmd에서 adb devices 명령. 장치에서 알림창 허용하고, 연결된 장치목록 확인.
                                ㄴ 장치 목록이 없을 시,
                                    ㄴ 연결 잭이 정상적인지 확인. 종류에 따라 안 되는 잭이 있다?
                            ㄴ 프로젝트 루트 위치에서 npx react-native run-android 실행. (그전에 npx react-native start 먼저???)
                                ㄴ 오류 뜰 경우, 프로젝트 루트/android에서 gradlew clean 후, npm install 로 재설치 후 npx react-native run-android 재실행.
                        ㄴ virtual device

                ㅡ webview 설정
                    ㄴ 해당 프로젝트 루트 위치에ㅓㅅ npm install react-native-webview 실행
                    ㄴ 앱 재시작.
                ㅡ apk 다운
                    ㄴ 프로젝트 루트 / android / app / src / main 에 'assets' 폴더 생성
                    ㄴ 프로젝트 루트 위치에서 다음 명령 실행.
                        npx react-native bundle --platform android --dev false --entry-file index.js
                            --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/
                    ㄴ 프로젝트 루트 / android 에서 gradlew assembleDebug 실행.
                    ㄴ 플젝루트 / android / app/build/outputs/apk/debug 에 apk 생성.
                    ㄴ 디바이스기기로 옮긴뒤 실행하여 앱 설치.

            </pre>
		</pre>
		기타<button>더보기</button>
		<pre>
			ㅇ 웹팩<button>더보기</button>
			<pre>
				ㅡ https://joshua1988.github.io/webpack-guide/webpack/what-is-webpack.html#%EB%AA%A8%EB%93%88%EC%9D%B4%EB%9E%80 참조
				ㅡ 모듈과 모듈 번들링 )
					ㄴ 모듈 : 내가 아는 그 모듈. 함수같이 하나의 기능을 하는 단위같은것. 함수가될수도, 하나의 소스코드전체가 될수도.
					ㄴ 웹팩의 모듈 : 웹 어플리케이션을 구성하는 모든 자원(html, css, image, font 등등)을 말한다.
					ㄴ 모듈 번들링 : 이러한 모듈들을 하나의 파일로 병합, 압축해주는 과정을 말한다.
				ㅡ ~~~~~
			</pre>
			ㅇ 이미지 포멧<button>more</button>
			<pre>
				ㅡ ~~~~~
				ㅡ svg <button>more</button>
				<pre>
					ㄴ ex)
						< svg viewBox="0 0 300 100" xmlns="http://www.w3.org/2000/svg" stroke="red" fill="grey">
						  < circle cx="50" cy="50" r="40" />
						  < circle cx="150" cy="50" r="4" />

						  < svg viewBox="0 0 10 10" x="200" width="100">
							< circle cx="5" cy="5" r="4" />
						  < /svg>
						< /svg>
					ㄴ 그래픽을 그래는데 사용되는 xml 언어.
				</pre>
			</pre>
		</pre>
	</pre>
	<br>back-end<button>더보기</button>
	<pre>
		서버단<button>더보기</button>
		<pre>
			ㅇ 정적 vs 동적 웹사이트
				ㅡ 바뀌지않고 고정된 사이트를 정적 웹사이트.
				ㅡ 요청에 따라 필요할때 동적으로 생성되어 전달되는 페이지를 동적 웹사이트라함.( 가령 html탬플렛에 사용자에 따라 적절한 db를 입력하여 반환하거나)
					이때 사용되는 코드는 서버에서 실행되어야하고 이런 코드를 만드는것을 '서버 사이드 프로그래밍' 이라고한다.
				ㅡ 서버사이드 프로그래밍은 다양한 언어로 작성이 가능하다(PHP, Python, Ruby 등등)

			ㅇ 서버측 프로그래밍의 쓰임
				ㅡ 개별 사용자에 맞게 효율적 정보전달, 사용자 경험 향상.
				ㅡ 항목이 많고 데이터가 많아졌을때, 그 각각에 대해 모두 정적페이지를 만드는건 매우 비효율. 이럴때 쓰인다.
				ㅡ 편안한 사용자 경험을 위해 사용자의 정보를 저장하거나 하는데 사용
				ㅡ 사용자만 접근할수있는 정보제공
				ㅡ 특화된 알림기능
				ㅡ 정보 분석 수집.

			ㅇ 서버사이드측 작동방식
				ㅡ 웹 브라우저는 링크를 클릭하거나, form을 전송하거나, 검색을 하는 등을 할대 HTTP request라는것을 서버에 전송.
				ㅡ 이 request에 포함되는내용들은 URL,  메소드, 매개변수가 있다.
				ㅡ 메소드의 정류에는
					ㄴ GET : 특정 리ㅣ소스를 얻는다.
					ㄴ POST : 새 리소스를 만든다.
					ㄴ HEAD, PUT, DELETE, TRACE, OPTION, CONNECT, PATCH 등이 잇다.
				ㅡ 매개변수에는
					ㄴ ex) http://mysite.com ? name = Fred&age=11 과 같이 GET방식에서 물음표(?)뒤에 붙어서 전달되는것들을 말한다.
				ㅡ 요청에 대한 응답시에는 요청 성공여부를 나타내는'HTTP Response status code'를 포함하여 보낸다. (ex)200은 성공, 404는 not Found 등)

			ㅇ 서버란?
				ㅡ 웹페이지 : html페이지 하나를  의미.
				ㅡ 웹 사이트 : 관련있는 웹페이지들의 그룹.
				ㅡ 서버 : 일종의 저장소역할을 하는 컴퓨터같음. client에 해당하는 컴퓨터들이 접근하고 쓸수있는 정보를 저장하고, 제공하고, 더 나아가 그 정보에 적당히 처리도해주고
					client관리도하는 그런컴퓨터.
				ㅡ 사람들이 호스팅하거나 직접서버를 만들어 이 서버에 웹페이지나 정보를 올리면 다른 클라이언트가 접속할수있다.
				ㅡ WAS(Web Application Server) : 서버는 서버인데 '웹 컨테이너'라는게 추가되어 다양한 기능도 가능한 서버를 말한다.

			ㅡ 웹 서버
				ㄴ iis, 아파치, nginx 등
				ㄴ 경로 )
					ㄴ 웹서버는 클라이언트로부터온 url을 파일시스템의 자원이나 프로그램 이름으로 매핑할 수 있다.
					ㄴ 정적 요청의 경우, 웹서버의 루트 디렉토리를 기준으로 상대경로로 매핑되고
				ㄴ 웹 서버는 커널모드와 유저모드로 나뉘어져 있을 수 있다.
				ㄴ 웹서버는 load limit를 가진다. ip주소 하나당 모통 2~80000개의 연결.
			ㅡ 어플리케이션 서버
				ㄴ 웹 서버와 같이 그냥 똑같은 서버인데 하는 일에 따라 조금씩 다르게 부르는 정도인 듯 하다.
				ㄴ 웹 서버는 http의 정적인 파일들을 다루는 서버,
				ㄴ 앱 서버는 http뿐만 아니라 다른 것들도, 그리고 동적인 파일들을 다루는 서버를 말한다.
			ㅡ 웹 브라우저
				ㄴ www의 정보에 접근하기 위한 일종의 소프트웨어 어플리케이션.
				ㄴ 유저가 특정 요청을 보내면 웹서버로부터 해당 content를 받아 화면에 뿌려주는 기능을 한다.

			ㅇ 가상 호스트
				ㅡ 하나의 서버에서 여러개의 호스트가 있는것처럼 사용하게 해주는 기술.
				ㅡ 가령, 어떤 url로 요청이들어오면 이에 해당하는 가상호스트가 있을시, 이 가상호스트의 conf내용들을 적용해 처리하는 식.
				ㅡ 아파치의 경우, httpd.conf파일에 < VirtualHost>를 설정함으로서 가상호스트 설정이 가능하다.

			ㅇ 서버 동작 방식
				* nic란?
					ㄴ nic, network interface card. 통상 '랜카드'
					ㄴ 컴퓨터가 네트워크를 통해 데이터를 주고받을 수 있게해주는 하드웨어.
						ㄴ 랜선 꽃는곳 바로 뒤에 들어있는 카드.
					ㄴ osi계층에서 물리계층에 해당한다.
				* nic 드라이버란?
					ㄴ 드라이버란 os와 장치가 커뮤니케이션하게해주는 프로그램.
					ㄴ nic드라이버는 osi 계층에서 데이터링크층과 네트워크층에 해당한다.
				* 인터럽트
					ㅡ 아는 그대로고,
					ㅡ 하드웨어인터럽트의 경우, 어떤 칩이 있어서 이를 통하여 인터럽트의 발생을 알린다함.
				* 소켓 인터페이스
					ㅡ 컴퓨터 통신을 위해 커널단에서 제공하는 api.
				ㅡ 네트워크로 데이터가 들어오면 랜카드가 인터럽트를 발생시키고, 이를 통해 요청이 처리가 된다.
				ㅡ 내부적으로 소켓 인터페이스를 사용한다.
				ㅡ tcp를 통해 특정 포트로부터 listening하고 있는걸 '서버'라고 한다. 여기서 어떤 프로토콜이 적용되었느냐에따라 어떤서버인지 달라지는것.(ftp server, http server...)
					ㄴ https://stackoverflow.com/questions/38712164/difference-between-socket-and-web-server-example
					ㄴ ex) http요청을 받아서 처리해주는 httpd라는 '데몬프로그램'이 listening을 하고있다가 요청이 들어오면 이를 처리해준다.
						http프로토콜 패킷형식에 맞게 패킷을 분석하여 처리해준다. (헤더부분의 method부분엔 무슨 스트링값이들어있는지(GET인지 POST인지) 등등)

			ㅇ Apache Server<button>더보기</button>
			<pre>
				ㅡ https://httpd.apache.org/docs/ 참조.
				ㅡ 직접 컴파일해서 사용해야하지만 그러지 못하는 사람들을 위해 많은 바이너리 실행파일 배포 페이지들이 있다.
					ㄴ 내경우 Apache Lounge에서 다운받았다.
				ㅡ 아파치 서비스 실행)
					ㄴ 먼저 서비스 설치를 해야하고 이는 httpd.exe -k install 로 가능. (아파치의 bin폴더안에서해야한다)
					ㄴ 서비스 시작 종료는 httpd.exe -k start, stop

				ㅇ centos7에서 아파치 )
					ㅡ yum으로 설치하였고
					ㅡ /etc/httpd안에 서버 설정파일들이 들어있음
						ㄴ /etc/httpd/conf/httpd.conf가 설정파일
						ㄴ 이 외에도 log, module등에 대한 것들이 들어있다.
					ㅡ /var/www/html가 기본적인 DocumentRoot이고 이는 요청들어오면 기본적으로 소스 찾는 위치.
						ㄴ DocumentRoot는 /etc/httpd/conf/httpd.conf에서 설정할 수 있다.
					ㅡ 관련 명령어 )
						ㄴ 아파치 서버 실행 : systemctl start httpd
						ㄴ 아파치 서버 재시작 : systemctl restart httpd
						ㄴ 아파치 서버 상태확인 : systemctl status httpd

				ㅇ 아파치 파일 구성 )
					ㅡ conf 파일 )
						ㄴ 지시자 : http://httpd.apache.org/docs/2.4/mod/directives.html 참조.


				ㅇ 아파치 톰캣 연동
					ㅡ http://tomcat.apache.org/connectors-doc/, https://tomcat.apache.org/connectors-doc/webserver_howto/apache.html 참조

					ㅡ 아파치의 경우 mod_jk, IIS의 경우 ISAPI redirector 등의 모듈이 존재. 이를 이용해 연동.
					ㅡ 톰캣과 다른 웹서버를 연동할 수 있는 플러그인을 제공하고 있으며, AJP라는 프로토콜을 사용하여 아파치 웹서버로 들어오는 요청을 톰캣 컨테이너에게 보낸ㄴ다.

					ㅡ worker 란?  웹서버를 대신해 서블릿이나 다른 컨텐츠들을  실행시켜주기위해 대기하고있는 톰캣 인스턴스라고 한다.
						ㄴ 일반적으로 여러개의 worker를 둔다고한다. 이유는..
							ㄴ We want different contexts to be served by different Tomcat workers to provide a development environment where all the developers share the same web server but own a Tomcat worker of their own.
							ㄴ We want different virtual hosts served by different Tomcat processes to provide a clear separation between sites belonging to different companies.
							ㄴ We want to provide load balancing, meaning run multiple Tomcat workers each on a machine of its own and distribute the requests between them.
						ㄴ worker에 대한 정의는 workers.properties라는 파일에서 설정된다.
					ㅡ 설정하기 )
						ㄴ 자동설정?? )
							ㄴ 자동적으로 톰캣연동 설정이 가능하다고 한다. 이를 Tomcat auto-configure이라고함.
							ㄴ 설정을 위해 conf.properties파일에 들어갈 명령어 => Include c:/Apache/Apache24/conf/jk/mod_jk.conf-auto
						ㄴ 커스텀 설정 )
							ㄴ 기본설정 )
								JkWorkersFile ${SRVROOT}/conf/workers.properties	=> worker가 정의된 파일을 가리켜주는 지시자.
								JkLogFile ${SRVROOT}/logs/mod_jk/mod_jk.log		=> mod_jk가 로그를 기록할 파일을 가리키는지시자
								JkLogLevel error			=> 로그 레벨설정. info : 스탠다드 로그정보, error : 에러기록, debug : 모든 정보.
								JkLogStampFormat "[%y-%m-%d %H:%M:%S.%Q]"	=> 로그기록할때 시간기록 형식 설정하는 지시자

							ㄴ??? forwarding 옵션들 )
								ㄴ forwarding과 관련된 여러 옵션들을 설정 할 수 있다.
								ㄴ JkOption +ForwardURIProxy
								ㄴ JkOption +ForwardURICompat
								ㄴ 등등..
							ㄴ 톰캣으로 보낼 uri 할당 )
								ㄴ JkMount (*uri prefix*) (*worker이름*)
								ㄴ uriworkermap.properties 설정할때와 비슷한 형식.
							ㄴ 아파치 서버가 처리할 파일들 설정 )
								ㄴ JkUnMount 지시자를 통해 톰캣이 아닌 아파치 서버가 처리할 파일들(보통 static파일들)을 설정해줄수있다.
								ㄴ JkUnMount 형식은 JkMount와 같다.
								ㄴ 보안상의 이유로 일단 모든 url을 JkMount로 설정하고 JkUnMount로 제외시켜주는 방식을 사용하라한다.
							ㄴ Alias, no-jk, JkAutoAlias 등등..
						ㄴ ???mod_jk 빌드 )
							ㄴ ...
					ㅡ workers.properties configuration파일 )
						ㄴ mod_jk의 worker에 대해 정의하는 파일로, 필수적으로 잇어야 하는 파일이다.
						ㄴ 기본 )
							ㄴ (*이름*)  = (*값*) 형태
							ㄴ 주석은 해쉬태그 #
						ㄴ http://tomcat.apache.org/connectors-doc/reference/workers.html
							ㄴ 위링크에 자세한 프로퍼티들이 나와있음.
							ㄴ 대략 worker.list 로 worker인스턴스를 선언?하고, 이에 해당하는 directive들을 설정하여 worker를 설정하는방식.
						ㄴ ex)
							worker.list= worker1 =>worker1이란 워커 선언
							worker.worker1.type=ajp13	=>아래로쭉 worker1에 대한 directive들을 설정하고 있다.
							worker.worker1.port=8009
							worker.worker1.socket_timeout=180
							worker.worker1.reply_timeout=180000
					ㅡ uriworkermap.properties 파일)
						ㄴ 기억하던대로, 어떤 uri요청이들어오면 처리를 넘겨줄지 설정하는 파일이다.
						ㄴ http://tomcat.apache.org/connectors-doc/reference/uriworkermap.html
						ㄴ 아파치에선 conf.properties파일 안에서 JkMount 지시자를 통하여 설정하여도 된다.
					ㅡ ??? status worker )
						ㄴ 요청을 forward하는 기능이 아닌 런타임시에, configuation정보나 상태를 가져오거나 이를 동적으로 변경하는 기능을 한다함.


			</pre>

			ㅇ Nginx server<button>more</button>
			<pre>
				ㅡ ~~~~~
				ㅡ 설정 파일<button>more</button>
				<pre>
                    ㄴ 주석 ) '#' 뒤로 오는 내용은 주석 취급.
                    ㄴ
					ㄴ ex )<button>more</button>
					<pre>
						user  nginx;
						worker_processes  auto;

						error_log  /var/log/nginx/error.log notice;
						pid        /var/run/nginx.pid;

						events {
							worker_connections  1024;
						}

						http {
							include       /etc/nginx/mime.types;
							default_type  application/octet-stream;

							log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
											  '$status $body_bytes_sent "$http_referer" '
											  '"$http_user_agent" "$http_x_forwarded_for"';

							access_log  /var/log/nginx/access.log  main;

							sendfile        on;
							#tcp_nopush     on;

							keepalive_timeout  65;

							#gzip  on;

							include /etc/nginx/conf.d/*.conf;  # 해당 위치의 *.conf 형태의 파일을 모두 이 위치에 포함시킴.

							server {  # server directive. 하나의 가상 서버에 대한 설정을 나타냄.
                                    # nginx 서버가 어느 포트를 listening할지. 'default_server' 입력시, 가상서버들 중 request와 매칭되는 서버가 없을시 이 디폴트 서버가 요청을 처리.
									listen 80 default_server;
									server_name divlab.io;  # ???해당 ip로 들어온 request가 어떤 도메인명을 타고 왔는지를 체크하여 여기에 명시된 도메인인 경우 매핑시킨다.

									# location = /favicon.ico {
									#         access_log off; log_not_found off; }

									location /static {  # url이 '/static' 형태로 들어올 시, 응답을 어느 위치에서 찾아서 반환해줄지 설정.
											alias /opt/deepqapps/static;
									}

									# location /adm {
									#       alias /opt/branddesign/bdak/media/adm/data;
									# }

									# location /media {
									#       alias /opt/branddesign/bdak/media;
									# }

									# location / {
									#       proxy_set_header Host $http_host;
									#         proxy_set_header X-Real-IP $remote_addr;
									#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
									#         proxy_set_header X-Forwarded-Proto $scheme;
									#         proxy_pass http://unix:/tmp/gunicorn.sock;
									# }

									location / {  # url이 일치하는게 없으면 이 기본형 '/'에 매핑된다.
											proxy_pass http://divlab.io:8888;  # 프록시 설정. 여기에 매핑된 요청을 해당 주소로 보내준다.
                                            # 위 row제거후 이 row사용시, location에 대한 요청 들어오면 해당 url로 리다이렉트시킴.
                                            # $request_uri는 url뒤의 모든 인자 포함.
                                            #return 301 https://divlab.io$request_uri
									}
							}

                            server {
                                listen 443 ssl;  #
                                server_name bbdlab.kr;

                                ssl_certificate /etc/nginx/chain.crt;  # 도메인 인증서-체인인증서-루트인증서의 결합파일.
                                ssl_certificate_key /etc/nginx/www_bbdlab.kr.key;  # 인증서 신청 때 생성한 crs와 같이 나온 개인키. (암호화 해제되어 있어야 한다)

                                #ssl_session_cache shared:SSL:1m;  # ???
                                #ssl_session_timeout 5m;  # ???

                                #ssl_ciphers HIGH:MEDIUM:!SSLv2:!PSK:!SRP:!ADH:!AECDH;
                                ssl_prefer_server_ciphers on;

                                location / {
                                        proxy_pass http://127.0.0.1:8000;
                                }
                                error_page 500 502 503 504 /50x.html;
                                location = /50x.html {
                                        root /usr/share/nginx/html;
                                }
                            }
						}
					</pre>
                    ㄴ request와 가상서버 매핑 방식
                        ㄴ request의 header의 'host'만을 보고 이 요청을 처리할 가상서버 결정.
                        ㄴ host의 ip, port를 먼저 보고 매칭되는 가상 서버를 찾고 그 다음 server_name을 매칭시킴.
                        ㄴ ~~~
                        ㄴ http://nginx.org/en/docs/http/request_processing.html 참고.
                    ㄴ server_name
                        ㄴ http://nginx.org/en/docs/http/server_names.html 참고.
                    ㄴ ssl 설정<button>more</button>
                    <pre>
                        ㄴ 필요한 파일은 'ssl_certificate', 'ssl_certificate_key' 속성에 경로를 넘겨줄 두개의 파일.
                            인증서 파일과 개인키
                        ㄴ 개인키는 인증서 신청시 csr파일과 함께 만들어진 개인키를 말함.
                        ㄴ 인증키 파일은 '도메인 인증서' - '체인 인증서' - '루트 인증서' 순서로 구성되어야 한다.
                            ㄴ ??? 순서는 인증서 종류?마다 다른 것 같다.
                            ㄴ 대략 형식이 다음과 같은데
                                -----------BEGIN CERTIFICATE------------
                                IIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
                                A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
                                b3QgQ0ExGzAZBgNVBAMTEkd~~~~~~~~
                                -----------END CERTIFICATE--------------
                                -----------BEGIN CERTIFICATE------------
                                MIIETTCCAzWgAwIBAgILBAAAAAABRE7wNjEwDQYJKoZIhvcNAQELBQAwVzELMAkG
                                A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
                                b3QgQ0ExGzAZBgNVBAMTEkdsb2Jhb~~~~~~~~~~
                                -----------END CERTIFICATE--------------
                            ㄴ  -----------END CERTIFICATE--------------
                                -----------BEGIN CERTIFICATE------------
                                위 부분이 다음과 같이 옆으로 붙어있거나
                                -----------END CERTIFICATE-------------------------BEGIN CERTIFICATE------------
                                다음과 같이 한 줄 떨어져 있지 않도록 주의해야함.
                                -----------END CERTIFICATE--------------

                                -----------BEGIN CERTIFICATE------------
                        ㄴ ssl 인증서 신청. 인증서 파일 및 개인키 확보 )
                            ㄴ ssl서비스를 가비아 등의 업체에서 구매하고 필요한 정보를 전달하여 신청, 인증서 발급 과정을 통해
                                ssl설정에 필요한 인증서파일, 개인키 등을 얻을 수 있다.
                            ㄴ 이 인증서 파일들은 가비아 등 ssl 업체에 인증서를 구매 및 신청하여 받을 수 있다.
                            ㄴ 신청 방법이나 전달받을 인증서 파일들의 형태는 업체별로 상이하다. 각각 확인 필요.
                            ㄴ 대략 공통적으로 아주 간략하게 다음의 과정으로 진행된다.
                                1. csr, 개인키를 생성하여 ssl 인증 업체에 전달하여 신청,
                                2. 인증 업체에서 인증서 파일들을 반환.
                                ㄴ 1번은 서버에서 openssl등의 명령어로 직접 생성할 수도, 업체 사이트에서 form으로 입력할 수도 있다.
                                ㄴ 1번 csr 생성시 대략 다음의 정보를 입력하여 csr파일을 생성한다.
                                    Country Name ( 국가코드) [] : KR
                                    State or Province Name ( 지역 ) [] : Seoul
                                    Locality Name ( 시/군/구 ) [] : Seocho
                                    Organization Name ( 회사명 ) [] : 회사명 Inc
                                    Organizational Unit Name ( 부서명 ) [] : Develop Team
                                    Common Name ( 서비스도메인명 ) [] : www.domain.com
                                    Email Address [] : 현재 도메인 소유자의 이메일 주소
                                ㄴ 2번은 인증서 파일들이 묶음으로 올 수도, 낱게로 올 수도 있다.
                            ㄴ 리눅스 서버, 가비아 신청의 예를 들자면,
                                서버에서 openssl 명령어로 인증서 개인키, csr(인증서 요청파일)을 생성,
                                가비아에서 ssl서비스 결재 후 위 파일들 전달하여 신청,
                                가비아에서 도메인 인증서, 체인 인증서, 루트 인증서 반환.
                        ㄴ SNI 설정 관련
                            ㄴ nginx -V 명령어 입력시, 중간에 "TLS SNI support enabled"라는 문구 존재시, SNI 기능을 지원하는 상태.
                                ㄴ 지원하지 않는다면 다음과 같은 경고문구 존재.
                                    nginx was built with SNI support, however, now it is linked
                                    dynamically to an OpenSSL library which has no tlsext support,
                                    therefore SNI is not available
                    </pre>

				</pre>

				ㅡ gunicorn 연동<button>more</button>
				<pre>
					ㄴ ~~~~~
					ㄴ nginx에서 프록시 설정으로 요청을 gunicorn 포트로 넘겨줌으로서 연동.
					ㄴ
				</pre>

			</pre>

		</pre>
		Servlet<button>더보기</button>
		<pre>
			기본<button>더보기</button>
			<pre>
				ㅇ 서블릿이란?
					ㅡ 웹 어플리케이션(동적 웹페이지를 만드는데 쓰이는 프로그램)을 프로그래밍하는데 쓰이는 기술을 말함.
					ㅡ '서블릿 클래스'라고하는 클래스를 이용하여 프로그래밍을 하며
					ㅡ 핵심문법은 다음과같다.
						ㄴ 서블릿 클래스는 javax.servlet 패키지의 Servlet인터페이스를 구현해야한다.(보통 편의를 위해 이를구현하는 javax.servlet.http.HttpServlet클래스를상속)
						ㄴ 서블릿 클래스안에 doGet()또는 doPost()메소드를 선언하고 이 안에 클래스가 호출되었을때 할일을 정의해야한다. 이 두 메소드는 두개의 인자를받아야하는데 첫번째는
							javax.servlet.http.HttpservletRequest, 두번째는 javax.servlet.http.HttpServletResponse이다. 예외처리또한 java.io.IOException과
							javax.servlet.ServletException을 던져야한다.
						ㄴ 위 두 메소드의 두번째 인자에 대해 getWriter()를 호출하면 PrintWriter라는 스트림 객체가 반환되고 이 객체에 대해 print,println등을 사용하여 웹브라우저로
							html코드를 출력시킨다. 이런식으로 동적페이지를 브라우저에 반환한다.
					ㅡ 서블릿 클래스는 일반자바와 똑같이 javac.exe에 의해 컴파일 되며 컴파일결과물은 웹서버의 폴더에 저장해야한다. 그리고 웹서버에 url과함게 서블릿 클래스를 등록하고나면
						후에 웹브라우저로부터 url이 전달되면 서버는 그에 해당하는 서블릿 클래스를 호출한다.
					ㅡ "서블릿 클래스" --(인스턴스화)--> "서블릿 객체" --(초기화)--> "서블릿"
						ㄴ 위순서로 진행되며, 인스턴스화와 초기화는 웹컨테이너가 자동으로 처리해준다.

				* CGI, Common Gateway interface
					ㅡ 개요 )
						ㄴ 서블릿 이전에 동적 웹 컨텐츠를 만들기위해 쓰이던 기술.
						ㄴ 이 기술을 통해 웹서버가 특정 요청들을 외부의 프로그램으로 전달하게 되고, 그 프로그램의 결과값은 클라이언트로 보내지게된다.
					ㅡ CGI는 좋지않은 라이프 사이클을 가지고 있다고한다.
						ㄴ 웹서버가 CGI로 보내져야하는 요청을 받으면 새로운 프로세스를 생성하여 CGI프로그램을 돌려야 한다함.
						ㄴ 모든 요청에 대한 이러한 과정은 당연히 자원을 많이먹어 부하가큼.
						ㄴ 또한 별개의 프로세스를 사용하기때문에 웹서버와 상호작용이 불가하다함.
					ㅡ FastCGI
					ㅡ ...

				ㅇ 서블릿 장단점
					ㅡ 장점)
						ㄴ 자바로 만들엇기때문에 자바의 장점인 '이식성'
							ㄴ 자바로 만들었기때문에 jvm위에서 동작하며,
							ㄴ 다른 CGI와 달리 매번 새 프로세스를 생성하는게 아니라 jvm위에서 쓰레드를 생성하여 처리하기때문에 부학 적다.
							ㄴ portable하다한다. os에 관계없이 대부분의 웹서버에서 지원을 한다함.
						ㄴ 네트워크 보안 용이
						ㄴ 프로그래밍 언어 수준의 '멀티스레드 지원'
					ㅡ 단점)
						ㄴ print를 이용해 html코드를 만들어야해서 매우복잡하고 이해도 어렵고 유지보수도 어렵고 디자이너와의 협업도 어려움.

				ㅇ 서브릿의 멀티스레드/ 싱글스레드
					ㅡ 서버는 여러 사용자로부터 동시에 요청을 받을수있고 이를 처리하기위한 방법으로 멀티/싱글 스레드 모델이 있다.
					ㅡ 멀티스레드 모델)
						ㄴ 서블릿 클래스가 서블릿을 단 하나 만들며,
						ㄴ 멀티스레드를 이용해 요청들을 처리.
						ㄴ 멀티스레드이므로 데이터충돌이 일어날수있지만 서블릿이 하나이기때문에 시스템자원과메모리효율이 좋다.
						ㄴ 멀티스레드이므로 이 모델에서 서블릿클래스에 멤버변수 사용 지양.
					ㅡ 싱글 스래드 모델)
						ㄴ 서블릿 클래스가 서블릿을 여러개 만듦.
						ㄴ 따라서 스레드는 하나면되고 각각의 서블릿들이 각자의 요청들을 처리.
						ㄴ 멀티스레드모델의 장단점의 반대이면서,
						ㄴ 사용자가 늘어날수록 단점이 너무 심각해져 현재 폐용화.

				ㅇ 서블릿 클래스 상속구조
					<img src="image/서블릿 클래스 상속구조.png" style="height:300px; width:auto;">

				ㅇ 서블릿 클래스 만들기
					import javax.servlet.http.*;
					import javax.servlet.*;
					import java.io.*;	=>필요한 클래스, 인스턴스들을 가져와준다.

					public class (*서블릿클래스이름*) extends HttpServlet {		=>웹컨테이너가 요청에따라 메소드를 호출할수있게 public으로 선언. 그리고 서블릿클래스는
																				앞에나온대로 HttpServlet을 상속해줌.
						public void do(*Get 또는 Post*)(HttpServletRequest (*변수명.request*), HttpServletResponse (*변수명.response*))
																							=>doGet이나 doPost중 하나를	오버라이딩해야하며, 매개변수형식도 지켜야함.
							throws ServletException, IOException {		=> 던져야하는예외들도 지켜야함.
							~~~
							(*서블릿에서 실행할내용들*)	=>메소드 내용들로 서블릿이 호출되었을때 할 작업들을 작성해주고.
							~~~
							PrintWriter (*변수명.out*) = response.getWriter();	=> 앞서나온내용대로 PrintWriter 객체를 받아 html코드를 출력해 브라우저로 반환해줌.
							out.println("< html>");
							~~~~
						}
					}

				ㅇ 서블릿 클래스 컴파일하기
					ㅡ javac으로 그냥 컴파일하면되는데 코드에서 사용된 import된것들은 표준라이브러리에 없는것들이므로 추가해주어야한다.(tomcat에 jsp-api.jar, servlet-api.jar에 들어있다)
					ㅡ 방법1)
						ㄴ 이클립스에서 프로젝트명 오른쪽클릭 - Properties - Java Build Path - Libraries - 'Add External JARs' - tomcat폴더에 lib에있는 위 jar들 추가.
					ㅡ 방법2)
						ㄴ jdk에서 외부라이브러리들을 저장하는곳인 jdk - jre - lib - ext 폴더에 해당 jar들을 복사해줌.
					ㅡ 방법3)
						ㄴ javac 명령어입력시 옵션으로 -cp를 주어 라이브러리 경로를 전달해줌.

				ㅇ 서블릿 클래스 설치하기
					ㅡ tomcat을 이용
					ㅡ webapps폴더 안에 'WEB-INF'라는 이름의 폴더를 만들고 그안에 'classes'라는 폴더를 만들고 이곳에 서블릿 클래스파일을 저장하면된다.

				ㅇ 서블릿 클래스 등록하기
					ㅡ 서블릿은 jsp와 달리 파일을 폴더에 갖다놓기만하면되는게 아니고 따로 '등록'의 과정을 거쳐야 사용할수있다.
					ㅡ 웹 어플리케이션의 DD(deployment descipter)라는 파일에 등록을하는데 WEB-INF폴더 안에 'web.xml'이란 파일로 위치와이름이 정해져있다.
						이 파일을 위 정확한 위치에 생성하고 작성하고 서블릿을 그 안에 등록해야 등록이 완료된다.
					ㅡ xml파일만들기)

						< web-app xmlns = " (*파일작성에 사용된 문법의식별자*) " version = "(*버전정보*) ">	=>< web-app>은 html파일의 < html>같은것. 루트엘리먼트.
																									=>잘모르겟지만 xmlns와 version 속성은 필수라한다.
							< servlet>
								< servlet-name> (*이름a*) < /servlet-name>	=>여러 서블릿들이 등록될텐데 이들을 구분하기위한 식별자역할을한다.
								< servlet-class> (*패키지명을 포함한 서블릿 클래스이름*) < /~~>
							< /servlet>
							< servlet-mapping>
								< servlet-name> (*이름a*) < /~~>	=>위에 < servlet>안에있는 < servlet-name>과 연결된다.
								< url-pattern> (*url*) < /~~>		=> 전체 url이 아닌 서버도메인, 포트, 웹 어플리케이션 폴더이름을 제외한 나머지를 입력한다.
							< /~~>
						< /web-app>

					ㅡ 대략적인 동작방식)
						ㄴ 설정해둔 url을 요청받으면 이 DD파일에서 같은 url을 찾는다.
						ㄴ 찾으면 해당 url이 있는 < url-pattern>과 같이있는 < servlet-name>의 값을 확인하고 < servlet>안에서 이와 같은 값의 < servlet-name>을 찾는다.
						ㄴ 찾은 < servlet-name>과 같이있는 < servlet-class>를 실행시킨다.
					ㅡ 새로운 서블릿을 작성하게되면 똑같은 방식으로 < servlet>, < servlet-mapping>요소를 작성해 등록하면된다.

				ㅇ 서블릿 클래스에서 한글인코딩)
					ㅡ 서블릿에서 브라우저로 페이지를 반환할때 한글을쓰려면 인코딩을 해주어야한다.
					ㅡ doGet, doPost의 매개변수 response에 대해 setContentType()을 호출하여 브라우저로 응답하는 페이지의 한글을 인코딩해준다.
					ex)	response.setContentType("text/html; charset=UTF-8");	=>text/html은 이문서의 내용이 text형이고 html문법으로 작성됨을 의미. UTF-8은 인코딩할문자셋.

				* 웹 어플리케이션 개발하기 팁)
					ㅡ 먼저화면 구성을 생각하고
					ㅡ 각각의 url을 미리정한뒤 코딩을 시작한다.

				* html의 form요소
					ㅡ < form>요소에 action속성값으로 url을 정해두면
					ㅡ < form>안에 여러값들을 입력받은뒤 < input type="submit">을 통해 값들을 해당 url로 매개변수로 붙여 요청을 보낼수있다.
					ㅡ ex)	< form action="(*url*)" method = (*GET방식 또는 POST방식*) >
								< input type="text" name="id">
								< input type="submit">	=>id란 이름의 파라미터가 요청url에 매개변수로 붙어서 전달된다.
							< /form>
			   		ㅡ 보낸 값들은 서블릿에서 doGet,doPost메소드의 첫번째인자 request에대해 getParameter("(*넘겨받은 값의 name속성값*) ")을 통해 가져올수있다.
			   		ㅡ 다양한 form 형태들)
			   			ㄴ < form>태그로 입력할수있는 형태는 다양하다. < input type=(*타입*)>에서 타입도 다양하고 이외에도 radio, checkbox, < select>등등.
			   			ㄴ 구체적으로 어떤식으로 데이터가 받아지는지 그냥 그때그때 검색해보고, 대략적으론 다음과같다.
			   				ㄴ name속성값이 다르면 각각의 name속성값에 해당하는 value값들이 반환되고, name속성값을 공통으로 쓰는 타입의 경우 그 입력된 값들이 모두 반환된다.

			   	ㅇ Get방식과 Post방식
			   		ㅡ 위처럼 form태그를 통해 값을 전송할때 url뒤에 붙여서 전송하면 GET방식이다.
			   			ex) http://mysite.com ? name = Fred & age=11 	=> 이런식으로 ?뒤에 (*name속성값*) = (*전달되는값*) 형태로 붙어서온다.
			   			ㄴ 정보가 url뒤에 붙어서 보이므로 보안에 취약하고
			   			ㄴ url의 길이에 제한이 있어 전송할데이터가 커지면 중간에 짤릴가능성이있다.
			   		ㅡ Post방식은 전송할 데이터를url뒤에 붙여전송하는게 아닌 서버쪽에 저장한뒤 이를 가져와 쓰는방식이다.
			   		ㅡ < form>태그에서 method라는 속성값으로 이 방식을 선택할수있다. 'GET'이나 'POST'를 값으로 주면된다. 디폴트는 GET이다.
			   		ㅡ 어떤 방식을 사용한 요청이냐에따라 서블릿에서 doGet()이호출될지, doPost()가 호출될지 결정된다.
			   		ㅡ Post방식의 경우 데이터를 서버에서 가져오는것이므로 이 과정에서 한글이 깨질수있으므로 doGet,doPost의 첫번재인자 request에 대해 setCharacterEncoding("(*글자셋*)")을호출.
			   		ㅡ GET방식의 경우 url뒤에 붙어오는 한글인자를 post방식처럼 인코딩해주지못하므로 다름방법사용.
			   			ㄴ tomcat폴더에서 conf - server.xml에 들어가서 port속성값이 8080인 < connector>요소에다가 URIEncoding = (*글자셋*) 속성을 추가해준다.

			   	ㅇ 서블릿을 이루는 것들
					ㅡservlet 인터페이스)
						ㄴinit(), destroy(), service()메소드가 대표적으로 존재하고, 컨테이너에 의해 이 메소드들이 호출된다.
						ㄴinit()에선 인스턴스화ㅗ된 서블릿이 초기화되고, 나머진아는그대로.
					ㅡHttpServlet 추상클래스)
						ㄴ보통 서블릿을 만들면 이것을 상속해 만듧. http프로토콜을 반영하기 위해 service()를 재정의한 서블릿. 때문에 이 service()는
						  http request와 http response만을 인자로 받는다
						ㄴdoGet(), doPost(), doDelete(), doPut(), service()등의 메소드가 존재하고 추상클래스이므로 이들중 하나를 오버라이딩해야함.
						ㄴ하지만 이 메소드중 하나인 public void service()는 request를 protected void service()로 보내주고 여기서는
						  해당 request의 타입에 맞게 doGet,doPost()등의 메소드로 request를 보내주는 기능을 하므로  이 두 service()는 오버라이딩할 필요가 없다.
					ㅡGernericServlet 추상클래스)
						ㄴ프로토콜 독립적인 서블릿클래스로, Servlet인터페이스를 구현하며 HttpServlet 추상클래스의 부모클래스이다.

				ㅇ 서블릿 라이프 사이클
					<img src="image/서블릿 라이프사이클.jpg" style="height:800px; width:auto;">
					ㅡ 초기화시 init()호출, 웹브라우저의 호출, 작업시 service()호출, 폐기시 destroy()를 호출한다.
					ㅡ여러 요청이 들어온다고 서블릿을 여러개 인스턴스화 하는게 아니라 하나만 인스턴스화해놓고, 스레드를 새로만들어서 요청마다 사용하는식이다.
					ㅡ서블릿 클래스를 인스턴스화하고 init()을 호출하는과정까지가 '로딩'이라하고 init()수행하는게 '초기화'라고함. 최초 요청 전에 서블릿은
						항상 로딩되고 초기화된다고함.
					ㅡ서블릿 인스턴스화는 그냥 '객체'가 되기만했을뿐이고 init()를 통해 여러가지 서블릿으로서의 권한, 기능 등을 부여받아야 '서블릿'이 되는것이다.
						ex) ServeltContext를 통해 dispatch를한다던지 log를쓸수있다던지 등의 권한,기능.
					ㅡ init()또한 service()처럼 두종류가있다. ServletConfig객체를 넘겨주는것과 없는것. 인자를넘겨주는 init()는 컨테이너가
						인자를 넘겨주며 호출하며, 이 메소드안에서 인자가 없는init()를 호출하게된다. 개발자가 오버라이딩하는 메소드도 인자가 없는 init()이다

			</pre>
			요청,응답과 페이지 전환<button>더보기</button>
			<pre>
				* HTTP 응답
					HTTP/1.1 ~~				=>시작행 : 응답결과가 정상인지 에러인지, 어떤에러인지에 대한 정보를담고있다.
					Server : Apache ~~		}
					(*이름*) : (*값*)			}	=> 헤더 : 여러가지 정보를 담고있다. (쿠키라던가 )
					  ~~~					}

					< HTML>					=> 바디 : 출력할 html문서 본문이 온다.
						~~~


				ㅇ 서블릿 요청과 응답
					ㅡ 응답으로 무얼전송하나)
						response로 html파일을 보내고 싶으면 HttpServletResponse의 getWriter()로 PrintWriter객체 받아서 출력하면 그내용이
						http 응답에서 body부분에 씌여전송되며, 바이너리 파일을 보내고싶으면 HttpServletResponse의 getOutputStream()으로
						ServletOutputStream객체 얻어서 이걸로  출력하면 http응답에 html페이지가 아닌 파일이 전송되게 됨.
						즉, response에 html페이지만 전송하는것은 아니며, 웹에서 파일다운받는것을 이런식으로 할수도 있다. (그냥 WAS없이 링크를 걸어서
						서버에서 바로 보내주는게 간단하긴하지만)
					ㅡ 응답의 헤더에 값을 설정할수있다.
						ㄴsetHeader("(*헤더이름*)", "(*값*)") : 헤더 이름과 값을 추가합니다. 같은이름이 있으면 해당 값을 대체합니다.
						ㄴaddHeader("(*헤더이름*)", "(*값*)") : 헤더 이름과 값을 추가합니다. 같은이름이 있으면 해당 이름에 값을 하나더 추가합니다.
						ㄴex) setContentType("text/html") == setHeader("content-Type", "text/html" ==> 둘다 완전똑같은 의미.
							헤더에 contentType항목에 text/html값을 추가하는기능.
					ㅡ요청에 대한 응답을 누가할지 정할수 있다. 리다이렉트(redirect)와 디스패치(dispatch)방법이있다.
						ㄴredirect)
							ㄴ대표적으로 sendRedirect(" (*url*) ")
								ㄴ 인자로 넘긴 url로 서버에 웹자원을 다시요청하라는 명령을 브라우저에게 보내는 메소드.
								ㄴ 이 메소드가 실행되면 기존 url이 지워지고 다시요청한 url로 대체되며, 브라우저에 히스토리에도 남지않는다.
								ㄴsendRedirect("(*url*)")에서 url부분은 상대경로 지정이 가능하며 이경우, 컨테이너가 알아서 webapp의 디렉터리 경로를
								   추가한다. 단, url이 '/'로 시작할경우 webapp까지만의 경로를 추가하는것으로 재작성한다.
								ㄴ이 메소드는 response에 쓰기작업을 하는것과 동시에 될수없다. 응답메세지에 데이터가 보내지면서 다른 url로 이동하라고 할수는
								 없다는것. 때문에 html페이지 쓰기 등의 작업이 있어선안된다.
						ㄴdispatch)
							ㄴ서블릿 상에서 바로 다른 웹컴포넌트로 제어를 넘기는 방식.
							ㄴ대표적으로 forward(). forward()는 POST방식으로 넘겨줌.

				ㅇ forward()
					ㅡ 개요) 한 페이지안에서 다른 페이지 호출하는 기능을한다.
					ㅡ 기본)
						ㄴ javax.servlet.RequestDispatcher 인터페이스에 들어있는 메소드이다. 이 객체를 생성해야 호출가능하다.
						ㄴ 이 객체는 꼭 request의 getRequestDispatcher(" (*이동할페이지url*) ")을 통해 얻어야한다.
						ㄴ 위 getRequestDispatcher() 호출시 인자넘길때, '/'로 시작하면 현재디렉토리가아닌 웹어플리케이션 디렉토리부터 시작한다.
						ㄴ forward()의 인자는 첫번째가 request, 두번째가 response이다. ex) forward(request, response);
					ㅡ 동작 방식)
						ㄴ 메소드를 호출하는 페이지의 request를 이동할 페이지의 request로 전달하며 페이지를 불러온다. 요청을 다른페이지로 넘긴다고보면된다.
						ㄴ 이동된 페이지로 제어흐름이 넘어가며 메소드를 호출한페이지로 다시돌아오지않는다.
					ㅡ ex)
						RequestDispatcher dispatcher = request.getRequestDispatcher("/home");
						dispatcher.forward(request,response);
					ㅡ 추가사항)
						ㄴ 서버에서 직접 호출하는것이므로 sendRedirect()와 달리 같은 서버의 디렉토리 안에서만 자원을 호출할수있다.

				ㅇ include()
					ㅡ forward()와 비슷한 기능을 한다. 다른점은 이동한 페이지를 실행후, 제어흐름이 다시 메소드를 호출한 페이지로 돌아온다.
					ㅡ forward()와 같이 RequestDispatcher인터페이스에 정의된 메소드이고 사용법도 같다.
					ㅡ jsp의 include 지시자와 결과가 유사하나, 동장방식이 다르다고한다.
						ㄴ


			</pre>
			주요 객체들과 메소드들<button>더보기</button>
			<pre>
				ㅇ Scope 영역
					ㅡ 개요)
						서블릿에서 사용되는 객체들은(원래있는 객체든 정의한객체든) 정해진 영역 안에서만 사용이 가능하다. 이를 객체의 스코프라고하며, 4가지 영역이 있다.

					1. page영역)
						ㅡ 하나의 request에 대해 대응되는 하나의 jsp에 해당하는 영역. pageContext에 해당한다.
					2. request 영역)
						ㅡ 하나의 요청을 처리하는데 쓰이는 모든 웹 컴포넌트에 해당하는 영역.( forward()나 include()등을 사용시 요청을 그대로 넘겨주기때문에 해당 요청에 대한 처리는
							계속 이어진다). HttpServletRequest 객체에 해당한다.
						ㅡ request의 setAttribute()로 저장하는 속성과 form등으로 전달되는 request parameter는 다른것이다.
					3. session 영역)
						ㅡ 하나의 세션이 생성되고 종료될때까지의 해당하는영역. 하나의 웹브라우저당 하나의세션 객체가 생성된다. HttpSession 객체에 해당한다.
					4. application 영역)
						ㅡ 하나의웹 어플리케이션 전ㄴ체 영역에 해당한다. 하나의 클라이언트에 대한 영역인 세션영역가 달리 해당 웹 app에 접속하는 모든이들이 공유하는 영역.
							하나의웹app당 하나의 application 객체 생성. ServletContext 객체에 해당한다.

					ㅡ 속성 저장)
						ㄴ 각 영역에 해당하는 객체들은 '속성'들을 가질수있으며 해당 객체가 존재하는동안 사용할수잇다. 데이터 교류 목적으로 주로 쓰인다.
						ㄴ 메소드들) 형태가 모든객체들에서 대동소이하다.
							ㄴ setAttribute( "(*이름*)", (*값*) ) : 속성을 저장. (*값*)은 Object형태로 저장된다.
							ㄴ getAttribute( "(*이름*)")) : (*이름*)에 해당하는 속성 반환. Object형태로 반환되므로 사용을 위해서 형변환필요.
							ㄴ removeAttribute( "(*이름*)" ) : (*이름*)에 해당하는 속성 삭제
							ㄴ getAttributeName() 등등

				ㅇ 그 외에 주요 객체들
					ㅡ ServletConfig 인스턴스
						ㄴ서블릿 당 하나 할당.
						ㄴ서블릿의 init()의 인자로 넘어가, 초기화시 여러 정보를 서블릿으로 넘겨주기 위해 쓰이는 객체.
						ㄴServletContext에 접근하기 위해서도 사용

					ㅡ ServletContext 인스턴스
						ㄴ웹 어플리케이션당 하나 할당. AppContext라고 생각하면 좀 기억하기쉬움.
						ㄴ컨테이너와 상호작용하기위한 여러 메소드들이 정의되어있음.
						ㄴ 컨테이너에 의해 웹 어플리케이션이 배포되는 시점에서 생성된다.
						ㄴ 컨텍스트 초기화 파라미터를 가진다.

			</pre>
			세션, 쿠키<button>더보기</button>
			<pre>
				ㅡ 개요)
					페이지간의 데이터 전달을 위한 기술. 쿠키는 브라우저쪽에 데이터를 저장. 세션은 서버쪽에 저장.

				ㅇ 쿠키
					ㅡ 서버에서 브라우저로 작은 크기의 정보를 보내는 기술을 말하며, 정보는 브라우저쪽에 저장된다.
					ㅡ 세션기술과유사하게 클라이언트와 서버간에 연결유지기능을한다.
					ㅡ 브라우저가 서버로 요청을 보낼때 기본적으로 쿠키정보를 같이 보내게 된다.
					ㅡ Cookie클래스가 쿠키를 말한다.

					ㅡ 쿠키 만들기)
						ㄴ ex)	Cookie c - new Cookie( "(*쿠키이름*)", " (*쿠키값*) ");

					ㅡ 쿠키 저장하는법)
						ㄴ 생성한 쿠키를 브라우저로 보낼 response에 붙여 브라우저쪽에 저장한다.
						ㄴ ex)	response.addCookie( (*쿠키객체*) );
						ㄴ http 응답 메세지에 헤더부분에 쿠키정보가 추가되어 전달된다.

					ㅡ 쿠키 조회)
						ㄴ 브라우저로부터 전달받은 쿠키를 읽을수있다.
						ㄴ 넘어온 쿠키들중에서 특정 쿠키를 찾는 메소드는 따로 존재하지않는다. getCookie()를 통해 쿠키정보를 읽어오면 반환값은 Cookie형 배열이다.
						ㄴ Cookie객체의 getName()을 이용하여 하나씩찾아봐야한다.
						ㄴ Cookie객체의 getValue() : 쿠키값을 반환한다.
						ㄴ ex)	request.getCookie()

					ㅡ 쿠키 수정)
						ㄴ 저장과 똑같은 방식으로 하면된다. 브라우저상에 같은 이름의 쿠키가 추가되면 기존의 것을 대체한다.

					ㅡ 쿠키 삭제)
						ㄴ 쿠키 수명 : 쿠키는 수명이란것을 가지고있으며, 브라우저에 종료에 상관없이 이 값에따라 생존과 소멸이 결정된다.
						ㄴ 삭제는 이 수명값을 0으로 만드는것으로 진행된다.
						ㄴ setMaxAge( (*초단위 정수*) ) : 쿠키 객체의 메소드.

					ㅡ 쿠키 전송범위)
						ㄴ 브라우저는 서버로 url을 보낼때 url에 모든 쿠키정보를 붙여서 보낸다고했는데 특정url에 대해서만 쿠키를 보내게 설정할수있다.
						ㄴ 쿠키 객체에 대해 setPath(" (*url*) ")으로 설정가능하다. (이메소드에서 url은 webapps폴더가 시작위치이며, '/'로 시작하고 끝나야한다)
						ㄴ 해당 쿠키는 설정한 url로 요청을 보낼때만 쿠키정보가 넘어간다.
						ㄴ url뿐만 아니라 특정 서버, 도메인으로도 설정가능.

				ㅇ 세션
					ㅡ 쓰임새)
						ㄴ http프로토콜에서는 한번 요청에 대한 응답이 되면, 서버와 클라이언트간 연결이 끊긴다(stateless)
						ㄴ 로그인 등과 같이 지속적인 연결이 필요할때 이 세션기술을 이용할수있다.

					ㅡ 기본)
						ㄴ 클라이언트가 처음 요청을 할때 컨테이너는 해당클라이언트에게 고유한 세션id를 생성해주고 이를 응답을통해 전달한다.
						ㄴ 이 세션 id는 쿠키기술로 클라이언트측에 저장이되며
						ㄴ 다음번 요청시부터 이 쿠키로 저장되어있는 세션id를 같이 보내는 방식으로 서버와 클라이언트간의 연결이 지속된다.
						ㄴ 세션은 자동으로 생성되는듯함. 그냥 반환받아서 쓰는거고

					ㅡ HttpServletRequest에 대해 getSession()을 호출하면 HttpSession객체 반환(세션을 반환). 이 객체를 사용하여 다양한 세션기술들을 사용할수있다.
						ㄴ 세션에 있는 데이터들은 같은 webapps안의 폴더에 있는 웹자원끼리 공유. 이 범위안에 다른페이지에서 세션을 만들시 이미 진행중인 세션이 있을경우 기존세션을 반환해줌.
							이 외의 범위에서 세션만들면 별개의 세션반환.
					ㅡ 메소드들)
						ㄴ isNew() : session에 들어있는메소드로, 해당세션이 새로생긴것인지 아닌지 boolean반환.
						ㄴ getSession(boolean형) : 그냥 세션을 얻는 getSession()과 다르게 인자값으로 false를 넘기면 이미 존재하는 세션을 반환해주며, 없는경우 null반환.
						ㄴ setAttribute( " (*이름*)", (*값*) ), getAttribute("(*이름*)"), removeAttribute("(*이름*)"), invalidate() 등이 있다.

					ㅡ 세션 제거)
						ㄴ 사용되지 않는 세션은 서버에 남아 자원을 소모하고있기때문에 적절하게 제거되어야한다.
						ㄴ 특정 조건을 만족하는 세션은 컨테이너에 의해 비활성화라고 판한되고 제거된다.
							ㄴ 일정시간이 지남( 타임아웃)
							ㄴ 개발자가 세션객체에 대해 invalidate()를 호출
							ㄴ 어플리케이션이 다운됨( 문제가 생겨서 또는 undeploy되는 경우 )
						ㄴ 세션 타임아웃 설정하기)
							ㄴDD에 설정하며 < web-app>안에 중첩해서 정의.
								< session-config>
									< session-timeout> (*분단위 숫자*) < /session-timeout>
							  	< /session-config>
							ㄴ 해당 세션객체에대해 setMaxInactiveInterval( (*초단위 숫자*) ) 호출.
								ex) session.setMaxInactiveInterval(20*60);

				ㅇ url재작성
					ㅡ 세션id가 있어야 세션을 유지시킬수 있다. 세션id는 쿠키기술로 클라이언트쪽에 저장된는데 만약, 클라이언트가 쿠키기술을 막아놨다면 세션을 저장할수가 없다.
					(이런 클라이언트들은 "Set-Cookie" response 헤더부분을 무시한다). 이럴때쓰이는게 url재작성이다.
					ㅡ 이는 페이지상의 요청으로 보낼 모든 url에다가 'jsessionid'라는 세션id정보를 추가하여 세션을 유지시키는 방법이다.
						ex) < a href="http://~~~.com;jsessionid=~~~~"> 이런식으로.
						ㄴ해서 이런 링크를 눌러 요청을 보낼때마다 해당 클라이언트의 세션id가 url뒤에 따라가기때문에 세션을 유지시킬수있다.
						ㄴ 단점은 세션id가 url로 노출되기때문에 보안에 좋지않다.
					ㅡ HttpServletResponse의 encodeURL(" (*URL*) ")
						ㄴ url재작성을 편리하게해주는 메소드로서, 해당 클라이언트가 쿠키기능을 제공하는지아닌지를 판단하여 제공한다면 그냥 url부분의 경로를 반환하고
							제공하지않는다면 url끝에 세션id를 붙여서 반환해준다.
					ㅡ HttpServletResponse의 encodeRedirectURL(" (*URL*) ")
						ㄴ 페이지 redirect를 하면서 url재작성으로 세션id를 넘겨주고 싶을때 사용.
					ㅡ 부가설명)
						ㄴ url재작성 규칙은 벤더마다 다르다. 톰캣처럼 ~~;jsession=~~이런형태가 아닐수있다.
						ㄴ 정적인 페이지에선 사용이안됌.


				ㅇ 세션이동, 직렬화
					ㅡ .....<!--  p292부터 나오는 내용부분인데 아직 이해못함. 나중에정리 -->

			</pre>
			컨테이너<button>더보기</button>
			<pre>
				ㅡ컨테이너의 이점
					ㄴ통신지원)
						서블릿과 웹서버가 대화하는 방법을 API로서 제공한다. 따라서 개발자가 서버와 어떻게 통신하는지를 신경쓸 필요가없이 서블릿의 비즈니스 로직만
						신경쓰면된다.
					ㄴ라이프 사이클 관리)
						서블릿 클래스를 적절하게 로딩, 인스턴스화, 초기화하고 적절한 메소드를 호출하고 가비지컬렉션으로 제거하는등의 작업을 컨테이너가 알아서해줌.
					ㄴ 멀티스레딩 지원)
						새 요청이 들어올때마다 알아서 스레드릴 생성하여 요청을 처리해준다.
					ㄴ 선언적인 보안관리)
						잘은 모르겟지만 보안관련 내용을 직접 클래스 안에 하드코딩할 필요가없다함.
				ㅡ컨테이너 작동방식(대략)
					ㄴ요청이 들어오면 HttpServletRequest, HttpServletResponse 객체를 생성
					ㄴ 요청 메세지를 분석하여 어떤 서블릿이 필요한지 알아낸다음 스레드생성하여 해당서블릿으로 request,response객체 넘김
					ㄴ 해당 서블릿에서 service()실행하여 적절하게 doGet()이나 doPost()실행
					ㄴ 실행결과를 response에 실어서 보냄
					ㄴ request,response 객체 소멸
				ㅡ컨테이너가 요청과 서블릿을 연결하는 방법
					ㄴ 알고있는 web.xml을 이용한다. 이를 배포서술자(DD, Deployment Descriptor)라고 한다.
					ㄴ 구조를 간단히 봤을때,
						< servlet>
							< servlet-name>(*내부에서만 사용하는 이름*)< /servlet-name>
							< servlet-class>(*패키지를포함한 실제 클래스명*)< /servlet-class>
						< /servlet>
						< servlet-mapping>
							< servlet-name>...< /servlet-name>
							< url-pattern>(*클라이언트쪽에서 요청할때쓰는 서블릿이름*)< /url-pattern>
						< /servlet-mapping>
						  이런식으로 url-pattern에 있는이름으로 요청이들어오면 servlet-name의 이름으로 해당 클래스를 찾아서 그 서블릿을
						  실행하는 방식으로 연결된다.
					ㄴ 이점은 보안강화와 나중에 변경사항발생시 이 DD만 수정하면된다는점에서 유연성이 좋음.


			</pre>
			초기화 파라미터<button>더보기</button>
			<pre>
				ㅡ 서블릿 시작시 설장하는 값으로, c언어,자바의 고정 상수정의 비슷한거.
				5-1. 서블릿 초기화 파라미터
					ㅡ doGet(), doPost()가 request 인자를 받듯이, 서블릿도 처음에 받을수 있는 초기화 파라미터라는 인자가 있다.
					ㅡ 초기화 파라미터 설정하기 )
						DD에 입력을 하며, < servlet>요소 안에
						< init-param>
							< param-name> (*초기화 파라미터 이름*) < /param-name>
							< param-value> (*초기화 파라미터 값*) < /param-value>
						< /init-param>
						와 같이 입력을 하여 설정한다.
					ㅡ 컨테이너는 DD를 읽어(물론 이안에 초기화파라미터 정보가 있으며 같이읽는다) 서블릿당 하나씩 생성되는 ServletConfig을 만들어
						 여기로 정보를 넘겨주며(물론 초기화 파라미터도 같이 넘겨진다)
					ㅡ  이후 서블릿 인스턴스를 생성하고 init()를 호출할때 이 ServletConfig객체를 넘겨준다. 당연히, init()실행후에
						초기화파라미터를 사용할수 있따.
					ㅡ 따라서 초기화파라미터를 이용하여 서블릿의 내용을 수정하려면, 서블릿을 종료했다가 다시 초기화되도록해야한다. 하지만 서버를
						종료하는것은 실제 서비스에 있으서 좋은방법이아니고 이를 위해 redeploy기능을 이용하면 되지만, 이것역시 조심해야함.
					ㅡ 파라미터 사용하기)
						ㅡ 서블릿 초기화 파라미터는 ServletConfig객체 안에있으므로 이 객체를 얻는 Servlet인터페이스의 getServletConfig()를
							사용해 객체를얻고, 이 ServletConfig객체에 대해 getInitParameter(" (*파라미터이름*) ")을 사용하여
							파라미터를 얻는다.
				5-2. 컨텍스트 초기화 파라미터
					ㅡ 서블릿 초기화 파라미터와 같은 초기화 파라미터인데, 서블릿당 하나씩 생기는 ServletConfig객체에 들어있는 초기화 파라미터가 아닌
						웹 어플리케이션당 하나씩 생성되는 ServletContext객체에 들어있는 초기화 파라미터이다.
					ㅡ 설정하기)
						DD에 서블릿 초기화파라미터와 조금 다르게 < servlet>요소와 동등한 구조상 위치에서
							< context-param>
								< param-name> (*초기화 파라미터 이름*) < /param-name>
								< param-value> (*초기화 파라미터 값*) < /param-value>
							< /context-param>
						이런 형식으로 써준다.
					ㅡ 사용방법)
						ㄴ ServletContext객체에 초기화파라미터가 존재하므로 getServletContext()를 통해(request, GenericServlet 등
							여러 객체들에서 상속되는 메소드임) ServletContext객체를 반환받아 getInitParameter(" (*파라미터이름*) ")을 사용한다.
						ㄴ 당연히 웹어플리케이션에 있는 모든 웹자원에서 사용이 가능하다.

				*J2EE?
					ㅡ java 2 enterprise edition 으로, 기업환경에서 어플리케이션을 만들기위한 기술들을 담아놓은 에디션을 말함.
					  이거말고도 standard edition, micro edition 등등이 있음.
					ㅡ 이 안에 jsp, servlet, java bean 등의 기술들이 들어가있는것.
					ㅡ 해서 이 J2EE에 완벽하게 부합하는 어플리케이션 서버는 웹컨테이너뿐아니라 EJB(enterprise java bean)이 있어야
						한다함. 근데 톰켓서버는 웹컨테이너밖에없어서 완벽한 j2ee서버가 아니라고함.

			</pre>
			리스너<button>더보기</button>
			<pre>
				* 리스너란?
					ㅡ 특정한 이벤트가 발생했을때 이를 처리하는 함수나 객체를 말하며, 이벤트 핸들러 라고도 한다.
					ㅡ ex) 마우스클릭 이벤트, 종료 이벤트 등등. 서블릿에선 웹어플리케이션 배포 이벤트, 서블릿의 종료이벤트 등.
					ㅡ 서블릿/jsp환경에서는 이 환경에서의 이벤트가 존재하며, 이에 대응하는 리스너들이 존재한다.
					ㅡ 이벤트 소스 : 이벤트가 발생한 대상(근원지)를말하며, 키보드 마우스 서블릿 등을 말함.

				ㅇ 서블릿/jsp에서의 이벤트,리스너 종류
					: 웹환경에서는 서블릿의 초기화와 종료, 세션 생성,종료 각각에서 속성값 추가,변경,제거 등에 관한 이벤트들이 있다.
							ㅡ이벤트소스 ServletContext인 경우)
					ㄴServletContextListener, ServletContextEvent : 웹어플리케이셔의 시작,종료이벤트에대한것들.
					ㄴServletContextAttrubuteListener, ServletContextAttributeEvent
						:ServletContext에 속성 추가,제거,수정시 발생.
					ㅡ이벤트소스 HttpSession인 경우)
						ㄴHttpSessionListener, HttpSessionEvent : 세션의 시작,종료에관한것
						ㄴHttpSessionAttributeListener, HttpSessionBindingEvent : HttpSession에 속성 추가...에관한것
					ㅡ 이벤트 소스 ServletRequest인 경우)
						ㄴServletRequestListener, ServletRequestEvent : 클라이언트요청으로인한 ServletRequest생성,응답,제거에관한것
						ㄴServletRequestAttributeListener, ServletRequestAttributeEvent : ServletRequest에 속성 추가,제거,수정에관한것.
					ㅡ위에서 ~~Event로 끝나는 객체들에는 해당 이벤트소스를 반환해주는 메소드가 정의되어있으며, 해당이벤트 발생시 컨테이너는 이 객체들을 생성하여전달함.
						ex) ServletContextEvent안에 getServletContext().
					ㅡ 위에서 ~~Listener로 끝나는 객체들 안에는 해당이벤트 발생시 호출되는 메소드들이 선언되어있다.

				ㅇ 리스너 동작과정(간략)
					ㅡ 개발자가 리스너를 구현하고 등록해놓으면
					ㅡ 컨테이너가 관리를하다가
					ㅡ 해당이벤트 발생시 해당 리스너에게 알려줌
					ㅡ 리스너에서 해당 메소드가 실행

				ㅇ 리스너 등록방법
					ㅡweb.xml에 등록하며
					ㅡ < web-app>에 중첩해서 정의(< web-app>아래에 정의한다는말).
					ㅡ 순서는 (지켜야하는지잘모르겟지만) < filter-mapping>과 < servlet>사이에 정의.
					ㅡ 형식은
						< listener>
							< listener-class> (*리스너클래스 이름(패키지명까지)*) < /listener-class>
						< /listener>

				ㅇ ServletContextListener 인터페이스
					: 웹환경에서의 리스너중 하나.
					ㅡ 구성 메소드들)
						ㄴ public void contextInitialized(ServletContextEvent sce): 웹어플리케이션 시작시 호출.
							웹어플리케이션의 모든 필터,서블릿의 초기화 이전에 호출되는메소드.
						ㄴ public void contextDestroyed(ServletContextEvent sce): 웹 어플리케이션 종료시호출.
							웹어플리케이션의 모든 필터,서블릿 종료후에 호출되는메소드.
					ㅡ 리스너 구현 예시)
						public void contextInitialized(ServletContextEvent event){
							ServletContext context = event.getServletContext();	=>ServletContext객체를 얻음.
							String dogBreed = sc.getInitParameter("breed");		=>ServletContext객체로부터 컨텍스트초기화파라미터를 얻음.
							Dog d = new Dog(dogName);							=>저장하고자하는 Dog객체를 파라미터로부터 받은정보로 생성
							sc.setAttribute("dog", d);							=>생성한 객체를 ServletContext객체에 속성값 저장.
						}
					ㅡ  ServletContex
						ㄴ 컨텍스트가 초기화되면(웹어플리케이션이 배포되면), 컨테이너가 이를 이벤트로서 알아차리고 ServletContextEvent를 생성하여
						ㄴ SerlvetContextListener에게 전달
						ㄴ 리스너의  contextInitialized()실행.

							ㅇ 속성값들의 데이터 충돌문제
								ㅡ ServletContext, 세션 등의 객체에 저장하는 속성값들은 여러 서블릿 또는 스레드에서 접근이 가능하기때문에 데이터충돌문제를 일으킨다.
								ㅡ 때문에 동기화를 시켜주어 최대한 안전함을 보장해야함. synchronized()를 이용.
								ㅡ request객체의 속성과 지역변수만이 안전하다.
							ㅇ 개요)
								ㅡ 초기화파라미터는 xml을 이용하므로 문자열만 사용이가능한데, 문자열이 아닌 db데이터나 객체를 초기화하고싶을때 이 기능을 구현해주는 것을 리스너라한다.
								ㅡ 서블릿은 어느서블릿이 가장먼저 호출될지 보장할수없으므로 일반 자바 클래스에 리스너를 정의를한다.
							ㅇ 기능)
								ㅡ 컨텍스트가 초기화되는걸(웹어플리케이션이 배포) 알아차리고,
								ㅡ ServletContext 로부터 컨텍스트초기화 파라미터를 읽어들여 db에 이 읽어들인 검색명으로 검색을하여
								ㅡ 검색한 데이터를 객체로 '속성'에 저장한다.
								ㅡ 이후 컨텍스트가 종료되면 이를 알아차리고 db와의 연결을 끊을수 있어야한다.

								ㅡ 컨테이너는 DD를 참고하여 리스너를 실행시킨다.
							ㅇ 문법)
								ㅡ 리스너 클래스는 javax.servlet.ServletContextListener 인터페이스를 구현해야한다.
									이 인터페이스 안에는 contetInitialized(ServletContextEvent), contextDestroyed(ServletContextEvent)가있다.

			</pre>
			기타<button>더보기</button>
			<pre>
				ㅇ 서블릿에서의 오류처리
					1. try-catch문으로 catch부분에 html출력 =>구조가 기형적.
					2. try-catch문으로 catch부분에 forward()사용.
					3. DD를 이용한 오류처리.
						ㄴ DD에 오류와 해당오류에 짝지어진 url을 등록하여 해당오류발생시 짝지어진 url로 이동하도록 할수있다.
						ㄴ	< error-page>
								< exception-type>(*패키지를포함한 예외클래스이름*)< /~~>
								< location>/(*웹어플리케이션부터시작하는url*)< /~~>
							< /error-page>
								=> 해당 예외클래스발생시 바로아래에 짝지어진 url로 이동.
						ㄴ < exceptino-type>대신에
							< error-code>(*http상태코드*)< /~~>
						  	 를 써넣으면 해당 에러코드발생시 이동할 url을 설정할수있다.
						    	ㄴ 마찬가지로 exception객체를 넘겨주며 사용하기위해서는 역시 isErrorPage에 true를주어야함.

				* 바인딩 : request나 세션 객체등에 속성값을 설정해는것을 말함.
				* 분산 웹 어플리케이션?
					ㅡ 컨테이너가 클라이언트의 요청을 몇몇 JVM으로 분산하여 넘기는 환경이 있다고함. 즉, 어플리케이션이 다중 JVM에서 구동되는것.
						ㄴ 즉, 어떤 요청은 vm1로 보내고 또다른건vm2로 보내고 이런식.
					ㅡ 이럴경우, 어플리케이션의 ServletContext, ServletConfig 등은 JVM당 하나씩 생성된다.
					ㅡ 하지만 Session의 경우는 VM과 상관없이 웹어플리케이션당 하나만 생성되고 VM을 이동하며 작동한다.
				* 직렬화(Serialization)
					ㅡ 객체나 데이터 등을 외부시스템에서도 사용,전송,저장 할수있도록 바이트형태로 변환하는것을 말함.
					ㅡ  자바에선 java.io.Serializable 인터페이스를 구현하는 객체는 직렬화가 가능하다.

			</pre>
		</pre>
		JSP<button>더보기</button>
		<pre>
			ㅇ JSP란?
				ㅡ 문법구조상 서블릿과는 반대로 html코드안에 자바코드가 삽입. =>서블릿의 단점해결.
				ㅡ 서블릿과 달리 컴파일이나 등록과정 필요없음. 서버의 폴더에 저장하기만하면된다.
				ㅡ html문서사이에 jsp문법의 코드가 삽입되는 형태로 작성된다.
				ㅡ 실행과정)
					ㄴ 웹 컨테이너가 jsp페이지 전체를 서블릿 클래스의 소스코드로 변환한다.
					ㄴ 이후 서블릿 클래스가 작동하는 그대로 진행된다.(컴파일, 인스턴스화, 초기화)
				ㅡ 문법종류)
					1. < % (*내용*) %> 을 사용하는 문법. (스크립틀릿과 지시자,선언부, 표현식이 있다)
					2. $ { ( * 내용*) } 을 사용하는문법. 익스프레션 언어(EL)이라고한다.
					3. < c:fi>, < jsp:forward>등과 같은 xml태그형태의 문법. 액션같은것들.

			ㅇ jsp vs servlet? 뭘써야?
				ㅡ 둘다 장단이 있으므로 둘다쓰인다

			ㅇ 스크립팅 요소
				ㅡ 스크립틀릿과 표현식, 선언부를 말함.
				ㅡ 스크립틀릿)
					ㄴ < % ~~ %>사이에 자바 '명령문'을 넣어서 사용.
					ㄴ 이 부분은 브라우저로 전송되지않으며 서버쪽에서 처리한다.
					ㄴ 서블릿으로 변환시, 안에 내용인 자바명령문들은 그대로 자바명령문이된다.
				ㅡ 표현식)
					ㄴ < %= ~~ %> 사이에 자바'식'을 넣어서 사용.
					ㄴ 이 '식'은 상수나 변수, 연ㄴ산식,메소드 등이 될수잇다.( 명령문 안된다. '식'이다)
					ㄴ 그냥 스크립틀릿을 사용해도 되지만, jsp페이지에 자바코드가 들어가는것을 지양하므로 이를이용해 원하는값들을 뿌려주는식으로 사용된다.
					ㄴ 이역시 서버쪽에서 처리된다.
					ㄴ 서블릿으로 변환시, '식'은 그 식의 결과를 출력하는 명령문으로 변환된다.
				ㅡ 선언부)
					ㄴ < %! ~~~ %> 사이에 자바코드를 쓰며, 변수선언이나 메소드선언을 작성한다.
					ㄴ 서블릿으로변환시, 서블릿클래스의 멤버변수, 멤버함수가 된다.(멀티스레드모델에서는 멤버변수 사용안된다했으므로 변수선언할거면 반드시 final, static을붙여준다)

			ㅇ 지시자
				ㅡ jsp페이지를 서블릿 클래스로 변환할때 필요한 정보를 전달하는 기능을 한다.
				ㅡ page지시자, include, taglib지시자가 있다.
				ㅡ 형식)
					< %@(*지시자이름*) (*속성*)="(*속성값*)" ~~~ %>
					ㄴ 여러속성값들을 설정한다.
				ㅡ page 지시자)
					ㄴ jsp페이지 전체에 적용되는 정보기술에 쓰이는 지시자이다.( 문자인코딩, 응답페이지의 컨텐츠타입, 페이지가 내장세션객체를가질것인지 등)
					ㄴ 대표적 속성들)
						ㄴ import : 자바의 import처럼쓰인다. 기본적으로 포함되는것들은 java.lang, lavax.servlet, javax.servlet.http, javax.servlet.jsp이다.
						ㄴ isThreadSafe : 생성될서블릿클래스가 '싱글스레드모델'일지 결정해줌. 디폴트는 true로 싱글스레드모드사용안함을 의미.
						ㄴ contentType : jsp가 생성하는 문서종류와 브라우저로 전송할때 쓰이는 인코딩타입을 설정한다. 서블릿으로 변환시 response.setContentType()의 인자로넘어간다.
							ex)	< %@page contentType="text/html; charset=UTF-8"%>
						ㄴ isELIgnored : 페이지를 서블릿으로 변환할때 EL표현식을 무시할건지 결정
						ㄴ isErrorPage : 현재페이지가 jsp오류처리용페이지인지 결정
						ㄴ errorPage : 현재페이지에서 잡지못한 예외를 보낼 오류페이지 url을 설정.

				ㅡ taglib지시자)
					ㄴ jsp문법 세가지중 마지막인 xml태그 '액션'을 사용할때 쓰인다.
						ㄴ 더 정확히는, 기본적으로 제공되는액션과 라이브러리를 설치해야 사용가능한 액션이 있는데 후자의 사용을 위해 쓰인다.
					ㄴ jsp에서 이용가능한 태그라이브러리를 정의

				ㅡ include 지시자)
					ㄴ 현재 jsp페이지에 다른 jsp페이지나 html페이지를 불러올때 사용한다.
					ㄴ 불러온 페이지는 현재페이지으 일부가된다.
					ㄴ file속성값으로 상대경로 url을 설정하여 불러온다
						ex)	< %@include file="./aaa.jsp" %>
					ㄴ 지시자가 입력된 그 위치에 불러온 파일이 삽입된다.
					ㄴ 여러 jsp페이지에 공통적으로 포함되어야하는 코드가 있을때 쓰면 좋음. 문서머리말이나 네비게이션같은.

			ㅇ jsp 주석
				ㅡ html, java, jsp의주석 모두사용가능하다.
				ㅡ 처리는 각각 조금씩다르다.
					ㄴ html주석) 서블릿 클래스 변환시 그대로 html형식으로 출력된다.
					ㄴ 자바 주석) 서블릿클래스변환시 주석이 그대로 서블릿 클래스 안으로 들어간다.
					ㄴ jsp주석) < %-- ~~~ --%>형태로 작성하며, jsp에서만 의미가있으므로 html에 출력되지도, 서블릿클래스에 남지도않는다.

			ㅇ jsp코드의 서블릿 변환
				ㅡ jsp선언문을 제외한 jsp의 내용들은 모두 서블릿의 service()메소드 안으로 들어가게된다.(service()는 GET,POST방식 둘다 처리해주는 메소드)
						ㄴ jsp선언문( < %! ~~ %> )안에 선언되는 변수나 메소드는 service()안이 아닌 서블릿의 멤버변수,멤버메소드가 된다.
				ㅡ html코드는 out.println()형식으로 출력된다
					ex)< html>< head> => out.prinlnt("< html>< head>");
				ㅡ 스크립틀릿 안의 자바코드는 그대로 자바코드가 된다.
					ex) < % int count=0; %> => int count=0;
				ㅡ 표현식안에 있는 내용은 그대로 out.println(" ~~ ")안의 내용으로 바뀐다.
					ex) < %= count %> => out.println(count);
				ㅡ jsp코드 서블릿 변환과정)
					ㄴ 지시자가있는지보고 정보확인
					ㄴ HttpServlet의 하위클래스 생성
					ㄴ import속성가진 page지시자있으면 맨위에 import문 삽입.
					ㄴ 선언문부분은 서블릿의 service()위에 선언해줌.
					ㄴ _jspService()라는 이름의 service()메소드를 만듦. _jspService()는 서블릿의 부모클래스에서 정의된
						service()메소드에서 호출되는 메소드임.당연히 HttpServletRequest, ~~Response를 매개변수로받음.
						이메소드에서 jsp의 내장객체도 선언해준다.

			* jsp에서 파일읽기,쓰기

			ㅇ JspPage와  HttpJspPage 인터페이스
				1. JspPage 인터페이스
					ㅡ jsp페이지에 쓰이는 서블릿이 만족시켜야하는 기능들을 구현해놓은 인터페이스
					ㅡ 보통 구현은 이 인터페이스가 아닌 하위인터페이스인 HttpJspPage터페이스가 쓰인다.
					ㅡ jspInit()과 jspDestroy()가 있으며, 각각 init()와 destroy()에 의해 호출된다. 이들은 재정의가 가능하다.
				2. HttpJspPage인터페이스
					ㅡ JspPage인터페이스와 똑같은데 추가로 _jspService()가있으며, 서블릿의 service()와 같은 역할을한다.
					ㅡ service()에서 호출되며, 재정의될수 없다.
					ㅡ  jsp파일은 컨테이너에의해 HttpJspPage 인터페이스를 구현한 서블릿 클래스로 변환이 된다.
					ㅡ  HttpJspPage인터페이스는 JspPage인터페이스를 구현한다.

			ㅇ jsp 전체 흐름
				ㅡ jsp파일이 작성되어 웹어플리케이션에 배포.
				ㅡ jsp파일은 그냥 저장되어있음.
				ㅡ 사용자가 jsp파일을 요청하면, 컨테이너가 jsp파일을 java소스코드로 변환.
				ㅡ 그 java소스코드르 ㄹ컴파일하여 class파일로 만듦. (이 과정은 jsp페이지당 한번만일어나며 이 이후로는 일반 서블릿과 똑같이 작동한다)
				ㅡ 컨테이너가 해당 서블릿클래스를 메모리로 로딩.
				ㅡ 컨테이너에 의해 인스턴스화 되며 jspInit()호출.
				ㅡ 요청이 들어오면 _jspService()호출하여 샐행.

			ㅇ jsp 내장객체)
				ㅡ 선언을 하지않아도 쓸수있는 jsp가 이미가지고있는 객체들이다.
				ㅡ 모든내장객체들은 서블릿/jsp api에 일대일매핑된다.
				ㅡ종류)
					서블릿에서..				jsp에서..
					ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
					JspWriter				out
					HttpServletRequest		request
					HttpServletResponse		response
					HttpSession				session
					ServletContext			application
					ServletConfig			config
					JspException			exception
					PageContext				pageContext
					Object					page

			ㅇ jsp의 초기화 파라미터
				ㄴ 서블릿에서와 마찬가지로 DD에 정의하여 설정할수있다.단, jsp페이지 등록은 < servlet-class>가 아닌 < jsp-file>태그를 이용한다.
					ex) < servlet>
							< servlet-name> ~~< /servlet-name>
							< jsp-file> /(*jsp페이지이름.jsp*) < / jsp-file>	  => 서블릿의경우와 다른부분.
							< init-param>
								< param-name> ~~ < / param-name>
								< param-value> ~~ < / param-value>
							< /init-param>
					   < /servlet>
						~~~~...
				ㄴ 이렇게하면 서블릿에서의 초기화파라미터와 같은원리로 ServletConfig객체에 초기화파라미터가 저장되게되고 서블릿에서와 같은 방식으로 사용하면된다.

			ㅇ pageContext와 jspContext 추상클래스
				ㅡ pageContext 추상클래스)
					ㄴ jsp페이지와 일대일 매핑되는 내장객체로, 내장객체중 가장먼저 생성되어 다른내장객체들을 생성.
					ㄴ 다른 내장객체를 구하거나 흐름을 제어하거나(forward(), include()) 에러데이터를 구하는 기능을 하는 메소드들이있다.
					ㄴ 스코프 영역을 나타내는 정수값에 대한 상수정의가 되어있고, 그 외에도 여러 상수정의가 멤버변수로 되어있다.
					ㄴ jspContext 추상클래스를 상속한다.

				ㅡ jspContext 추상클래스)
					ㄴ pageContext의 상위클래스이다.
					ㄴ 모든종류의 스코프영역에엤는 속성 접근,생성 및 스트림객체생성 등다양한 메소드들이 있다.
						ex) pageContext.getAttribute( (*속성이름*), (*스코프 정수*) ) : 해당 스코프에서 속성이름에 해당하는 속성값 반환.
							스코프정수부분에는 말그대로 스코프를나타내는 정수를 입력해야하는데 pageContext 클래스의 멤버변수로 상수정의가 되어있음.
							SESSION_SCOPE, APPLICATION_SCOPE 등등.
						ex) pageContext.findAttribute( (*속성이름*) ) : 속성이름에 해당하는 속성값을 찾는다. 찾는 스코프범위는 작은것부터
							큰것순으로 찾는다(page, request, session, application순서).

			ㅇ jsp페이지에서의 오류처리
				1. try-catch문을 이용하여 catch문 부분에서 html출력	=> 구조가 기형적이다.
				2. try-catch문에서 catch에 forward등을 사용하여 오류를 처리하는페이지를 따로만듧.
				3. page지시자에 errorPage속성값으로 url을 쓰면 오류발생시 해당url로 이동함.
					ㅡ 이동하면서 exception이라는 jsp내장객체를 전달함.
					ㅡ 이동된페이지에서는 page지시자에 isErrorPage속성값을 true로 줌으로써 exception내장객체 사용이 가능하다.(exception객체는 java.lang.Throwable이다.)

			ㅇ jsp페이지에서 스크립틀릿 사용못하게하는방법.
				ㄴDD에 정의한다.
					< web-app>
						< jsp-config>
							< jsp-property-group>
							< url-pattern>*.jsp< /url-pattern>  =>jsp파일형식에 대해 와일드카드(*)를 사용했으니 모든 jsp페이지에 대해적용.
							< scripting-invalid>			=> 스크립틀릿 사용을 못하게하는부분. 이부분을 true로 설정해주면 스크립틀릿 사용x.
								true
							< /scriptiog-invalid>
							< /jsp-property-group>
						< /jsp-config>
						.....

			ㅇ jsp와 mvc패턴
				ㅡ mvc패턴에서 jsp페이지는 뷰를담당하고있으며, 여기에는 최대한 자바코드를 사용하지않는것이 좋음. 협업 및 유지보수측면에서.
				ㅡ 그래도 어쩔수없이 최소한의 자바코드가 필요할수있는데 이는 액션태그(자바빈같은)나 EL등을 이용하여 처리해준다.

			ㅇ 자바 빈
				ㅡ jsp페잉지에서 쓰이는 자바의 클래스의 일종
				ㅡ 정해진 문법에 맞게 클래스를 정의해야 빈으로서 쓰일 수 있고, jsp에서 태그를 이용해 쓰인다.
				ㅡ 로직과 뷰를 분리하여 심플하게 페이지를 만들고 재사용성을 높이기위해 사용된다.
				ㅡ 빈클래스의 규격을 보면 알겟지만 데이터 객체를 위한 클래스를 만드는 것에 가깝다.
				ㅡ jsp에서의 태그는 < jsp: ~~~/>등을 이용해 bean을끌어다쓴다.
				ㅡ 문법)
					ㄴ자바빈 규격은
						1. private로 선언된 멤버변수들
						2. set(*대문자로시작하는 변수이름*)((*설정할값*)), get(*동일*)() 형태의 getter, setter메소드들. public선언이어야함.
						3. 인자가없는 public생성자가 있어야한다.
						4. getter의 리턴값과 setter의 인자의 자료형은 같아야한다.

					ㄴ사용하는법은
						1. < jsp:useBean id="(*빈이름*)" class="(*패키지포함 자바빈클래스명*)" scope="(*사용범위*)"/> : 자바빈 객체를 생성하기위한 코드.
						2. < jsp:setProperty name="(*위에서 설정한 빈id*)" property="(*프로퍼티명*)" value="(*저장할값*)"> : 자바빈 프로퍼티의 값을
							저장하는 액션.
						3. < jsp:getProperty name="(*위에서설정한빈id*)" property="(*프로퍼티명*)"> : 자바빈 프로퍼티값을 가져오는 액션.

				ㅡ 자바빈 특징1. 쓰려는 자바 빈 객체가 없는경우 자바 빈 작동방식)
					ㄴ < jsp:useBean ~~>은 해당스코프에 id로 설정한 이름의 속성값이 없으면 해당객체를 직접 생성하고 속성값으로 설정한다. 서블릿으로변환되는코드를보면 다음과같다.
						< jsp:useBean id="person" class="foo.Person" scope="~~"/>는 아래와같이변환된다.

							foo.Person person = null;
							synchronized(request){
								person=(foo.Person)~~context.getAttribute("person", 스코프범위);
								if(person==null){
									person=new foo.Person();
									~~context.setAttribute("person", person, 스코프범위);
								}
							}
					ㄴ < jsp:useBean ~~>의 몸체부분에 다른 자바빈액션을 삽입하면 해당객체가 없을경우에 실행할것들을 정해놓을수 있다. 있으면 그냥건너뛰고.
					ㄴ < jsp:useBean>에 type속성을 부여하면, 객체가 없어서 새로 생성할때 부여한 속성값인 클래스를 참조변수의 타입으로,
						class로 부여한 클래스를 실제로 생성하는 타입으로 지정할수가있다.
							ex) < jsp:useBean ~~ type="foo.Person" class="foo.Enployee" ~~>
									변환되면 아래와같다.
								foo.Person person=null;	=>참조변수 타입은 type의 속성값으로.
								if(person==null){
									person = new foo.Employee();	=>실제생성하는 객체타입은 class의 속성값으로.
								}
								물론 이런식으로 설정을하려면 자바문법대로 두클래스가 상속관계이어야한다.
					ㄴ class속성없이 type만 사용할경우, 해당클래스가 스코프범위안에있을시 문제없지만 아닌경우 예외발생한다함.(이부분이해x)

				ㅡ 자바 빈 특징2. 스코프속성의 디폴트값)
					ㄴ < jsp:useBean>과 < jsp:setProperty>액션에는 scope속성이 있는데 이것의 디폴트 값은 page이다.
				ㅡ 자바 빈 특징3. 페이지로부터 파라미터를 받아 사용할수있다.
					ㄴ < jsp:setProperty>의 param 속성 : 클라이언트로부터 받은 파라미터를 바로 자바 빈값으로 사용하고싶을때 사용.
						속성값으로 넘어온 파라미터의 name을 쓰면 해당 값이 저장되게된다.
					ㄴ param속성을 쓰지않고도 넘어오는파라미터의 name값이 빈의 프로퍼티 이름과 같으면, < jsp:setPropery>에 value값을
						비워두면 컨테이너가 자동으로 넘어온파라미터의 값을 저장시킨다.
					ex) 넘어오는 파라미터의 name이 "dog"일때,
						< jsp:setProperty name="AA" property="dog" />
						이러면 넘어오는 dog란 name의 파라미터가 빈에 저장됨.
				ㅡ 자바 빈 특징 4. 자동형변환
					ㄴ 프로퍼티 자료형이 무엇이든 자바 빈태그에 의해 알아서 변환이 된다.
					ㄴ 자바빈 액션만을 이용해서 프로퍼티를 set하면 자동으로 형변환을 해주지만 중간에 스크립틀릿이 들어간경우 자동형변환x.
					ex) < jsp:setProperty ~~~~ value="< %=request.getParameter(~~)%>"/> =>이런식으로쓰면 자동형변환x.

		</pre>
		EL<button>더보기</button>
		<pre>
			ㅡ https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html 에 자세히 나와있다. 참조.
			ㅇ EL (Expression Language) 개요
				ㄴ jsp페이지코드 안에 자바 코드를 넣는건 지양하는추세라함. 프로그래머가 아닌사람들이 못알아보기때문.(디자이너같이)
				ㄴ 그래서 나온 대안이 EL.
				ㄴ 다른곳에있는 자바코드를 호출하는데 그 기능이있다.
				ㄴ ex) el표현식 ${applicationScope.mail}은
				       스크립틀릿 < %=application.getAttribute("mail")%>와 동일하다

			ㅇ EL 기본
				ㅡ el에는 eval-expression과 literal-expression이 있으며 이둘을 합성한 composite expression이 있다.
					ㄴ 전자가 $ { }나 #{ }을 말하는것같고 후자는 아직안배운것같다.
				ㅡ eval-expression에는 ${}를 사용하는것과 #{}을 사용하는것이 있는데, 이 둘은 그 안의 식이 실행되는 시점을 제외하고는 차이점이 없는것같다.
					${}는 즉각적인 실행, jsp페이지가 컴파일될대 바로 컴파일되고 jsp페이지가 실행될때 바로실행된다. #{}는 해당 값이 필요로하기 전까지는 평가되지않는다고한다.
					'defferd-evaluation'이라고한다.
				ㅡ EL의 기능)
					ㄴ 동적으로 자바빈이나 여러 데이터들, 내장객체 안에있는 어플리케이션 데이터를 읽어오는기능
					ㄴ 자바빈이나 form요소같은 데이터를 쓰는기술
					ㄴ 임의의 static, public메소드를 호출하는기능
					ㄴ 연산자를 동적으로 수행하는기능
				ㅡ ${}, #{} 둘다 해당되는지는 모르겠지만 ${}은 서버단에서 EL식이 모두 변환이되어 완전한 html문서가 만들어지고 클라이언트로 보내지기때문에
					한번 처리가되어 보내지면 변경되지 않는다. 클라이언트입장에선 EL이 아니라 그냥 글자값과다름없음.
					ㄴ 서버단에서 처리가 되고 클라이언트로 넘어가기때문에 물론 javascript에서도 사용이 가능하다.
					ㄴ 추측 ) el이 먼저 해석되고 그다음에 jsp가 처리되는 순서가 아닐까 싶다.

			ㅇ EL 사용법
				ㅡ ${ (*expression*) }형태이고,
				ㅡ EL의 rvalue, lvalue는 다음의 객체들과 그 속성, 프로퍼티들을 가리킬수있다.
					ㄴ 자바빈 컴포넌트
					ㄴ 컬렉션
					ㄴ 자바 se enumerated type
					ㄴ 내장객체
				ㅡ 이것들을 가리키기위해 객체의 이름을 expression부분에 쓰면된다.
				ㅡ 컨테이너는 표현식 안에잇는 변수를 PageContext.findAttribute( (*표현식안의변수명*) )의 방식대로 찾는다. page,rquest, session, application범위순으로
					 찾으며 없으면 null을 반환.
				ㅡ bean이나 enum객체, 컬렉션, 내장객체들의 속성이나 프로퍼티를 기리키려면 도트연산자(.)와 [ ]를 이용하면 된다. 이것들 뒤에 프로퍼티나 속성의 이름이 오면된다.
					 ex)	${customer.address["street"]}
				ㅡ 그냥 속성이름을써도되고, 속성이름이 중복되거나하면 내장객체로 스코프를지정한뒤 속성이름을써도된다.
				ㅡ [ ]사이에는 String literal을 쓰며, ""나 ''를써도된다. 도트(.)와 [ ]를 섞어써도된다.
				ㅡ []연산자를쓸때는 안에""을써주어야하며(ex)["~~~"]), ""을쓰지않을경우 해당이름과 같은 속성값을찾아 그값을 넣어준다. 없으면 null.
					ex) ${musicMap[Genre]	=>Genre란 이름의 속성값을찾아 넣어줌.

				ㅡ 빈을 사용할경우. 빈 객체를 저장한 속성에다가 빈의 프로퍼티를  입력하면 getter,setter를 자동으로 호출해준다.
					ex) ${ (*빈 객체가 저장된 속성이름*). (*빈의 프로퍼티*) } => 이러면 빈의 해당프로퍼티에 대한 getter을 자동호출하여 값나오는듯.
						ㄴ 이를 이용하면 jsp 빈 액션태그를 사용하는것 보다 심플하고 더 많은 기능 사용가능.
				ㅡ enum객체의 프로퍼티를 호출하려면, enum객체 안에 bean의 get(*속성이름*)()같은 메소드가 존재해야한다.
				ㅡ 배열이나 리스트의 경우) int로 변환될수있는 literal값이나 따옴표없는 int값이 들어간 [ ]를 이용하여 접근가능.
					ex)	${customer.orders[1]}, ${customer.orders.socks} (socks가 int로 변환된다고 가정)
				ㅡ Map형의 경우) string literal key를 이용해 접근가능하다. (강제는아니라고한다?)
					ex)	${customer.orders["socks"]}

				ㅡ rvalue표현은 객체가 아닌값도 가리킬수있다고한다. 산술연산결과값이나 문자값 등등
					ex)	${"literal"}, ${customer.age+20}, ${true}, ${453} 등
				ㅡ el에서의 자료형 약속)
					ㄴ Boolean : true나 false로 표현
					ㄴ Integer : 자바와 똑같이
					ㄴ Floating-point : 자바와 똑같이
					ㄴ String : 큰따옴표("")나 작은따옴표('')로 둘러싸인것. (큰따옴표를 쓰려면 \", 작은따옴표는 \', 역 슬래쉬는 \\)
					ㄴ Null : null

				ㅡ 표현식 안에 또다른 표현식을 넣는것도 가능.
				ㅡ EL은 자바가 아니며, 당연히 자바문법을따르지도않는다. 비슷해 보이기는 한다.

				ㅡ el내장객체들은 pagContext를 제외하고 모두 map형 객체이다. ServletRequest와 같은 실제 객체가 매핑되어있는 맵이 아닌 단순히 해당 범위의 속성들이
					매핑되어있는 맵. 속성의 참조 그 이상의 기능은 없다.
				ㅡ ServletRequest, HttpSession등의 실제객체에 접근하려면 자바 빈인 pageContext가 프로퍼티로 해당 객체들을 가지고있으므로 이를통해접근하면된다
					ex)${pageContext.request.~~~}  =>.request를 하면 빈인 pageContext가 가지고있는 ServletRequest객체가 반환된다.
				ㅡ EL 내장객체로는 pageScope, requestScope, sessionScope, applicationScope, param,paramValues, header,
					headerValues,cookie, initParam, pageContext가 있다.
					ㄴ param : < form>을 통해 받은 데이터를 가져올때 사용. ex)	${param.(*name속성값*)} 또는 ${param["(*name*)"]
					ㄴ paramValues : < form>에서 한 name에 대해 값이 여러개일때사용. ex)	${paramValues.(*name*)[(*index*)]
					ㄴ header : http요청 메세지에 있는 http헤더값 가져올때쓰임.
					ㄴ pageContext : 유일하게 bean형태이다. PageContext객체의
					ㄴ 내장객체 cookie는 cookie다음으로 쿠키이름을 주면 해당 쿠키가 나옴.
						ex) ${cookie.(*쿠키이름*).value} =>쿠키이름에해당하는 값 출력.
					ㄴ 내장객체 initParam은 initParam다음으로 초기화파라미터이름을 주면 해당 파라미터가 출력.
						ex) ${initParam.(*파라미터이름*)}

			ㅇ EL함수 사용하기
				1. 사용할 함수를 만든다
					ㄴ 일반 자바클래스안에 public static형 메소드를 만든다.
					ㄴ 필수는 아니지만 보통 어떤값을 얻기위해EL에서 함수사용하므로 리턴값이 있는게 보통이고 인자는 상관없다.
				2. DD처럼 태그라이브러리서술자(TLD, Tag Library Descriptor)을 만든다.
					ㄴ 문법은 다음과 같다.
						< taglib ~~>
						< tlib-version>~~~< /~~>
						< uri> (*jsp지시자 taglib에서 사용할 uri이름*) < /uri>
						< function>
							< name> (*jsp에서 함수를 호출할때쓸 이름*) < /name>
							< function-class> (*패키지를포함한 실제클래스*)< /~~>
							< function-signature>(*실제 메소드*)< /~~>
						< /function>
						< /taglib>
					ㄴ 저장위치는 WEB-INF폴더 아래.(.tld형식)
				3. jsp에 taglib지시자를 입력.
					ㄴ ex) < %@ taglib prefix="(*이름*)" uri="(*TLD에서설정한 uri*)"%>
					ㄴ prefix는 일종의 이름공간. 함수이름앞에 붙여줌
						ex) ${ (*prefix*): (*함수이름*)()}
				4. 함수를호출하는 EL작성
					ex) ${ (*prefix*): (*함수이름*)()}

			ㅇ EL연산자
				ㄴ 뷰를 위해 el을쓰는것이므로 지양ㅎ해야하지만 기능은 존재한다.
				ㄴ el에서 null은 출력값으로선 아무것도없는것이고,
					산술연산으로선 0,
					논리연산으로선false이다.

			ㅇ EL의 include
				ㄴ 머리말, 꼬리말같이 똑같은내용이 반복되는경우 include를  통해 구현하여 재사용할수있다.
				ㄴ 이를사용하면 url에있는페이지가 위문장이 있는부분에 삽입된다.
				ㄴ jsp 지시자를이용)
					< %@ include file=" (*페이지url*) " %>
					작동과정)
					1.컨테이너가 include지시자가있는 페이지를 요청받는다.
					2. 컨테이너가 include지시자를보고 포함하려는 페이지의 코드를 그대로 지시자가있는부분에 복붙한다.
					3. 복붙된 코드를 .java파일로 만들어 컴파일하여 서블릿을만든다.
					4. 그다음부턴 서블릿 라이프사이클..
					ㄴ이런과정이기때문에 한번 코드가 삽입되어 서블릿이만들어지면 재배포하거나하는게 아닌이상 포함하려는페이지가 변경되어도 그내용이 반영되지않는다.
					ㄴ 또한 포함되는부분에 < html>, < head>등의 태그가있을시 복붙되면 중복이되므로, 이런 재사용할페이지를 만들땐 이를고려해서 코딩을해야한다.
						(저런태그들을 없애주는등)
				ㄴ 표준액션을 이용)
					< jsp:include page=" (*페이지url*) "/>
					작동과정)
						1.  해당액션부분에 런타임시동작하는 함수호출문삽입.
						2. 일반페이지처럼 .java로 변환되고 컴파일되어 서블릿이됨.
						3. 요청이들어와 실행시 아까의 함수가 실행됨.
						4. 그함수는 포함하려는페이지에 대해 RequestDispatcher를만들어 이것의 include()를통해 반환받은 응답페이지를 그대로
							삽입하는방식으로 작동한다.
							ㄴ이런과정이기때문에 포함하려는페이지내용이바뀌어도 실행할때마다 요청해서 응답받은내용을 포함시키기때문에 그 내용이 반영될수 있다.
							ㄴ 이 액션태그는 몸체를 가질수 있으며, 몸체에 요청파라미터 값을 추가할수있다.
					ex) < jsp:include ~~>
						< jsp:param name="~~" value="~~"/> =>요청파라미터를 넘겨줌.
					    < /jsp:include>

			ㅇ forward 액션
				ㄴ < jsp:forward page=" (*페이지url*) "/>
				ㄴ forward가있으면 응답에 쓰여진것들이 모두취소된다. 즉 forward이전에 어떤출력문이 있었든간에 다 무시되고 페이지를넘어간다는말.

			ㅇ jsp페이지에서 EL을 사용못하게하는방법
				ㄴ jsp에서 스크립틀릿사용못하게하는방법과 같이 DD에정의한다. jsp의경우와 똑같고 < scripting-invalid>부분만 다르다.
					< web-app>
						< jsp-config>
							< jsp-property-group>
							< url-pattern>*.jsp< /url-pattern>  =>jsp파일형식에 대해 와일드카드(*)를 사용했으니 모든 jsp페이지에 대해적용.
							< el-ignored>				=> EL사용 못하게하는부분.
								true
							< /el-ignored>
							< /jsp-property-group>
						< /jsp-config>
				ㄴ 저 값은 디폴트가 false이고 이는 el을 사용한다는것을 의미한다.
				ㄴ 저렇게 true로 바꾸어주면 el식인 ${ ~~} 을 더이상 el로 인식하지 않는다.

		</pre>
		표준액션<button>더보기</button>
		<pre>
			ㅇ 액션태그
				ㅡ 원래 html태그에는 없는 기능으로서 jsp에 의해 제공되는 태그들이다.
				ㅡ 표준액션 태그와 커스텀 액션 태그로 나뉜다.
					ㄴ 표준액션태그 : jsp에서 바로 쓸수있는 기본 액션들. < jsp:~~> 형태로 시작한다.
					ㄴ 커스텀 액션 태그 : 별도의 라이브러리를 설치해야 사용가능한것들. 또는 직접 만들거나.
				ㅡ 액션태그들은 jsp문법이 아닌 xml문법을 따른다.

			ㅇ 표준 액션태그들
				ㅡ < jsp:include> : jsp의 include()와 같은 기능을 한다.
				ㅡ < jsp:forward> : forward()와 같은기능.
				ㅡ Bean과관련된 액션들)
					1. < jsp:useBean id="(*빈이름*)" class="(*패키지포함 자바빈클래스명*)" scope="(*사용범위*)"/> : 자바빈 객체를 생성하기위한 코드.
					2. < jsp:setProperty name="(*위에서 설정한 빈id*)" property="(*프로퍼티명*)" value="(*저장할값*)"> : 자바빈 프로퍼티의 값을 저장하는 액션.
					3. < jsp:getProperty name="(*위에서설정한빈id*)" property="(*프로퍼티명*)"> : 자바빈 프로퍼티값을 가져오는 액션.

		</pre>
		JSTL<button>더보기</button>
		<pre>
			ㅡ 개인적인 간단개요)
				ㄴ 뷰(View)를 담당하는 jsp페이지에서 자바코드를쓰지못하다보니 생기는 제약이있는데, 이 jstl을이용해서 좀더 동적이고 다양한 기능을 구현할수있는
					jsp페이지를 만드는데 쓰이는것 같다.
				ㄴ 한마디로 동적인 뷰 jsp페이지를 만들기위한 도구들?
			ㅡJSP 표준 태그 라이브러리(JSP Standard Tag Library)로, JSP페이지 안에서 쓸수있는 커스텀 액션과 함수를 제공함.
			ㅡ대표적으로 간단한프로그램로직구현, 다른jsp페이지호출, 날짜시간숫자의 포맷,  db입력조회생성등, xml문서처리, 문자열처리함수호출 등등의 기능을한다.
			ㅡex) < fmt:formatNumber value="1.323" patter="#.00"/>
			ㅡ이 jstl은 5개의 라이브러리로 나뉘어지며 각각의 접두어가 붙는다.
					ㄴ코어 ) 변수선언, 실행흐름제어, 페이지이동 등의 기능제공. 접두어는 'c'. uri는 http://java.sun.com/jsp/jstl/core
				ㄴ포매팅 ) 숫자,날짜,시간을 포매팅, 다국어 기능지원. 접두어는 'fmt'. uri는 http://java.sun.com/jsp/jstl/fmt
				ㄴ데이터베이스 ) db관련기능 제공. 접두어는 'sql'. uri는 http://java.sun.com/jsp/jstl/sql
				ㄴxml처리 ) xml문서처리관련 기능. 접두어는 'x'. uri는http://java.sun.com/jsp/jstl/xml
				ㄴ함수 ) 문자열처리함수 제공. 접두어는 'fn'. uri는 http://java.sun.com/jsp/jstl/functions
			ㅇ 코어 라이브러리<button>더보기</button>
			<pre>
				ㅡ 속성 var로 저장된값은 자바변수가 아닌 속성명으로서 저장되는것.
				ㅡ scope속성은 디폴트가 page범위이다.
				ㅡ < c:set>
					ㄴ bean 프로퍼티나 맵형태의 값을 저장하는데 쓰인다.
					ㄴ ex) < c:set var="(*변수명*)" value="(*할당할값*)" scope="(*스코프*)"/>	=>jsp의 setAttribute()와 비슷한기능.
								또는,
						< c:set target="(*빈또는 맵객체*) property="(*해당프로퍼티*)" value="(*할당할값*)"/>	=>이건 빈이나 맵객체에 값저장하는기능.
					ㄴ target에 빈이나 맵의 속성이름이 아닌 객체 자체가 들어가야한다는점 주의. 또한, property값은 빈의 경우 프로퍼티이름이 되고, 맵의 경우 '키'값이 된다.
								ex)
							< %Member member = new Member(); %>

							< %-- member.setName("원종천1")과 동일 --%>
							< c:set target = "< %=member%>" property = "name" value = "원종천1"/>
							< %=member.getName()%> < %--값 원종천1 출력 --%>

							< c:set var = "m" value = "< %=member%>"/>
							< %-- member.setName("원종천2")와 동일--%>
							< c:set target = "${m}" property = "name" value = "원종천2"/>
							${m.name} < %-- 값 원종천2 출력 --%>

							< % Map< String, String> prop = new HashMap< String, Stiring>();%>
							< %--prop.set("host", "localhost")와 동일 --%>
							< c:set target = "< %=prop%>" property = "host" value = "localhost"/>
							< %=prop.get("host")%> < %-- 값 localhost 출력 --%>
								=>이런식으로 맵객체 자체를 target에 넣어줌. 근데 맵객체란게 키값하고 값으로 이루어진거고 키값도 property속성으로 써줄건데
								 이걸사용하는게 의미가 있는지싶긴함.
					ㄴ value값을 이 태그의 몸체부분에서 작성해도된다.
						ex) < c:set ~~>
							(*value값*)
						    < /c:set>
					ㄴ value로 null을 주게되면 해당 속성을 삭제됨.
					ㄴ var속성과 target속성을 동시에 사용할수는 없다.
					ㄴ scope속성에는 page, request, session, application이 올수 잇다.
				ㅡ < c:remove/>
					ㄴ jsp의 removeAttribute()와 같은역할.
					ㄴ < c:set>을 이용해 저장한 변수를 삭제함.
					ㄴ ex) < c:remove var="(*변수명*)"/>
					ㄴ 변수명 부분에는 문자열이 와야함.
				ㅡ < c:out/>
					ㄴ jsp의 표현식과 같은역할
					ㄴ ex) < c:out value="(*변수명*)" default="(*기본값*)" escapeXML="(*참,거짓*)"/>
					ㄴ escapeXML속성 true이면, <,>,&,',"을 문자그대로 출력한다.
				ㅡ < c:if/>
					ㄴ else구문이 없는 if문비슷한거.
					ㄴ ex) < c:if text="(*조건문*)" var="(*변수명)*" scope="(*스코프*)"
							(*참일경우 실행할부분*)
					      < /c:if>
					ㄴ 조건문부분의 참거짓결과를 scope범위의 var변수명으로 속성값저장가능하다
				ㅡ < c:choose/>, < c:when/>, < c:otherwise/>
					ㄴ 자바의 switch문같은것. if~else문이 없어서 이것 대용으로 주로쓰임.
					ㄴ ex) 	< c:choose>
								< c:when text="(*조건문*)">
									(*해당조건만족하면실행할부분*)
								< /c:when>
								< c:when text=~~>
								~~
								< /c:when>
								....
								< c:otherwise>
									(*아직까지만족하는조건없을때실행할부분*)
								< /c:otherwise>
							< /c:choose>
				ㅡ < c:forEach/>
					ㄴ 반복문역할.
					ㄴ var속성에 부여한 변수에다가 반복문의 값을 하나씩 자동으로 매핑함.
					ㄴ 여기서 var은 태그안에서만 유효.
					ㄴ 정수반복이나 자바의 컬렉션(Iterator나 Enumeration클래스)반복을 지원한다.
					ㄴex)	< c:forEach var="(*변수명*)" varStatus="(*추가속성값이름*)" begin="(*정수시작숫자*)" end="(*정수 끝숫자*)" step="(*정수증가값*)">
				  				(*반복실행할부분*)
							< /c:forEach>
								이게 정수반복. 아래는 컬렉션에대한 반복.
							< c:forEach var="(*변수명*)" items="(*컬렉션*)" varStatus="(*추가속성값이름*)" begin="(*시작인덱스*)" end="(*끝인덱스*)" step="(*인덱스증가값*)">
				  				(*반복실행할부분*)
						 	< /c:forEach>
					ㄴ varStatus는 값으로 부여한 이름을 통해 여러 속성값들을 반복문몸체부분에서 호출할수있다.
						ex) ~~~ varStatus="aaa"~~>
							aaa.current	=>현재 item
							aaa.index	=>0부터시작해서 세는 인덱스값
							aaa.count	=>1부터시작해서 세는 인덱스값
							aaa.first	=>첫번째값 여부
							aaa.last	=>마지막값 여부
							aaa.begin	=>begin속성의 값
							aaa.end		=>end속성의 값
							aaa.step	=>step속성의 값

				ㅡ < c:forTokens/>
					ㄴ 문자열을 주어진 '구분자'로 나누어 반복문실행.
					ㄴex)	< c:forTokens var="(*변수명*)" items="(*컬렉션*)" delims="(*구분자*) varStatus="(*추가속성값이름*)"
								begin="(*시작인덱스*)" end="(*끝인덱스*)" step="(*인덱스증가값*)">
								(*반복문실행하는부분*)
							< /c:forTokens>

				ㅡ < c:import>
					ㄴ include()기능. < jsp:include>와 같은방식으로 동작한다.(조금더 좋다고함)
					ㄴ < c:import url="(*url*)">
					ㄴ 현재 웹어플리케이션이 아닌 외부자원도 포함가능하다고 한다.
					ㄴ < c:param> 태그를 이용하여 포함시킬페이지로 요청을 보낼때 파라미터를 넘겨줄수있다.
						ex)	< c:param name="(*파라미터이름*)" value="(*파라미터 값*)"/>
					ㄴ 파라미터를받는 포함될페이지에서는 이를
						${ param.(*파라미터이름*)}으로 사용할수있다.

				ㅡ < c:url>
					ㄴ url을 만들어주는 태그.
					ㄴ ex) < c:url value="(*url*)" var="(*변수명*) scope="(*스코프*)"/>
					ㄴ url속성값에 해당하는 url을 적절하게 만들어줌.
					ㄴ 브라우저가 쿠키지원을하지않아서 세션id저장이 안될때 자동으로 url재작성을하여 jsessiond값을 붙여서 생성해줌.
					ㄴ var속성을 주지않으면 해당위치에 생성된url이 삽입된다.
					ㄴ var과 scope속성을 설정할경우 생성한 url을 scope영역의 var변수명으로 속성값저장해줌.
					ㄴ 몸체부분을가질수있으며, 이부분에 < c:param>을 이용해 url뒤에 붙을 파라미터를 설정할수잇음.
						ex) < c:url value="/userSearch.do" var="url">
				 			 	< c:param name="name" value="홍길동" />
				 			 	< c:param name="page" value="3" />
						    < /c:url>
							=> url 맨뒤에 ~~?name=홍길동&page=3 이런식으로 추가됨.
					ㄴ 이 태그는 url인코딩은 해주지않는다. 하지만 < c:param>을 이용해 파라미터를 넘기면 해당파라미터에 대해 url인코딩을 자동으로 해준다.

				ㅡ < c:catch> 태그)
					ㄴ jsp태그로, try~catch문과 비슷하게 작동한다.
					ㄴ	< c:catch var="(*변수명*)">
							(*예외발생예상부분*)
						< /c:catch>
						=>이런식으로 catch태그로 감싸진부분에서 예외발생시, var에 exception객체가 저장된다.
					ㄴ 이 exception객체가 저장된 변수var을 통해 jsp의 page지시자에서 isErrorPage가 true가 아니어도 exception객체를 사용할수있다.
					ㄴ 이 태그는 try~catch문과 같이 감싸진부분에서 예외가 하나라도발생하면 그 뒤 나머지부분을 전부생략하고 < /c:catch>부분으로 넘어가는방식으로 동작한다.

				ㅡ 그외에도  < c:catch>, < c:redirect>, < c:out>등이 있다.
			</pre>
				*url 인코딩
					ㅡ 브라우저에서 파라미터를 보낼때, url뒤에 파라미터가 추가되는방식으로 전달되는데 이때 파라미터로서 불완전한문자가 있으면 문제가 된다. (가령, 스페이스,공백문자같은건
						 url에 사용할수없는 등) 이때 이런식의 불안전문자, 예약 문자등을 다른문자로 바꾸어주는것을 'url인코딩'이라고 한다.  (공백문자를 '+'로 바꾸어주는 식으로)

			ㅇ 포매팅 라이브러리 : 같은 날짜를 2011년2월12일 이라 표현하거나 2011/2/12라고표현하거나, 0.55이거나 55%이거나 처럼 다양한 포매팅 요구사항을
				  충족시킬수있는  라이브러리제공. 또는 국제화를 지원하는 커스텀액션제공.
				ㄴ국제화
					< fmt:message>, < fmt:setLocale>, < fmt:bundle>, < fmt:setBundle>, < fmt:param>, < fmt:requestEncoding>
				ㄴ포맷팅
					< fmt:timeZone>, < fmt:setTimeZone>, < fmt:formatNumber>, < fmt:parseNumber>, < fmt:parseDate>
			ㅇ SQL 라이브러리
				ㄴ DB접근
					< sql:query>, < sql:update>, < sql:setDataSource>, < sql:param>, < sql:dateParam>
			ㅇ XML라이브러리
				ㄴ코어 xml액션
					< x:parse>, < x:out>, < x:set>
				ㄴ xml흐름제어
					< x:if>, < x:choose>, < x:when>, < x:otherwise>, < x:forEach>
				ㄴ 변환 액션
					< x:transform>, < x:param>


		</pre>
		커스텀태그<button>더보기</button>
		<pre>
			커스텀태그란?<button>더보기</button>
			<pre>
				ㅡ사용자 정의 액션태그로서, 원하는 기능을 가진 함수를 만들듯이 액션태그를 만들어 사용할수있다.
				ㅡ 개인적인 개요)
					ㄴ jstl만으로 부족할때 직접태그를 만들어 사용할때씀.
					ㄴ 로직과 연결시키지않고 그냥 뷰적인 부분에 한해 유용하게 쓰인다함. 여러번 출력하는등.
					ㄴ jstl과 비슷하거나 여기에 속행있다고 생각하면 될듯???
					ㄴ
			</pre>
			자바클래스를 이용한 커스텀 태그 만들기<button>더보기</button>
			<pre>
				ㅡ 두가지 형식으로 만들수 있다) '클래식'과 '심플'
					ㄴ 심플형태가 최근에 나온건데 이를사용하면 대부분원하는것을 다할수있어서 클래식은 거의안쓰임.
					ㄴ 클래식으 쓰일때는 이미클래식형태로 만들어져서 그걸 유지보수할때 정도라고함.

				ㅇ 사용의 전체적인 방식은
					1. 원하는 동작을 수행할 클래스를 만든다.
					2. 해당클래스를 TLD파일에 등록하며 페이지에서 사용하기위한 여러가지 설정을 해준다.
					3. 페이지에서 지시자를통해 해당 커스텀태그를 사용할것이라 선언해준뒤, 만든 태그를 호출하여 사용한다.

				ㅇ 커스텀 태그 사용하는방법
					ㅡ 형식은 다음과같다.
						< %@ taglib prefix="(*prefix*)" uri="(*tld에서 지정한uri*)"%>	=>taglib지시자로 사용할 커스텀 태그를 설정.
							~~
						<(*prefix*):(*태그이름*) (*속성*)="(*속성값*)"/>	=>TLD에서 설정한 데이터를 토대로 커스텀태그 호출.
					ㅡ 여러 커스텀태그를 사용하려면 taglib지시자를 여러개 정의해야함.

				ㅇ TLD파일 등록하는법
					ㅡ 전체적인구조는 다음과같다.
						< tlib-version>~~~
						< short-name>(*아마 tld파일의이름?*)< /short-name>

						< uri> (*jsp지시자 taglib에서 사용할 uri이름*) < /uri>

						< tag>
							< description>< /~~>
							< name>(*태그이름*)< /~~>
							< tag-class>(*태그사용시 컨테이너가호출할 클래스*)< /~~>
							< body-content>(*태그몸체에 관한 설정*)< /~~>

							< attribute>	=>태그의 속성들을 설정하는부분. 속성하나당이 < attribute>태그를 하나 설정해야함. 여러개면 여러개설정.
								< name>(*속성이름*)< /~~>
								< required>(*참거짓값*)< /~~>	=>속성이 필수인지.
								< rtexprvalue>(*참거짓값*)< /~~>	=>속성값을 어떤식으로 표현할지설정.
							< /attribute>
						< /tag>

						ㄴ< name>, < tag-class>, < body-content>는 필수항목이다.
						ㄴ< rtexprevalue>는 속성값이 런타임시 실행(평가)할건지, 변환시 실행할건지 결정하는 태그라고한다.(뭔소린지..)
							ㄴ false이면 String형태만 가능하며, true이면 el표현식, 스크립팅,< jsp:attribute>표준액션으로 표현이가능하다.
							ㄴ 디폴트값은 false. 태그를 정의하지않으면 디폴트설정.
						ㄴ < body-content>는 커스텀태그의 몸체에 무엇이들어갈지를 결정하는부분이다.
							ㄴ 들어갈수있는값으로 empty, scriptless, tagdependent, JSP가 있다.
							ㄴ empty는 몸체가없음을뜻함.
							ㄴ scriptless는 스크립팅(스크립틀릿, 스크립팅표현식, 선언문)이 올수없다는뜻이다.
							ㄴ tagdependent는 태그몸체를 그냥 텍스트로 취급한다.
							ㄴ JSP는 JSP안에 들어갈수있는것이라면 무엇이든지 가능하다는뜻.
						ㄴ < uri>는 url이 아니며, 그냥 커스텀 태그 라이브러리에 붙여주는 유일한 이름일 뿐이다. url형식으로 써있어도 그냥 이름으로서의 기능일뿐.
							동일한 웹어플리케이션 내에서 이 uri가 겹쳐선 안된다. 그러다보니 관습적으로 사용하는게 도메인 이름일뿐이며, 외부로 배포할것이아니라면 굳이 이렇게쓸필요없다.

						*< jsp:attribute>
							ㅡ 태그에 속성을 설정하는 방법의 일종
							ㅡ 태그의 몸체부분에 삽입되어 속성을 정의할수있으며,
							ㅡ 커스텀태그에서 < body-content>가 empty로 설정되어 몸체가 없다고 설정되어있어도 사용가능하다
							ㅡ ex) 	< AAA:aaa>
								  		< jsp:attribute name="(*속성이름*)"> (*속성값*) < /~~>
							      	< /AAA:aaa>
								=>부여하려는 속성이 여러개면 < jsp:attribute>를 여러개 써서 각각 속성값들을 주어야함.

				ㅇ TLD파일의 위치
					ㅡ 컨테이너가 사용자정의태그를 사용하기위해 tld파일을 읽어올때 찾아보는 정해진 위치가 있다.
					ㅡ WEB-INF아래, 또는 WEB-INF안의 디렉토리 아래. 만약, JAR파일로 배포했다면, WEB-INF아래 lib아래 JAR아래에 있는 META-INF아래, 또는 META-INF안의 디렉토리 아래.
						이렇게 네군데이다.

				ㅇ 커스텀 태그 핸들링 클래스 만들기
					ㅡ 커스터태그 호출시 실행되는 클래스를 커스텀태그 핸들링클래스라고한다.
					ㅡ 해당클래스는 SimpleTagSupport클래스를 상속받는다.
					ㅡ doTag()는 해당태그가 실행되면 컨테이너에의해 실행되는메소드로, 사용자가 이를 오버라이딩하여 원하는 작업을 수행한다.
					ㅡ set(*대문자로시작하는 속성이름*)( String (*속성이름*))은 역시 컨테이너에 의해 태그실행시 태그의 속성값들을 가져와 저장해주는 메소드이다.
						메소드이름은 자바빈의 getter,setter과 같은방식으로 설정된다.
					ㅡ 태그핸들링클래스의 일생)
						1. 컨테이너에 의해 클래스 로드를 통해 심플 태그 클래스 .class파일이 가져와짐.
						2. 클래스 인스턴스화로 태그핸들러 디폴트 생성자 실행.
						3. setJspContext(JspContext)호출. 태그핸들러 객체가 pageContext 참조객체를 가짐.
						4. 다른태그 내부에서 커스텀태그가 실행되었다면 setParent(JspTag)호출. 부모태그와 통신이가능해짐.
						5. 속성이있다면 setter호출.
						6. < body-content>값이 empty가 아니라면 setJspBody(JspFragment)호출. 태그몸체에 접근가능.
						7. doTag()호출.

				ㅇ 심플 형태의 커스텀 태그핸들링 클래스
					ㅡ SimpleTagSupport는 SimpleTag인터페이스를 구현하며, SimpleTag인터페이스는 JspTag인터페이스를 상속받는다.
						(각각 어떤메소드를가지고있는지는 api찾아보기)
					ㅡ 심플 태그 핸들러 클래스는 매번 호출때마다 인스턴스를 새로생성하여 작동한다. 캐시에 저장되거나 하는 재사용은 이루어지지않는다.
						클래식 태그 핸들러는 재사용된다고함.

					ㅡ 커스텀 태그 몸체에있는 내용을 사용하고싶으면 TLD에 < body-content>값이 empty가 아니어야하고, 태그핸들링클래스 내부에선
						getJspBody().invoke( (*커스텀태그몸체읽은뒤출력할곳*) ) 을 사용하여 써야한다.

				ㅇ 클래식 형태의 커스텀 태그핸들링 클래스
					ㅡ 커스텀태그를 호출하는 jsp페이지, 등록하는 TLD페이지에서는 심플태그핸들링 클래스를 사용할때와 차이점이없고 핸들러 클래스 코드상에서만 차이가있다.
					ㅡ 클래식 태그핸들러 클래스는 Tag, IterationTag인터페이스를 구현해야하며 보통 이를 구현하는 TagSupport 클래스를 상속받아 만든다.
					ㅡ 클래식 태그핸들러클래스는 컨테이너가 재사용을한다. 인스턴스 멤버변수에 주의.
					ㅡ doStartTag(), doEndTag()메소드를 오버라이딩하여사용. 심플태그클래스의 doTag()같은것. 작동방식은 메소드 이름그대로. 태그 시작할때 실행되는
						doStartTag(), 이후 태그몸체처리하고, 끝날때 doEndTag().
						ㄴ 이외에도 doAfterBody()가있다. 몸체가 실행된 이후에 호출되는메소드. (이 메소드에서 EVAL_BODY_AGAIN을 반환한느것을 통해 몸체부분을 반복할수있다.)
						ㄴ doStartTag()는 SKIP_BODY, doAfterBody()는 SKIP_BODY, doEndTag()는 EVAL_PAGE가 디폴트 리턴값이다.
						ㅡ 오버라이딩한 메소드들은 컨테이너가 다음에 어떤동작을 수행할지 정수형태의 미리정의된값을 반환해야함.
						ㄴ SKIP_BODY : 몸체가 있더라도 실행하지말고 바로 doEndTag()를 실행하라는 값
						ㄴ EVAL_PAGE : 태그를끝내고 페이지뒷부분을 실행하라는값.
						ㄴ EVAL_BODY_INCLUDE : 몸체를 실행시키라는값.
						ㄴ EVAL_BODY_AGAIN : 몸체한번더실행시키라는값.
						ㄴ EVAL_BODY_BUFFERED : BodyTagSupport 클래스를 상속한경우사용가능. 이클래스의 메소드를 실행시키라는값.
						ㄴ ex)	~~~
							return SKIP_BODY;	=>이렇게반환해주면 컨테이너가 반환값에 해당하는동작을취한다.
						ㅡ 클래식 커스텀태그클래스의 메소드 동작순서)
							<img src="image/클래식 커스텀태그 클래스 메소드순서.jpg" style="height:600px; width:auto;">
						1. doStartTag() : 태그 시작할때
							EVAL_BODY_INCLUDE리턴시)
								1-1. 몸체실행정수를 리턴했으면 몸체실행.
								1-2. doAfterBody() : 몸체실행후.
							EVAL_BODY_BUFFERED리턴시)
								1-1. setBodyContent() :
								1-2. doInitBody() :
						2. doEndTag() : 태그 끝날때
						3. 원래 페이지 실행.

				ㅇ 커스텀태그의 동적속성 전달
					ㅡ 커스텀태그에서 속성이 많을경우, 이것들을 일일이 setter메소드로 정의하게되면 코딩이 길어지게 되는데, 이에대한 해결책으로 커스텀태그에서 속성을 전달시 이를
						동적으로 설정해주는 기능이 있다
					ㅡ DynamicAttributes 인터페이스를 이용하면 동적 속성전달이 가능하다. 이 인터페이스의
						setDynamicAttribute( (*uri*), (*속성이름*), (*속성값*) ) 메소드를 이용하면된다
						ㄴ 이 메소드는 해당 커스텀태그의 TLD에서 attribute로 정의되지않은 속성이 커스텀태그로 전달되면 그 속성이름과 값을 인자로 받으며 호출되는 메소드이다.
						ㄴ 매개변수 (*uri*)는 속성의 네임스페이스라고한다. (*디폴트 네임스페이스면 null이라한다.)
						ㄴ uri, 속성이름은 String형이고 속성값은 Object형이다.
					ㅡ 호출되기만 하므로 메소드를 정의해서 사용해야함.
					ㅡ 일반적으로 동적 속성은 name/value 쌍으로 속성을 저장하기좋은 hashmap형태로 저장한다고한다.
					ㅡ 이를 사용하려면 TLD에서 < dynamic-attribute>를 < tag>아래에 추가하고 true값을 설정해주어야한다.
					ㅡ 심플 태그 클래스와 클래식 태그 클래스 둘다 동작한다.
					ㅡ 태그파일로도 사용할수있다.
						ㄴ 똑같은 원리로 동작하며,
						ㄴ tag지시자에서 dynamic-attribute속성을 추가하고 속성값으로 동적 속성을 받을 hashmap형 변수이름을 정해주면 동적속성이 추가될시 이 hashmap변수로 저장된다.
							 속성이름은 hashmap의 'key'라는 이름으로 속성값은 'value'란 이름으로 저장된다.
					ㅡ 주의)
						ㄴ 물론 동적속성을 사용하더라도 기본적인 속성을 설정할수있다. (TLD에서 < attribute>를 사용해서..) 이경우 일반적인 setter메소드를 정의하여 속성값을 받아주어야한다.

				ㅇ BodyTagSupport 클래스
					ㅡ 커스텀태그의 몸체부분을 가지고 어떤 작업을 하고자 할때 사용한다고함.
					ㅡ IterationTag 인터페이스를 상속하는 BodyTag 인터페이스를 구현하는 클래스이며, TagSupport 클래스를 상속한다.
					ㅡ setBodyContent(), doInitBody()가 새롭게 추가되며, doStartTag()에서 EVAL_BODY_BUFFERED를 리턴하면 setBodyContent()가 실행되고 이 메소드 이후에 doInitBody()가 실행된다.
					ㅡ 정확히 무슨 기능을 하는지 잘모르겟다....

				ㅇ 협업태그
					ㅡ 커스텀태그가 부모자식의 구조로 있을때 상위,하위태그사이에 통신을 할수잇는 기능이 존재한다.
					ㅡ 자식태그가 부모태그에 접근)
						ㄴ SimpleTag인터페이스와 Tag인터페이스에있는 getParent()메소드로 부모태그에 접근할수잇고 이를통해 부모의 태그와 통신할수있다.
						ㄴ findAncestorWithClass( (*시작태그*), (*찾고자하는태그핸들러클래스*) )를 이용해 부모를넘어선 조상커스텀 태그 클ㄹ래스를 바로찾을수있다.
					ㅡ 부모태그가 자식태그에 접근)
						자식태그쪽에서 getParent()로 부모태그클래스에 접근한 다음 자신을 부모태그클래스에 등록해둔다.
					ㅡ getParent()의 반환형을 보면 알수있지만 심플커스텀태그 클래스는 같은 심플커스텀태그클래스는 물론 클래식 커스텀태그 클래스도 부모태그로 가질수있다.
						ㄴ클래식 커스텀 태그 클래스는 같은 클래식 태그클래스밖에 부모로 가질수없다.

				ㅇ 커스텀태그 핸들러 클래스와 PageContext
					ㅡ 커스텀태그핸들러클래스는 서블릿도, jsp도 아니기때문에 내장객체접근이 바로는안되지만 PageContext에 대한 참조를 가지고있어서 필요한 내장객체를 사용할수있다.
					ㅡ 클래식커스텀태그 클래스의경우 PageContext, 심플커스텀태그 클래스의 경우 JspContext이다.

			</pre>
			태그파일을 이용한 커스텀 태그 만들기<button>더보기</button>
			<pre>
				ㅇ 태그파일이란?
					ㅡ jsp문법을 이용해 개발한 커스텀태그이며, 간단하여 내부용?으로 사용된다고한다.
					ㅡ jsp페이지처럼 작성을 하며, 태그파일만의 지시자를 가진다.

				ㅇ 태그파일 만들기??
					ㅡ jsp파일의 일종이므로 만드는것도 jsp페이지와 거의 유사.
					ㅡ 지시자는 태그파일만의 지시자 사용.
					ㅡ 작성후 파일의 확장자를 '.tag'로 저장.
					ㅡ 파일의 이름이 커스텀태그의 이름이 된다.
					ㅡ jsp파일이기도하므로 jsp의 내장객체 사용가능. (단, ServletContext는 없고 대신 JspContext를 사용해야함)

				ㅇ 태그파일의 지시자들
					ㅡ jsp의 지시자와 똑같이 < %@ (*지시자*) ~~ %> 형식을 사용한다.

					ㅡ taglib : 태그파일에서 사용할 태그라이브러리를 명시할때 사용. 문법은 jsp페이지와동일.
					ㅡ include : 태그파일에 특정파일을 포함시킬때사ㅏ용. 포함될파일은 태그파일에맞는문법으로 작성해야함.(?)

					ㅡ variable : EL변수로 사용될 변수에 대한 정보를 지정.

					ㅡ attribute 지시자 : 태그파일이 커스텀태그로쓰일때 입력받을 속성명시.
						ㄴ attribute 지시자 속성들)
							ㄴ description : 속성에 대한 설명
							ㄴ name : 속성 이름, 태그 파일 내에서 스크립트 변수나 EL변수의 이름으로 사용, 각각의 attribute 디렉티브는 name 속성의 값이 달라야한다. tag 디렉티브(dynamic-attributes), variable 디렉티브(name-given) 속성과 값이 같으면 에러가 발생한다.
						 	ㄴ required : 속성의 필수 여부를 지정, 필수일 경우 true 아닌 경우 false를 값으로 지정, 기본값은 false
						 	ㄴ rtexprvalue : 속성 값으로 표현식을 사용할 수 있는지의 여부를 지정, 기본값은 true
							ㄴ type : 속성 값의 타입을 명시, int 등의 기본 데이터 타입은 명시할 수 없고 java.lang.Integer 와 같은 래퍼 타입을 사용, 기본값은 java.lang.String
							ㄴ fragment : < jsp:attribute> 액션 태그로 속성값을 전달할 때 true로 지정, true일 경우 rtexprvalue은 자동으로 false, type은 javax.servlet.jsp.tagext.JspFragment가 된다.
						ㄴ  전달한 속성값 사용법)
							attribute지시자로 전달한 속성은 지시자의 name속성값을 태그파일 안에서 스크립트요소나 EL식으로 변수처럼 사용할수있다.
						ㄴ 전달한 속성값의 생존범위)
							이렇게 부여된 속성값은 모두 tag생존범위이다. tag생존범위란 태그범위내, 태그파일 안에서만 유효한것.
						ㄴ 커스텀태그 몸체 전달하기)
							 전달하려는 속성값이 많다면 태그의 몸체를 통째로 넘기는 방법도 있다.
							1. tag파일의 tag지시자에 body-content속성값으로 empty대신 tagdependent 또는 scriptless로 설정한다.
							2. 태그파일에서 < jsp:body/>를 이용해커스텀태그의 몸체내용을 그대로 가져온다.
							ㄴ 커스텀태그의몸체를 전달하려할때 몸체에는 일반텍스트, EL, < jsp:include>만 올수있다. 스크립트요소는 x.

						ㄴ 속성 fragment가 true일경우)
							ㄴ attribute지시자의 fragment 속성값이 true이면, jsp에서 이 커스텀태그로 속성값을전달할때 < jsp:attribute>액션태그를 사용해야한다.
							ㄴ < jsp:attribute>의 몸체에는 텍스트, EL, < jsp:include>액션태그를 사용할수있다.(스크립트코드는x)
								*< jsp:attrubute>
								ㅡ 몸체에는 텍스트, EL, < jsp:include>액션태그를 사용할수있다.(스크립트코드는x)
								ㅡ 속성으로
								ㄴ name : 속성의 이름. 필수.
								ㄴ trim : 속성값 좌우의 공백문자들을 제거할지의 여부. 기본값은 true.
							ㄴ 이렇게 설정한 속성값은 태그파일에서 < jsp:invoke> 액션태그를 이용해 사용가능.
								*< jsp:invoke>
								ㅡ ~~~~~~~~~~~~~~~

					ㅡ tag지시자 : jsp페이지의 page지시자와 같은역할. 태그파일의 정보를 표시.
						ㄴ 속성들)
							ㄴ display-name : 태그 파일을 도구에서 보여줄 때 사용될 이름을 지정, 기본값은 확장자 ".tag"를 제외	한 태그 파일의 나머지 이름이다.
							ㄴ body-content : 몸체 내용의 종류를 입력, empty, tagdependent, scriptless 중 한가지를 사용, 기본값은 scriptless
							ㄴ dynamic-attributes : 동적 속성을 사용할 때, 속성의 < 이름,값>을 저장하는 Map 객체를 page 범위에 속성에 저장할 때 사용할 이름을 명시, EL에서 변수이름이로 사용할 수 있다.
								( JSP 페이지의 pageContext 와 비슷하게 jspContext 기본 객체를 지원한다. )
							ㄴ description : 태그에 대한 설명
							ㄴ import : 사용할 자바 클래스를 지정
							ㄴ pageEncoding : 페이지 자체의 캐릭터 인코딩을 지정
							ㄴ isELIgnored : page 표현 언어를 지원할 여부를 지정
							ㄴ deferredSyntaxAllowedAsLiteral : #{ 문자가 문자열 값으로 사용되는 것을 허용 여부를 지정
							ㄴ trimDirectiveWhitespaces : 출력 결과에서 템플릿 텍스트의 공백 문자를 제거할지의 여부를 지정

				ㅇ  태그파일 위치 ( 컨테이너가 태그파일을 찾는 위치)
					ㅡ WEB-INF아래에 tags폴더 또는 그 하위폴더에 위치.
					ㅡ 또는 WEB-INF/lib에 JAR파일로 배포되었다면, JAR파일 META-INF/tags폴더 또는 그 하위폴더에 위치.

				ㅇ  사용방법)
					ㄴ jsp페이지에서 taglib지시자이용.
					ex)	 <%@ taglib prefix=" (*prefix*) tagdir=" (*tag파일이있는 위치*) " %>
						~~
						<(*prefix*) : (*tag파일 이름*) ~~> ~~ < /~~>
						ㄴ 커스텀 태그 몸체에 스크립팅요소(js, 표현식)을 사용할수없다.

			</pre>
			기타<button>더보기</button>
			<pre>
				*JspFragment 클래스
					ㅡ jsp코드를 나타내는 객체.
					ㅡ 심플 태그핸들러나 < jsp:attribute>액션의 몸체부분에 쓰인다.
					ㅡ 내용으로 스크립팅요소를 사용할수없다.
					ㅡ invoke( (*java.io.Writer*) ) 메소드가 정의되어있어서 내용을 해당 Writer로 출력한다.

				ㅇ SkipPageException
					ㅡ 심플태그핸들러에 의해던져지며,
					ㅡ 페이지의 나머지부분이 처리되지않도록한다. 중단시킨다.
					ㅡ 이 예외를던지면 이후에 부분의 처리를중지하고 지금까지처리한부분만 응답으로 넘김.
					ㅡ 태그를 직접호출한 페이지으작업만 중지한다.

				ㅇ 클래식 태그핸들러 클래스
					ㅡ 오버라이딩한 메소드에서 던지는 예외도 JspException 하나이다. IOException은 따로 처리해주어야한다.
			</pre>


		</pre>
		웹 어플리케이션 배보<button>더보기</button>
		<pre>
			ㅡ 웹 사이트 배포란?
				개발된 사이트를 일반사용자가 사용할수있도록 프로덕션 서버에 올리는 작업을 말한다.
			ㅡ 배포의 주요 토픽세가지)
				ㄴ 웹어플에 어느 위치에 개발한 것들을 저장하는가
				ㄴ 컨테이너는 웹어플에 어느위치에서 자원을 찾는가
				ㄴ 웹 어플 컨텐츠를 어떻게 요청하면 되는가

          		* 배포 툴이나 ANT빌드 스크립트? 를 이용하면 쉽게 배포할수있다고함
				ㅡ 하지만 내부적으로 어떻게 ㄷ동작하는지는 알아야하지않을까.

			* 아카이브 파일
				ㅡ 뭔가를 저장한다는 뜻으로, 압축파일을 의미한다.
				ㅡ zip, rar, jar, war, ear 등등의 확장자가 있다.

			* jar파일이란
				ㅡ 일종의 자바 프로젝트 압축파일이다. 자바프로그램이나 자료등을 패키징하는 기능.
				ㅡ 아카이브 파일의 일종. 여러개의 파일을 하나의 파일로 묶어놓은것. 디렉토리정보를 가진채 들어있다.
				ㅡ zip파일 압축 알고리즘을 기반으로 만들어져 알짐과같은zip프로그램과 호환가능하다.
				ㅡ jar cf (*압축된파일의 이름*) 이런식으로 압축을하고, far xf (*압축풀려는파일이름*) 을 이용해 압축을 푼다.
				ㅡ 압축을 풀면 META-INF란 폴더가생기며 안에 manifest.mf파일이 생겨있는데 이는 jar파일의 사용메뉴얼이나 스펙등의 내용을 담고있다고보면된다.

			*WEB-INF/lib 폴더
				ㅡ jar파일을 넣어둘수있는 폴더.
				ㅡ 이곳에 .jar파일을 넣어두면 이 파일을 classpath에 추가한것처럼 사용이 가능해짐.
			* WEB-INF폴더
				ㅡ 웹 어플리케이션용으로 따로만들어진폴더.
				ㅡ 자원이 노출되지 않도록 만든 폴더.

			ㅡ WAR파일
				ㄴ Web Application ARchive.
				ㄴ 자바에서 웹관련 자원을 모으는 jar파일이다.
				ㄴ jar, war 모두 그냥 파일을 패키지화하여 저장하는파일로, 프로젝트에서 라이브러리로 추가하기만하면 그 파일을 사용할수있다. 톰켓에 있는 .jar파일들을
					라이브러리 추가해서 프로젝트만들던것처럼.
				ㄴ 웹 어플리케이션에선 웹 어플리케이션 디렉토리 자체를 압축하는것이 아닌 웹어플리케이션 디렉토리'에서' 압축을 실행한다.
					ㄴ 따라서 압축한war파일과 웹어플리케이션의 이름이 같지않고, 컨테이너가 이를 매핑해야하는데 이 매핑하는 방식이 컨테이너마다 조금씩 다르다고한다
						(톰캣의 경우 war파일과 웹어플리케이션의 이름을 일치시켜준다고함)
				ㄴ war파일이라고 다른 웹어플리케이션 구조와 거의 다를건 없고 그대로 저장되어 옮겨짐. 차이점이라고는 META-INF라는 폴더하 하나 추가되며,
					안에 MANIFEST.MF파일이 추가됨.
				ㄴ 배포방법)
					ㄴ webapps폴더에 war파일을 옮겨놓기만하면 톰켓이 알아서 해당 웹어플리케이션 폴더를 만들어 압축을푼다고함.

			ㅇ 자원의 위치
				ㅡ 유저에 의해 직접 접근되어도 상관없는 자원은 웹 어플리케이션 폴더 아래에 두는식으로,
				ㅡ 직접접근하면 안되는 자원은 WEB-INF나 META-INF아래에 두면된다. 이 두폴더 아래에있는 자원들은 직접 요청될수 없다.

			ㅇ DD를 통한 서블릿 매핑 방법
				ㅡ < url-pattern>을 통해 요청받는데 이 url-pattern은 실제 구조가 아닌 만들어낸 가상/논리 구조이다.
				ㅡ url-pattern을 ' /Beer/* ' 이런식으로 디렉토리까지만 설정할수있고, ' *.do ' 와같이 확장자까지만 설정할수있다.
				ㅡ url-pattern을 통해 매핑하는 방법)
					1. 우선 요청받는 url과 완전히 패턴이 일치하는 < url-pattern>을 찾아 매핑
					2. 디렉토리가 일치하는 패턴을 찾아 매핑
					3. 확장자가 일치하는 패턴을 찾아 매핑

			ㅇ 환영파일 설정하기
				ㅡ 위와같은 url-patten으로도 일치하는 파일을 찾지못할경우 연결시켜줄 '환영파일'을 설정할수있다.
				ㅡ DD에 < web-app>아래에 < welcom-file-list>태그를 입력한다
					ㄴ < web-app>
						< welcome-file-list>
							< welcome-file> (*환영파일이름*) < /~~>
							< welcome-file> (*환영파일이름*) < /~~>
						< /~`>
					  < /~~>

				ㅡ 작동방식)
					일치하는 파일을 못찾으면 해당 url-pattern의 위치에 welcome-file-list목록에 있는 파일이있는지찾는다. 위에서부터 찾으며, 찾으면 그 페이지 반환.
				ㅡ 사용자가 정확한 자원이름을 입력하지않아도 사이트에 들어올수잇게하는데 쓰인다.

			ㅇ 최초 요청이 아닌 배포시점에 서블릿 초기화하기
				ㅡ 서블릿은 보통 최초 요청시 초기화된다. 이경우 클라이언트쪽에서 이작업을 해야하므로 부담이된다.
				ㅡ DD에서 < load-on-startup>을 이용하여 배포되는시점에서 서블릿을 초기화하도록 설정할수있다.
				ㅡ 사용법)
					< load-on-startup> (*정수*) < /~~>	=>양수일경우 배포시점에서 초기화하도록 설정. 여러개가 초기화되어야하는경우 정수가 작은것이 먼저 초기화됨.
				ㅡ 팁)
					모든 서블릿을 배포시점에서 초기화하는게 좋은것만은 아니다. 거의 안쓰이는 서블릿, 다른서블릿들이 아주 많다는점, 서블릿이 얼마나 오래 메모리에 있어야하는지
						등을 고려해야한다.



		</pre>
		웹 보안<button>더보기</button>
		<pre>
			기본<button>더보기</button>
			<pre>
				ㅡ 보안은 컴포넌트에 의해 제공된다.
					ㄴ 컴포넌트는 '선언적 보안'과 '프로그램적 보안'을 제공한다.

				ㅡ 거의 대부분의 보안관련설정은 선언적으로 이루어진다고한다. 이유는 대략..
					ㄴ 선언적 보안에쓰이는xml은 모르는사람이 없으니까
					ㄴ 서블릿을 더 유연하게쓸수있어서
					ㄴ 유지보수가 쉬워서
					ㄴ 컴포넌트기반 개발을 할수있어서 등등..

				ㅡ 보안의 주요 이슈 4가지
					ㄴ 인증
					ㄴ 인가
					ㄴ 기밀성
					ㄴ 무결성

				ㅡ 역할정보(Role) 설정방법)
					ㄴ 컨테이너마다 이를 설정하는 형태가 다르다고한다.
					ㄴ 톰캣의 경우 conf폴더의 "tomcat-users.xml"이란 파일 안에 저장되어있다. 이를 "톰캣 메모리 상주 영역(Realm)"이라 한다고한다.
						근데 보통 이거 안쓰고 DB같은거 사용한다함.
					ㄴ "tomcat-users.xml"파일은 모든 어플리케이션에 적용되는 내용이 들어있다.
					ㄴ 이 파일안의 역할정보 표현 형식은 다음과 같다.
						< tomcat-users>
							< role rolename="~~~"/>		=>역할의 이름을 설정한다.
							< role rolename="~~~"/>
							< user name="~~~" password="~~~" roles="~~, ~~"/>	=>사용자의 이름과 비밀번호를 설정하고 역할을 부여한다.
						< /tomcat-users>
					ㄴ DD에 < security-role>요소
						< security-role>
							< role-name> ~~~~ < / role-name>	=>컨테이너가 '역할정보'를 이 요소의 값과 매핑한다.
						< /security-role>
				ㅡ '인증'메커니즘을 사용하려면 DD에 다음과같은내용이 있어햐한다.
					< login-config>
						< auth-method>BASIC< /auth-method>
					< / login-config>

			</pre>
			선언적 보안<button>더보기</button>
			<pre>
				ㅡ DD와 Annotation에 보안 요구사항을 나타내는 방식의 보안방법이다.
				ㅇ 예시)
					< security-constraint>
					    < web-resource-collection>	=>보호받을 자원들의 컬렉션을 선언하고있다. 여러개 사용할수있다.
					        < web-resource-name>Protected Area< /web-resource-name>		=>필수 입력사항이다.
					        < url-pattern>/security/protected/*< /url-pattern>
					        < http-method>PUT< /http-method>	=> 이요소를 등록하지않으면 모든 메소드에대해 제약을건다는 의미가된다. 반대로 등록한다면, 여기에 등록하지않은 모든 메소드를 허용한단의미.
					        < http-method>POST< /http-method>
					    < /web-resource-collection>		=>이렇게 작성하면, "/security/protected/*"인 url에 대한 HTTP PUT메소드와 POST에 대해 제약을 건다는 의미가된다.

					    < auth-constraint>		=>위 컬렉션에 접근권한을가질 role이름을 설정하고있다. < security-constraint>안에 모든 < web-resource-collection>에 대해 적용된다.
					    							역시 옵션항목으로, 관련url에 대해 인증을 실시하라고 컨테이너에게 전달하는의미. 없으면 url에대해 인증없이도 접근가능.
					        < role-name>manager< /role-name>	=>이 요소는 옵션항목으로, 값에 해당하는 '역할'은 접근을 허용하라고 컨테이너에게 전달하는기능.
					        										 만약 하나도 없다면 어떤 사용자도 접근이 안된다는의미가된다. 값으로 '*'가오면 모든사용자 접근가능. 값은 대소문자를 구분함.
					    < /auth-constraint>

					    < user-data-constraint>		=>	전송되는 데이터의 무결성과 기밀성을 설정하기위한 요소.
					    	< transport-guarantee> (*NONE, INTEGRAL, CONFIDENTIAL중 하나*) < />	=>	NONE은 데이터보호를 안하겟단의미. INTEGRAL은 무결성보장하겟단의미,
					    																			CONFIDENTIAL은 기밀성을 보장하겟단의미. (일반적인 컨테이너는 SSL을사용하기때문에
					    																			INTEGRAL, CONFIDENTIAL 둘중 무엇을써도 무결성과 기밀성을 보장해준다함)
					    < /user-data-constraint>
					< /security-constraint>

					 <!-- Security roles used by this web application -->
					< security-role>		=>어플리케이션에서 사용할 role들을 선언하고있다.
					    < role-name>manager< /role-name>
					< /security-role>
					< security-role>
					    < role-name>employee< /role-name>
					< /security-role>

				ㅡ 자원의 단위로 제약을 거는게 아니라 HTTP요청(메소드)단위로 제약을 거는것이다.

				ㅡ 같은 자원에 대해 두개이상의 < security-constraint>가 정의되어있다면, 두 < auth-constraint>의 내용에 따라 접근제어가 달라진다.
				 	ㄴ 둘중 한 < security-constraint>에 < auth-constraint>가 정의되어있지않다면(누구나 접근가능하단의미의 경우), 어떤 '역할'이든 접근가능하다.
				 	ㄴ 둘중 한   < security-constraint>에 < auth-constraint>의 내용이 없다면(< role-name>이 없다는 얘기로, 누구도 접근이 안되는경우), 누구도 접근할수없다.
				 	ㄴ 이 외의 경우에 어떤 '역할'이 등록되어있으면 어느쪽의 < security-constraint>이든 등록된 '역할'들은 모두 접근가능하다.

				ㅇ 인증의 4가지 방식
					ㅡ 컨테이너가 제공하는 방식이 4가지가 있고, 이들간의 가장 큰 차이는 '이름과 패스워드 정보를 얼마나 안전하게 전송하느냐'이라한다.
						1. BASIC : 로그인 정보를 '인코딩'(암호화하지는 않은상태) 형태로 전송. 인코딩방식인 base64는 잘알려진방식이기때문에 별로 안전하지않다.
						2. DIGEST : 보다 안전하게 전송함.
						3. CLIENT-CERT :  '공인 키 인증(PKC)'를 이용하여 매우 안전한 형태로 로그인정보를전달. 단점은 클라이언트가 시스템에 로그인하기전에
								인증서를 가지고있어야한다는것. 보통환경에서 가지고있기는 드물기에 비즈니스환경에서 주로쓰는방식.
						4. FORM : 위 세가지 방식과 달리 로그인정보를 넣기위한 방법으로 표준 팝업 폼을 사용하지않음. 자신만의 로그인폼을 제공하는방식이며,
								가장 보안이 약한방식. 로그인정보가 HTTP요청 형식으로 암호회되지않고 서버로 전송됨.
					ㅡ 각 방식을 사ㅏ용하는법은 DD의 < web-app>요소 아래에 < login-config>를 이용해 설정.
						ex)	< login-config>
								< auth-method> (*BASIC, DIGEST, CLIENT-CERT, FORM 중 하나 *) < /auth-method>
							< /login-config>
					ㅡ BASIC, DIGEST, CLIENT-CERT방식은 이 방식이 지원이 된다면 컨테이너가 알아서 처리해준다.
					ㅡ FORM방식을 사용할경우 < login-config>안에 추가로 설정해야할것들이있다.
						ㄴ 개요) 	1. 사용자가 로그인할 폼 페이지를 작성한다.(html이나 jsp)
							2. 로그인 실패시 보여줄 오류페이지를 html로 작성한다.
							3. < login-config>에 이둘을 묶어준다.
						ㄴ DD에 설정 ex)
							< login-config>
								< auth-method>FROM< />
								< form-login-config>	=>FORM방식 사용시 추가로 설정할 부분.
									< form-login-page> (*로그인 페이지url*) < />
									< form-error-page> (*로그인실패시 오류페이지 url*) < />
								< />
							< />
						ㄴ 로그인페이지 작성)
							~~~
							< form method="~~" action = " j_security_check " >	=>컨테이너와의 협업을위해 action은 저값이어야함.
								< input type="text" name="j_username">	=>사용자이름에 해당하는 input의 name값도
														j_username으로 정해져있음.
								< input type="password" name="j_password">	=> 비밀번호도 마찬가지.
								< input type="submit">
							< />
						ㄴ 에러페이지는 그냥 만들면된다.

				ㅇ '안전이 보장된 전송 계층 연결'
					ㅡ 이를 사용하면, FORM방식을 사용해도 전송되는 데이터의 '무결성'과 '기밀성'을 지킬수 있다.
					ㅡ 보통 SSL기반 HTTPS를 사용하여 이를 사용하게된다.
					ㅡ 그냥 HTTP요청과 달리 HTTPS요청은 강력한 보안처리가 되기때문에 요청의 내용을 제 3자가 볼수 없다.
					ㅡ < user-data-constraint>의 < transport-guarantee>를 이용하여 설정한다.
					ㅡ 보안방식 과정)
						ㄴ < transport-guarantee>가 NONE인경우)
							1. 클라이언트가 요청을보냄
							2. 컨테이너는 요청한 자원에대해 전송보장방식을 확인, NONE이란것을 확인.
							3. 컨테이너는 클라이언트에게 401응답을 보내 로그인정보를 물어봄.
							4. 로그인정보가 보호되지 않은 형식으로 컨테이너에게 날라오고, 컨테이너는 클라이언트가 권한이있는지확인하고 요청햇던 자원을
								보내줌.
						ㄴ < transport-guarantee>가 INTEGRAL이나 CONFIDENTIAL인경우)
							1. 클라이언트가 요청을보냄
							2. 컨테이너는 요청한 자원에 대해 전송보장방식을 확인, INTEGRAL(CONFIDENTIAL)임을 확인.
							3. 컨테이너는 클라이언트에게 301 Redirect응답을 보내어 "안전한 방식으로 다시요청할것을 요청"
							4. 클라이언트는 HTTPS와 같은 안전한 전송방식으로 같은 요청을 다시보냄.
							5. 컨테이너는 요청한 자원에 제약이 걸려있음을 확인하고 401응답을 보냄.
							6. 클라이언트는 로그인정보를 보냄(보안연결을 통해 전송되어 안전하게전송됨).
						ㄴ 즉, 전송보장방식이 설정되어있으면 컨테이너는 보안연결이 되어있지않으면 요청을 받지않는것.

				ㅡ DD에서 사용되는 요소들은 다음과 같다.
					1. < security-constrain>
						ㄴ URL매핑을 사용해서 자원의 컬렉션에 대한 접근권한을 정의한다. 여러개 사용할수있다.
						ㄴ 하위 요소로 다음이 있다)
							1-1. < web-resource-collection> : 보안규제가 적용되어야할 자원집합이나 HTTP 메소드를 선언하는요소.
								ㄴ < web-resource-name> :
								ㄴ < url-pattern> : 보호받을 요청url을 나열하는 요소. 입력하는 request URL은 호스트이름과 포트이름이후에 나오는 URL의 일부를 말한다.
									ex)	/cart/* 라고 썼으면,
										http://localhost:8080/myapp/index.xhtml => 보호되지않음
										http://localhost:8080/myapp/cart/index.xhtml => 보호됨.
								ㄴ http-method 또는 http-method-omission : 어떤메소드가 보호되어야하고 아닌지를 명시한다. HTTP메소드는 다음상황중 하나 아래있을때 web-resource-collection에 의해 보호된다.
									ㄴ 컬렉션에 명명된 HTTP메소드가 없는경우. 이는 모든 메소드가 보호되고있음을 의미한다.
									ㄴ 컬렉션이 < http-method>에 HTTP메소드를 명명하고있는경우,
									ㄴ If the collection contains one or more http-method-omission elements, none of which names the HTTPmethod
							1-2. < auth-constraint> : 컬렉션에대한 접근이 허가되어야하는 role들을 선언하는요소.
								ㄴ < role-name>하위요소가 있고, 이는 인가받을 권한이있는 role이름들을 명시하는요소이다. 여러개 사용할수있다.
								ㄴ 내용으로오는 role 이름은 < security-role>의 이름중하나와 일치하거나, 모든 role을 의미한느 예약 '*'이어야한다.
								ㄴ role name은 대소문자를 구분한다.
								ㄴ The roles defined for the application must be mapped to users and groups defined on the server, except whendefault principal-to-role
									mapping is used.
								ㄴ??? 서블릿의 경우, @HttpConstraint, @HttpMethodConstraint어노테이션이 rolesAllowed요소를 받는다.
							1-3. < role-name> : 여기서 사용되는 < role-name>은 < security-role>의 < role-name>중 하나와 일치해야한다. 또는 특별하게
									예약된 role-name인 '*'이어야한다(어플리케이션의 모든 role을 지칭하는 이름).
							1-4. < user-data-constraint> : 클라이언트와 컨테이너간 통신되는 데이터가 어떻게 보호되어야하는지를 하위요소인 < transport-guarantee>를통해 나타내는 요소.
									< transport-guarantee>는 NONE, INTEGRAL,CONFIDENTIAL의 값중하나를 가질수있다.
									ㄴ < transport-guarantee>하위요소를 가진다. 이요소는 모든 보호받는 url pattern과 http메소드가 HTTPS같은 보호받는 transport-layer 연결을 사용하도록하는데 쓰인다.
									ㄴ 내용으로 올수있는것으론, CONFIDENTIAL, INTEGRAL, NONE이 있다. 앞의 두개의 사용은 보통 SSL사용의 요청과 < web-resource-collection>에있는 URL패턴에 해당하는
										요청에대해 SSL을 적용시키는걸 의미한다.
									ㄴ CONFIDENTIAL : 다른 개체가 전송되는 내용을 보지못하도록 데이터가 전송되는게 요구될때 사용한다.
									ㄴ INTEGRAL : 데이터가 변경되지않으면서 서버와 클라이언트사이를 전송되는게 요구될때 사용한다.
									ㄴ??? NONE : 연결이 보호받지 않을지라도 어떠한 연결위에서의 보호받는 요청도 컨테이너가 수용함을 의미한다.
					2. < login-config요소>
						ㄴ < auth-method> : 인증 메커니즘을 설정한다. BASIC, DIGEST, FORM, CLIENT-CERT, 또는 vendor-specific 인증스키마를 값으로가진다.
						ㄴ < realm-name> : 인증스키마에 사용될 realm name을 가리킨다.
						ㄴ < form-login-config> : FORM 기반 로그인 메커니즘사용시 사용되어야할 login과 에러페이지를 명시한다.
					3. < security-role요소>
						ㄴ security role을 정의한다.
						ㄴ < role-name> : 값으로 security role의 이름을 지정한다.


				 ㅡ tip)
				 	ㄴ 자원에 누구도 접근못하게하는 경우는 보통 클라이언트로부터 접근은 막아야하지만 같은 어플리케이션에잇는 컴포넌트로부터는 허용해야하는 경우사용된다. dispatch해야
				 		하는경우처럼.

			</pre>
			프로그램적 보안<button>더보기</button>
			<pre>
				ㅡ 코딩안에, 프로그램적으로 보안을 하는 방법이다.
				ㅡ 선언적 보안만으로 충분치 않을때 유용하게 쓰인다.
				ㅡ EJBContext 인터페이스와 HttpServletRequest 인터페이스의 메소드를 통하여 구현한다.
				ㅡ HttpServletRequest 인터페이스의 메소드들)
					ㄴ authenticate( (*HttpServetResponse형 인자*) ) : caller를 대상으로 '인증'을 실행한다. 로그인창이뜨고, 사용자 이름과 비밀번호를 입력하게한다.
					ㄴ login :
					ㄴ logout :
					ㄴ getRemoteUser : 유저가 인증받았다면 해당 유저를반환. 인증받지않았다면 null반환. (잘사용안된다함)
					ㄴ isUserInRole( (* DD의 < role-name>값에 해당하는 문자열*) ) : remote user가 특정 role인지를 확인. 인자로 넘어가는 문자열은
						< security-role-ref>의 하위요소인 < role-name>의 값을 말함. (< security-constraint>의 < role-name>이 아니라)
						선언적 보안처럼 HTTP요청 레벨에서 보안을하는게 아니라 메소드 내에서 보안작업을 하는데 쓰인다. 이 메소드를 이용해 '역할'에따라 다른 작업을 할수있다.
						이 메소드를 사용하려면 먼저 '인증'을 거쳐야함. 아되어있으면 false반환. 해당 역할이 맞으면 true반환.
					ㄴ getUserPrincipal : 현재 인증받은 사용자의 java.security.Principal 객체를 반환. (EJB에서 주로사용하는거라함)

				ㅡ < securty-role-ref>
					ㄴ '역할'을 가상의, 임시 이름으로 사용할수있게해주는 요소이다.
					ㄴ isUserInRole()은 인자로넘어온 '역할'이름을 < security-role>보다 이 요소에서 먼저 찾아서 매핑한다.
					ㄴ DD에 선언되는 < servlet>의 하위요소이다.
					ㄴ 어플리케이션에 정의된 security role과 위에 나온 메소드 isUserInRole( role )의 인자로넘어가는 role name을 매핑해준다.
					ㄴ ex)
						< servlet>
							< security-role-ref>
								< role-name> (*isUserInRole()의 인자로 넘어갈 문자열 role name*) < /role-name>
								< role-link> (*security role중 하나의 이름.*) < /role-link>
							< /security-role-ref>
						< /servlet>
						~~~
						< security-role>
							< role-name> (*security role이름*) < /~~>
						< /security-role>
						=>컨테이너가 isUserInRole()의 인자로 받은 문자열을 < role-name>에서찾아 해당하는 < role-link>의 이름을 < security-role>의 < role-name>에서 찾아 매핑한다.
							ㄴ 이 요소 선언없이 isUserInRole()가 호출되면, 컨테이너는 이 메소드의 인자로넘어온 role name을 모든 security role리스트와 비교한다.
								(근데 이렇게사용하는건 이 요소를통해 얻을수있는 유연성(서블릿컴파일을 다시할필요없이 role name을 바꿀수있는등)을 가지지못한다고한다)

			</pre>
		</pre>
		MVC패턴<button>더보기</button>
		<pre>
			ㅡ MVC 패턴
    			ㄴ 간단하게 말해, 로직부분과 뷰부분을 나누어서 깔끔하고 재사용성 등을 좋게하는 방법론 같은것.
    			ㄴ 컨트롤러, 뷰, 모델 세부분으로 나뉘며, 뷰는 보여지는결과부분, 모델은 로직담당부분 컨트롤러는 이둘을 연결하고 컨트롤하는
    			   부분이라고 보면되겟다.
	    	ㅡ대략적인 MVC 아키텍쳐 동작과정
	    		1. 클라이언트가 페이지를 요청
	    		2. 컨테이너는 어떤서블릿인지 알아내어 해당 서블릿에게 요청을 보냄.
	    		3. 서블릿(컨트롤러역할)은 java파일(모델역할)을 호출하여 필요한 정보를 얻고
	    		4. request객체를 만들어 jsp파일(뷰역할)로 forward시킴.
	    		5. jsp파일에서 클라이언트로 보내줄 결과를 컨테이너로보내면 컨테이너는 결과를 클라이언트에게 출력해줌.
	    	ㅡ 개발을 하는데 있어서 정형화된 디렉토리 구조 형식이 있는듯하다.
	    		이런식(https://www.oreilly.com/library/view/head-first-servlets/9780596516680/httpatomoreillycomsourceoreillyimages2244157.png.jpg)
	    	ㅡ 웹 개발 디렉토리 구조가 있고, 이를 배포하려면 사용할 컨테이너가 지정하는곳으로 디렉토리의 일부를 복사해주는것으로 끝난다고함.
	    		ex)내가 서블릿 컴파일한 서블릿클래스 파일을 톰켓의 WEB-INF/classes폴더 안으로 넣어주어야 작동하는것처럼.
	    	ㅡ 컨트롤러가 자바프로그램에서 핸들러같은느낌인가? 뷰는 뭔지알겟고. 컨트롤러와 모델이 헷갈림.
	    		요청을 컨트롤러(서블릿)이 받아서 자바파일(일반클래스, 모델)을 호출해 처리하고 뷰담당인 jsp페이지로 넘기는 방식?컨트롤러는 방금말한 과정처럼
	    		전체적인 흐름을 관리하고?
	    	ㅡ <strong>실습을하는데 서버가 서블릿을 찾지못해 중단.mvc패턴은 대략 위에 나온내용이 전부임(여기서 간단하게만본다햇음).<br>
	    		xml파일도 이상없어보이고, 서블릿 자바파일도, 디렉토리구조도 똑같지만 404오류가 계속뜸. 이클립스로 옮겨서실행해봐도<br>
	    		똑같음. 몇시간붙잡고있었지만 노답. 추후해결바람</strong>


		</pre>
		필터와 래퍼<button>더보기</button>
		<pre>
			Filter<button>더보기</button>
			<pre>
				ㅡ 필터란?
					ㄴ 컨테이너와 서블릿 사이에서 요청과 응답을 가로채어 어떤 처리를 해주는 일종의 자바 컴포넌트. (그림 추가 "필터란.jpg)
					ㄴ 서블릿은 필터에 의한 처리를 전혀 알지못함. 별개로 분리되어있음.
					ㄴ 컨테이너는 언제 필터를 실행할지를 DD에 선언된 필터에 대한 정보를 보고판단.
					ㄴ '배포자'가 url패턴과 호출할 필터를 매핑한다.  프로그래머가 아닌 '배포자'가 결정하는것.
					ㄴ 'Filter' 인터페이스를 통해 만들어진다. ( 사용하는 Filter, FilterChain 인터페이스는 javax.servlet 패키지안에있다)
					ㄴ 필터는 '모듈식'으로 DD에 설정한다.
						ㄴ 필터 하나는 하나의 완전한 컴포넌트이다.
						ㄴ DD에 선언한 내용을통해, 여러 필터의 적용순서를 설정하거나, 이 순서에하 한두개를 빼는 식의 설정이 가능하다.
					ㄴ 서블릿과 마찬가지로 생명주기가있다. ( init(), destroy(), doFilter() )

				ㅡ 필터 예제
					import java.io.*;
					import javax.servlet.*;
					import javax.servlet.http.HttpServletRequest;

					public class BeerRequestFilter implements Filter{	=>모든 필터는 반드시 이 인터페이스를 구현해야함.
						private FilterConfig fc;

						public void init( FilterConfig config ) throws ServletException{	=>inti()는 반드시 구현해야한다. 일반적으로 여기서 config객체를 내부에 저장ㅎ한다.
							this.fc=config;
						}

						public void doFilter ( ServletRequest req, ServletResponse resp, FilterChain chain )	=>	doFilter()에서 실제 처리하고자하는 작업을 정의한다.
																											역시 필수구현. 주의점은 인자가 HttpSrevletRequest,
																											Response가 아니라는점. 그냥ServletRequest,Response이다.
							throws ServletException, IOException {
							HttpServletRequest httpReq = (HttpServletRequest)req;	=>HttpServletRequest로 형변환해서 사용가능.
							~~~
						}

						public void destroy() {		=>destroy()역시 반드시구현해야한다. (코딩할내용은 보통 없다함)
							~~
						}
					}

				ㅡ 필터의 생명주기
					ㄴ 반드시 구현해야하는 init(), doFilter(), destroy()가생명주기.
					ㄴ init() : 컨테이너가 필터를 인스턴스화할때 호출됨. 위 예제와 같이 FilterConfig객체를 저장하는것이 전부.
					ㄴ doFilter() : 컨테이너가 현재요청에 필터를 적용해야겟다고판단하면 호출됨. 필터의 기능을 구현하는곳.
					ㄴ destroy() : 컨테이너가 필터 인스턴스를 삭제하려고할대 호출. 인스턴스가 삭제되기전에 뭔가 청소작업이 필요하면 여기에정의.

				ㅡ FilterChain 인스턴스
					ㄴ 필터는 모듈형태이기때문에, 서블릿은 필터가 적용되었는지 아닌지 모르고, 필터도 누가 자신을 불럿는지, 다음에 누가 적용되는지 모르고,
						모듈처럼, 블록처럼 여러개를 섞어서, 순서대로 사용할수있다햇다.
					ㄴ 이때 이 순서를 설정하는것이 FilterChain이다. DD에 선언된 내용대로 순서가 설정된다.
					ㄴ 여기에서 doFilter()가 있는데 이 메소드는 다음호출할 필터가 무엇인지 파악하여 그 필터의 doFilter()를 호출하는 기능을한다.
						다음 실행할 체인이없으면 서블릿을 실행한다.

				ㅡ 여러필터적용의 경우 동작과정)
					ㄴ 예를들어 filter A와 B가 적용된다고하면, 컨테이너는 A를 먼저 실행시키고 FilterChain.doFilter()가 나오면 다음실행될 필터B로 흐름을
						넘겨준다. 같은방식으로 B에서 서블릿으로 실행흐름이 넘어가고, 서블릿 servicer()가 완료되면 흐름이 다시 B로 돌아오고,
						B가완료되면, 흐름이 다시 A로 돌아와 A가 완료됨으로서 컨테이넌는 응답을 완료한다.

				ㅡ 필터 정보 선언하기)
					ㄴ 1. 필터 정의하기  2. 필터와 필터링할 자원 매핑   3. 필터순서 설정
					ㄴ 필터 정의하기)
						< filter>
							< filter-name> (* *) < />	=>필수입력사항.
							< filter-class> (*  *) < />	=>필수입력사항.
							< init-param>				=>옵션입력사항. 여러개가능.
								< param-name> (* *)< /  >
								< param-value> (* *) < /  >
							< / >
						< / >
					ㄴ 매핑하기)
						< filter-mapping>
							< filter-name> (* *) < />		=>필수입력사항. 연결된 < filter>를 찾는데 쓰임.
							< url-pattern> (* *) < />		=>필수( < url-pattern>이나 < servlet-name>둘중하나는 꼭이서야함) 해당 url에 필터를 적용.
							< servlet-name> (* *) < />		=>필수. 해당 이름을 가진 서블릿에 필터적용.
							< dispatcher> (*REQUEST, INCLUDE, FORWARD, ERROR 중 하나*) < /> =>	각각, 클라이언트가 요청한경우, include를통해, forward를 통해,
																							error핸들러를 통해 요청이 들어온경우에도 필터를 적용한다는의미.
																							이 요소는 0~4개까지 사용할수있고 없을경우 디폴트는  REQUEST.
						< />
					ㄴ 컨테이너가 필터순서정하는규칙)
						ㄴ 하나의 자원에 여러필터가 적용되어있을경우, 해당하는 모든 필터를 적용시켜 실행한다.
						ㄴ 순서는 먼저 < url-pattern>으로 적용되는 필터 다음 < servlet-name>으로 적용되는 필터적용. < url-pattern>으로 적용되는 필터중에선,
							DD에 먼저 정의된 매핑이 먼저 적용.

				ㅡ 요청필터와 응답필터)
					ㄴ 응답필터는 따로 없고 doFilter()에서 FilterChain.doFilter()실행 전에 처리하는부분을 요청필터, 이후에 처리하는 부분을 응답필터로서 사용된다.
						서블릿이 실행되고 제어흐름이 다시 돌아오면서 서블릿이만든 응답에 대해 처리를 하는 방식.
					ㄴ 문제는 서블릿 실행중에 서블릿 출력스트림에서 내보내는 응답이 필터로 돌아오지않고 바로 클라이언트쪽으로 넘어간다는점. 해서,
						필터에서 흐름을 받아도 응답은 이미 넘어간 상태가된다.
					ㄴ 이를 해결하기위해, 필터에서 서블릿으로 흐름이 넘어갈때, 실제 response객체가 아닌 새로만든 가상의 response를 넘겨주어 서블릿에서
						처리된 응답결과가 클라이언트로 바로넘어가지 않도록하는 방법을 사용한다. (당연히 이 가상의 response는 HttpServletResponse를
						구현해야한다)
					ㄴ ex)
						~~(*요청필터에서 처리할 내용*)~~
						(*직접만든 래퍼클래스 이름*) (*참조변수*) = new (*직접만든래퍼클래스 이름*)( (*실제 response*) );	=>실제 response를 감싸는 래퍼 response를 만드는 부분.
						chain.doFilter( request, (*참조변수*) ); 		=>다음으로 실행할 서블릿에게 새로만든 response객체를 넘겨주는 부분.
						~~(*응답필터에서 처리할 내용*)~~

				ㅡ tip)
					ㄴ 필터로 정의하면 좋은것들)
						ㄴ '요청필터'의 경우 : 보안관련 내용, 요청 헤더와 바디 포맷팅 수정, 요청 감시 및 기록
						ㄴ '응답필터'의 경우 : 응답스트립 압축, 응답스트립에 내용추가 및 수정, 완전히 다른 새로운 응답 만들기.

			</pre>
			Wrapper<button>더보기</button>
			<pre>
				ㅡ 개요)
					ㄴ 개인적인 개요)
						ㄴ 상속과 비슷한거같다.
						ㄴ 감싸지는대상을 내부에 그대로 가지고있으면서 필요한부분만 수정. 나머지는 그대로 내부의 대상으로 위임하는방식.
					ㄴ 말그대로 어떤 클래스같은걸 감싸는 객체를 말함.
					ㄴ 어떤 클래스를 감싸서 자신에게 들어오는 모든 메소드호출을 자신이 감싼 객체로 돌리는 식으로 작동한다.
					ㄴ ServletRequestWrapper을 예를들면, 이 래퍼클래스 생성시 생성자의 인자로 ServletRequest객체를 전달하고, 이 래퍼클래스를 대상으로 getAttribute()를 호출하면,
						이 메소드가 재정의되지 않았다면 생성자인자로 전달한 객체의 getAttribute()가 호출되는식.
				ㅡ 위 필터에서, 응답필터를 처리하기도전에 응답결과가 클라이언트로 넘어가는문제해결을위해 새로 가상의 response객체를 만든다고했는데,
					(HttpServletResponse를 직접 구현하는건 어려우므로) 이때 이 래퍼를 이용하여 만든다.
				ㅡ 자바 썬에서는 이와 관련하여 4개의 래퍼를 제공한다.
					ServletRequestWrapper, HttpServletRequestWrapper, ServletResponseWrapper, HttpServletResponseWrapper

			</pre>
		</pre>
		파이썬<button>더보기</button>
		<pre>
			ㅇ 파이썬<button>more</button>
			<pre>
                ㄴ 설치<button>more</button>
                <pre>
                    ㅡ centos7
                        ㄴ centos7에 기본적으로 python 2.7.5 설치.
                        ㄴ 압축 파일로 설치 )
                            ㄴ 필요한 패키지 설치
                                yum install gcc openssl-devel bzip2-devel libffi-devel -y
                            ㄴ 파이썬 공홈 다운에서 원하는 버전 다운페이지 들어가 gzipped source tarball의 다운 링크 복사.
                            ㄴ centos에서 wget으로 다운
                                ex ) wget https://www.python.org/ftp/python/3.9.5/Python-3.9.5.tgz
                            ㄴ 압축 해제 ex) tar -xvf Python-3.9.5.tgz
                            ㄴ (*압축 해제 폴더*) 들가서 컴파일.
                                ㄴ ex )
                                    cd Python-3.9.5/
                                    ./configure --enable-optimizations
                            ㄴ 설치. ex ) make altinstall
                            ㄴ 설치 위치 확인. ex) which python3.9
                        ㄴ 설치한 python과 'python' 명령어 연결
                            ㄴ vi /root/.bashrc
                            ㄴ ex )
                                # User specific aliases and functions

                                alias python="/usr/local/bin/python3.9"  # 'python'이란 별칭 설정. 값으로 python설치 경로.

                                alias rm='rm -i'
                                alias cp='cp -i'
                                alias mv='mv -i'

                                # Source global definitions
                                if [ -f /etc/bashrc ]; then
                                        . /etc/bashrc
                                fi
                            ㄴ 별칭 적용. ex ) source /root/.bashrc
                            ㄴ python -V 확인시 새로 설치한 버전 출력.

                        ㄴ pip install시, ssl을 통하여 모듈을 받기 때문에 openssl, openssl-devel 패키지 설치 필요.
                            ㄴ 적용 안 되었을시, SSLError 발생.
                            ㄴ yum -y install openssl openssel-devel
                        ㄴ 설치 후, 설정 변경하여 파이썬을 재컴파일해야 적용.
                        ㄴ 설정 변경 및 재컴파일 )
                            ㄴ (*압축 해제 폴더*) / Modules / Setup 파일을 편집.
                            ㄴ '_socket socketmodule.c' 부분 주석 해제,
                            ㄴ 다음 부분 주석 해제.
                                SSL=/usr/local/openssl
                                _ssl _ssl.c \
                                        -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \
                                        -L$(SSL)/lib -lssl -lcrypto
                            ㄴ (*압축 해제 폴더*) 에서 다시 'make altinstall'

                </pre>

				ㄴ 개요 )
					ㄴ 인터프리터형, 객체지향적 동적 타이핑(typing) 고수준 언어.
					ㄴ 들여쓰기를 사용하는 독특한 문법.
					ㄴ 배우고 사용하기 쉬움.
					ㄴ 실행속도가 느림
					ㄴ 다른 언어로 쓰인 모듈들을 연결하는데 자주 사용된다.
					ㄴ 수치 연산에 특화된 모듈들이 잘 되어있다. pyrex, Psyco, NumPy 등.
				ㄴ 표기법
					ㄴ ~~~~~
				ㄴ 어휘분석
					ㄴ ~~~~~
					ㄴ 식별자와 키워드 )
					ㄴ 리터럴 )
						ㄴ 포맷 문자열 리터럴 )
							ㄴ 'f'나 'F'를 앞에 붙인 문자열 리터럴.
							ㄴ 중괄호 {}를 중간에 추가하여 치환 필드를 포함할 수 있다. 이 중괄호 표현식 부분은 실행시간에 계산된다.
							ㄴ 중괄호 안 '표현식'에는 파이선 표현식이 온다.
								ㄴ 빈 표현식은 불가하다.
				ㄴ 데이터 모델 <button>더보기</button>
				<pre>
					ㄴ 객체
						ㄴ 파이선의 데이터를 추상화 한 것. 모든 데이터는 '객체(인스턴스)'나 '객체 간의 관계'로 표현된다.
						ㄴ 객체는 'identity', 'type', 'value'를 가진다.
							ㄴ identity : 메모리상의 객체의 주소 같은것. 한번 만들어진 후 변경되지 않는다.
								ㄴ is연산자는 객체의 아이덴더티를 비교.
								ㄴ id()함수는 아이덴터티를 정수로 표현한 값을 돌려준다.
							ㄴ 형(type)
								ㄴ 객체가 지원하는 연산들과 가질 수 있는 가능한 값들을 정의.
								ㄴ type()함수는 객체의 type을 반환. 즉, 해당 객체가 어떤 클래스의 인스턴스인지.
								ㄴ 아이덴터티와 마찬가지로 변경되지 않음.
							ㄴ 값(value)
								ㄴ '가변'객체들은 값을 변경할 수 있다. '불변'객체들은 불가하다.
								ㄴ '가변'인지 '불변'인지는 '형'에 따라 결정된다. ex) 숫자, 문자열, 튜플은 불변. 리스트, 딕셔너리는 가변.
						ㄴ 명시적으로 없앨 수 없다. 참조되지 않으면 '가비지 컬렉터'에 의해 수거된다.
							ㄴ 열린 파일이나 창 같은 '외부 자원'들을 참조하는 경우, 가비지 수거가 보장되지는 않으므로 보통 close()같은 명시적 제거 방법이 제공된다.
						ㄴ '컨테이너'
							ㄴ 다른 객체에 대한 참조를 포함하고 있는 객체.
							ㄴ 튜플, 리스트, 딕셔너리 등.
							ㄴ 컨테이너가 가변 객체를 가지고 있어서 가지고있는 객체들이 변경되더라도 각 객체들에 대한 아이덴터티는 변하지 않으므로
								이런 경우를 보고 컨테이너가 변했다(가변이다)라고 하지는 않는다. 컨테이너가 가진 객체들의 집합?이 변경되어야 가변이라고 한다.
					ㄴ '형(type)'의 종류<button>더보기</button>
					<pre>
						ㄴ None
							ㄴ 하나의 값만을 가짐. 하나의 객체만 존재.
							ㄴ 'None'이라는 내장 이름을 통해 접근 가능.
							ㄴ 여러 상황에서 값의 부재를 알리는데 사용.
							ㄴ 논리값은 false.
						ㄴ NotImplemented
							ㄴ 하나의 값만을 가짐. 하나의 객체만 존재.
							ㄴ 'NotImplemented'라는 내장 이름을 통해 접근가능.
							ㄴ 숫자 메소드, 비교 메소드에서 피연산자에 대해 연산이 안되면 이 값을 반환. (이후 인터프리터가 연산자에 따라 다른 대안 실행)
							ㄴ 논리 비교에 사용되어선 안됨.
						ㄴ Ellipsis
							ㄴ 하나의 값만을 가짐. 하나의 객체만 존재.
							ㄴ 리터럴 '...'이나 내장 이름 'Ellipsis'를 통해 접근 가능.
							ㄴ 논리값은 true.
						ㄴ number.Number
							ㄴ 숫자 계층의 최상위 클래스.
							ㄴ 숫자 리터럴에 의해 만들어짐. 산술연산, 내장 산술함수들의 반환 '형'
							ㄴ '불변'이다.
						ㄴ numbers.Integral
							ㄴ ~~~~~
						ㄴ numbers.Real
							ㄴ ~~~~~
						ㄴ numbers.Complex
							ㄴ ~~~~~
						ㄴ 시퀸스형들
							ㄴ ~~~~~
							ㄴ 불변 시퀸스
								ㄴ ~~~~~
							ㄴ 가변 시퀸스
								ㄴ ~~~~~
						ㄴ 집합형들
							ㄴ ~~~~~
							ㄴ 집합, Sets
							ㄴ 불변 집합, Frozen sets
						ㄴ 매핑들
							ㄴ ~~~~~
							ㄴ 딕셔너리, Dictionaries
								ㄴ ~~~~~
						ㄴ callable 형들
							ㄴ 함수 호출 연산이 사용가능한 type들.
							ㄴ 사용자 정의 함수
								ㄴ 함수 정의를 통해 생성.
								ㄴ ~~~~~
							ㄴ 인스턴스 메소드
								ㄴ ~~~~~
							ㄴ Generator 함수
								ㄴ ~~~~~
							ㄴ Coroutine 함수
								ㄴ ~~~~~
							ㄴ Asynchronous generator 함수
								ㄴ ~~~~~
							ㄴ 내장 함수 (Built-in 함수)
								ㄴ ~~~~~
							ㄴ 내장 메소드
								ㄴ ~~~~~
							ㄴ 클래스
								ㄴ ~~~~~
							ㄴ 클래스 인스턴스
								ㄴ ~~~~~
						ㄴ 모듈
							ㄴ import system에 의해 만들어짐.
							ㄴ 모듈 객체는 '딕셔너리' 객체로 구현되는 '이름 공간'을 가진다.
							ㄴ ~~~~~
						ㄴ 사용자 정의 클래스
							ㄴ 보통 클래스 정의로부터 생성.
							ㄴ ~~~~~
						ㄴ 클래스 인스턴스
							ㄴ ~~~~~
						ㄴ I/O 객체
							ㄴ ~~~~~
						ㄴ 내부 형(Internal types)
							ㄴ ~~~~~
							ㄴ 코드 객체
								ㄴ ~~~~~
							ㄴ 프레임 객체
								ㄴ ~~~~~
							ㄴ 트레이스백 객체(Traceback object)
								ㄴ ~~~~~
							ㄴ 슬라이스백 객체
								ㄴ ~~~~~
							ㄴ 스태틱 메소드 객체
								ㄴ ~~~~~
							ㄴ 클래스메소드 객체
								ㄴ ~~~~~
					</pre>
					ㄴ 특수 메소드 이름들<button>더보기</button>
					<pre>
						ㄴ 클래스에서 사전에 정의된 특정한 이름의 메소드를 구현하여 특정한 문법에 의해 실행될 로직을 구현 할 수 있다.
							ㄴ 클래스에 대한 연산자 오버로딩이라고 생각하면 된다.
							ㄴ 가령, 클래스의 인스턴스가 생성될 때 호출되는 __new__()함수가 있는데, 이 __new__이름의 메소드를 클래스에서 구현하여
								이 구현한 함수가 인스턴스 생성시 호출되도록 할 수 있다. (__new__()를 덮어쓴것)
						ㄴ 특정 메소드를 None으로 설정하는 것은 해당 연산이 제공되지 않음을 의미한다.
						ㄴ 기본적인 메소드 커스텀에 대해..
							ㄴ (*객체*).__new__(cls[,...])
								ㄴ 클래스 cls의 새 인스턴스 생성시 호출되는 메소드.
								ㄴ ~~~~~
								ㄴ 일반적인 사용은, 안에서 super().__new__(cls[,...])를 먼저 호출하여 인스턴스 생성후, 여기에 필요한 수정을 하는식.
								ㄴ ex)
									class bbb:
										a=1
										def __new__(cls):
											super().__new__(cls)
											print('in __new__()')

									bbb2 = bbb() #'in __new__()'가 출력됨.
							ㄴ (*객체*).__init__(self[,...])
								ㄴ __new__를 통해 새로운 인스턴스 생성후, 이를 반환해주기 이전에 호출되는 메소드.
								ㄴ ~~~~~
							ㄴ ~~~~~
						ㄴ 어트리뷰터 접근 메소드 커스텀에 대해..
							ㄴ 인스턴스의 어트리뷰트 참조 관련(읽기, 대입, 삭제)된 메소드들을 커스텀.
							ㄴ (*객체*).__getattr__(self, name)
								ㄴ 어트리뷰터 엑세스가 'AttributeError'로 실패시 호출.
								ㄴ ~~~~~
							ㄴ ~~~~~
							ㄴ 모듈 어트리뷰터 접근 메소드 커스텀에 대해 ...
								ㄴ ~~~~~
							ㄴ 디스크립터 구현
								ㄴ ?????
							ㄴ 디스크립터 호출
								ㄴ ?????
							ㄴ __slots__
								ㄴ ?????
						ㄴ 클래스 생성에 대한 커스텀...
							ㄴ ~~~~~
							ㄴ (*객체*).__init_subclass__(cls)
								ㄴ ~~~~~
							ㄴ ~~~~~
						ㄴ 인스턴스 및 서브 클래스 검사 커스텀
							ㄴ ~~~~~
						ㄴ 제네릭 형 흉내내기
							ㄴ ?????
						ㄴ 콜러블 객체 흉내내기
							ㄴ ?????
						ㄴ 컨테이녀형 흉내내기
							ㄴ ?????
						ㄴ 숫자형 흉내내기
							ㄴ ?????
						ㄴ with문, 컨텍스트 관리자
							ㄴ ?????

					</pre>
					ㄴ 코루틴, Coroutines
						ㄴ ?????

				</pre>

				ㄴ 실행 모델<button>더보기</button>
				<pre>
					ㄴ 프로그램 구조
						ㄴ 파이썬 프로그램은 '코드 블록'을 기준으로 만들어진다.
						ㄴ 파이썬 코드를 말하는 듯함. 모듈이 될 수도, 함수 바디가 될 수도, 스크립트 명령이 될 수도, 클래스 정의, 등등.
							ㄴ 코드블럭에서 다른 코드블록을 호출하여 실행시킬 수도 있다(함수호출)
						ㄴ ????? 코드블럭은 '실행 프레임'에서 실행된다. 프레임은 디버깅 등에 사용되는 정보를 가지고 있고, 다음 실행되어야 할 코드 블록이
							어느것인지 등을 결정한다.

					ㄴ 이름과 연결(binding)
						ㄴ '이름'은 '이름 연결 연산'을 위해서 만들어진다. '이름'으로 특정 대상을 가리키는 것.
						ㄴ 연결 대상 예)
							ㄴ 함수로 전달되는 형식 매개변수
							ㄴ import문
							ㄴ 클래스와 함수 정의 (정의하고있는 블록에 연결)
							ㄴ 대입, for루프 헤더, with문, except절의 as뒤
							ㄴ from ~~~ import * (모듈에 정의된 모든 이름 연결)
						ㄴ 이름이 블록 내에서 연결되면, 이름이 nonlocal이나 global로 선언되지 않는 이상, 그 블록의 지역변수가 된다.
						ㄴ 이름이 모듈 수준에서 연결되면, 전역변수이다.
						ㄴ 코드 블록에서 사용되지만, 해당 블럭에서 정의되지 않았고 전역변수도 아니라면 'free variable'이라 한다.
						ㄴ '이름'들은 다음의 규칙대로 결정된 binding을 가리킨다.
							* 스코프
								ㅡ 블럭 안에서 '이름'의 가시성을 정의한다. 즉, 특정 '이름'이 '보이는?'범위를 스코프라 하는 듯하다.
								ㅡ 가령, 지역변수 a가 블럭에서 정의되면, a의 스코프는 그 블럭을 포함하고, 그 블럭 안에서 a가 '보인다'(접근 가능하다).
									ㄴ 그 블럭 안에서 a란 '이름'으로 다른 binding을 만들지 않는 한.
								ㅡ '이름'이 결정될때, '이름'이 존재하는 코드 블럭이 포함되는 '가장 가까운 스코프'에서부터 '이름'을 검색한다.
									ㄴ 이렇게, 특정 코드블럭에서 볼 수 있는 스코프의 집합을 블럭의 'environment'라고 한다.
								ㅡ 발견되는 '이름'이 없다면 NameError 예외가 발생한다.
							ㄴ 코드 블럭 내에서 '어디에서건' 이름 연결 연산이 일어나면, 해당 코드 블럭 안에서의 그 이름의 사용은 모두 그 이름 연결으로 결정된다.
								ㄴ ex)
									q = 99
									def ccc():
										print(q)

									ccc()	#ccc()안에서의 q는 전역변수q가되어 99출력.
								ㄴ ex2)
									q=99
									def ccc():
										print(q)
										q=1

									ccc()	# ccc안에서 print()에서 q가 먼저 사용되고 q=1로 지역변수q를 생성하고있다.
											# 코드 블럭내에서 '어디에서건' 이름연결연산이 일어나면, 해당 코드블럭 안에서 그 연결을 사용한다 하였으므로,
											# print에서 사용하는 q는 q=1에 있는 지역변수 q를 의미하게되고, 이 q는 아직 바인딩이 안되었으므로 'UnboundLocalError'예외가 발생한다.
							ㄴ global 문
								ㄴ 해당 코드 블럭 전체에 적용되는 선언.
								ㄴ 나열된 식별자들이 전역범위에서 이름연결되어야함을 설정. 즉, 지정한 이름의 모든 사용은 '최상위 이름 공간'에 연결된 것을 가리키게됨.
									ㄴ ex)
										q=99
										def ccc():
											q=1
											print(q) #바로 위에서 연결된 1이 출력.
											def ccc2():
												global q #전역인 q=99가 연결된다.
												q = -99 #전역변수 q에 -99를 넣는다.
												print(q) # 전역변수인 q에 -99가 대입되었으므로 -99출력.
											ccc2()

										ccc()
										print(q) #전역변수 q가 ccc2()안에서 -99로 수정되었으므로 -99 출력.
									ㄴ '최상위 이름 공간'에서 검색한다는건, 전역 이름 공간, 즉, 모듈의 이름공간, 내장 이름공간, 모듈 내장 객체의 이름공간에 대한 검색.
								ㄴ 이 선언 없이도 free variable들이 전역을 조회할 수는 있지만, 값을 대입할 수는 없다.
									ㄴ ex)
										q=99
										def ccc():
											print(q) #ccc()호출시, ccc()안에서 q를따로 이름연결하지 않았으므로 전역스코프의 q에 조회하여 99가 출력된다.

										ccc()
										그러나 전역 q에 값을 대입하려는 경우,
										q=99
										def ccc():
											q=1 #이렇게 코드를 만드는 순간, 전역변수q에 1을 넣는게 아니라 지역변수 q가 생성되고 1이 대입된다.
											print(q) #출력도 당연히 지역변수q인 1이 나온다.

										ccc()
										print(q) #ccc()안에서 전역변수에 1을 넣은게 아니므로, 99가 그대로 출력된다.
								ㄴ ?????
							ㄴ nonlocal 문
								ㄴ 나열된 식별자들이 전역을 제외하고 가장 가까운 스코프에서 이미 연결된 변수를 가리켜야함을 선언.
								ㄴ ex)
									q=1
									def aaa():
										q=2
										def aaa2():
											nonlocal q 	#이름 q가 aaa()의 함수 블록의 q와 연결된다.
											q=99#2가 대입된q에 99가 들어간다. aaa2()안에서 q가 nonlocal로 선언되지 않았다면, aaa2()에서 q=99는 aaa2()의
												#지역변수 q에 99를 대입하고 aaa()의 q에는 그대로 2가 들어있다.
										aaa2()
										print(q)

									aaa()
							ㄴ 모듈의 이름공간은 모듈이 처음 import될 때 결정된다.
								ㄴ 메인 모듈의이름은 항상 '__main__'이다.
									ㄴ __name__ 이란 이름으로 조회가능하고, 대화형 스크립트나 모듈 자기자신의 이름은 항상 '__main__'이다.
							ㄴ ????? 클래스 정의의 이름 연결 연산
								ㄴ ????? 연결되지 않은 지역변수를 전역 이름공간에서
						ㄴ ?????
							ㄴ ?????
						ㄴ ~~~~~

				</pre>

				ㄴ 클래스<button>더보기</button>
				<pre>
					ㄴ 객체지향형 프로그래밍의 기본적인 기능들을 제공한다.
						ㄴ 상속 메커니즘 : 다중 상속, 오버라이딩, 등
					ㄴ 객체와 이름 )
						ㄴ 여러개의 '이름'이 하나의 객체에 연결될 수 있다. (일반적으로 별칭, aliasing이라고 불림)
					ㄴ 스코프와 이름공간
						ㄴ 흔히 사용되는, 변수의 영역?을 구분하는 namespace를 말하는 듯 하다.
							ㄴ 당연히, 동일한 '이름'이어도, 이름공간이 다르다면 사용가능.
							ㄴ (*이름공간이르며*).(*속성이름*)
							ㄴ 뒤에 오는걸 'attribute'라고 함.
							ㄴ 어트리뷰트는 읽기전용일 수도, 쓰기 가능할 수도 있다. 쓰기 가능할 경우 del문으로 삭제도 가능하다.
							ㄴ 파이선에선 대부분은 '딕셔너리'로 구현되어 있다함.
						ㄴ 이름공간은 생성 시기와 수명이 다를 수 있다.
							ㄴ 가령, 내장 이름들을 담는 이름공간은 인터프리터가 시작할때 생성되어 영원히 사라지지 않는 반면,
								모듈의 전역이름 공간은 모듈정의를 읽을 때 생성된다.
							ㄴ 함수의 지역 이름 공간은 함수 호출 시 생성되고, 함수가 복귀하거나 함수 내에서 처리되지 않는 예외 발생시 삭제된다.
					ㄴ 클래스 정의 )
						ㄴ ex)
							class ClassName:
								(*정의문*)
						ㄴ 정의 시작시, 새 '이름 공간'을 생성하고 이를 지역스코프로 사용. 정의 내의 모든 '이름'들이 이곳에 연결된다.
						ㄴ 클래스 정의가 종료되면, '클래스 객체'가 생성.
						ㄴ type 클래스 )
							ㄴ 내장함수로서, type( (*객체*) ) 를 호출할 시, 해당 객체의 type을 알려주는 함수이지만, type에 대한 다른 내용이 더있다.
							ㄴ 파이선의 모든 데이터들은 객체(인스턴스)라고 했다.
							ㄴ 모든 인스턴스, 클래스의 상위클래스? 라고 할 수있다??
								ㄴ 인스턴스의 __class__ 속성은 인스턴스가 속한 클래스가 무엇인지 알려준다.
								ㄴ 커스텀 클래스의 인스턴스, 내장 클래스의 인스턴스에 대해 __class__를 확인해보면 'type'클래스가 나온다.
							ㄴ type( (*클래스명*), (*상속할 클래스*), (*클래스의 어트리뷰트*) )
								ㄴ 인자를 가지고 새로운 클래스 객체를 생성하여 반환.
									ㄴ 위에 나온 클래스 정의문을 쓰면 이 함수를 호출하여 동작한다.
										ㄴ 	class (*클래스명*):
												(*클래스정의*)
											위의 클래스 정위문과 동일한 동작.
								ㄴ (*클래스의 어트리뷰트*)는 클래스가 가질 변수, 메소드들이 들어있는 'dict'
									ㄴ ex) Foo = type('Foo', (), {'bar':True})	#bar = true인 클래스변수를 가지는 Foo클래스 반환.
							ㄴ 모든 클래스들을 만드는 클래스, 모든 클래스들의 클래스라 하여 type을 '메타클래스'라고도 부른다.
							ㄴ 클래스의 '__metaclass__'라는 속성을 부여하여 클래스 객체 생성 동작을 커스텀 할 수 있다. 이를 '커스텀 메타클래스'라고 부른다.<button>더보기</button>
							<pre>
								ㄴ 클래스에 '__metaclass__'라는걸 설정하면 파이선은 해당 클래스 생성시, 이 속성에 부여한 클래스 또는 함수를 호출하여 클래스 객체를 생성한다.
								ㄴ ex)
									def upper_attr(future_class_name, future_class_parents, future_class_attr): #????? metaclass속성을 사용하면 자동으로 부여되는 인자들인듯하다.
									  """
										대문자로 변환된 속성의 리스트와 함께 클래스 객체를 반환합니다.
									  """

									  # '__'로 시작하지 않는 모든 객체를 가져와 대문자로 변환합니다.
									  uppercase_attr = {}
									  for name, val in future_class_attr.items():
										  if not name.startswith('__'):
											  uppercase_attr[name.upper()] = val
										  else:
											  uppercase_attr[name] = val

									  # `type`으로 클래스를 생성합니다.
									  return type(future_class_name, future_class_parents, uppercase_attr)	#type()을 사용하여, 커스텀으로 생성한 uppercase_attr과 함께
																												클래스객체를 생성해주고있다.

									class Foo(metaclass=upper_attr):	#metaclass속성으로 클래스 또는 함수 전달. 이 라인에서 Foo 클래스 객체 생성시
																			upper_attr을 호출하여 여기서반환한 클래스객체를 생성한다.
										bar = 'bip'	#Foo클래스객체의 변수 bar.

									f = Foo()

									print(f.__class__) #Foo
									print(f.__class__.__class__) #type. metaclass를 사용했어도 결국은 type을 사용했으므로.
									print(f.BAR) 	#bip출력. 클래스 변수 bar가 upper_attr호출로 BAR로 바뀜.

								ㄴ 클래스 생성시 파이선의 __metaclass__ 참조 동작
									ㄴ Foo라는 클래스객체를 생성한다고 하면,
									ㄴ 파이선이 먼저 Foo클래스정의에 __metaclass__속성이 있는지 확인한다.
									ㄴ 있으면 해당 __metaclass__를 사용하여 클래스 객체 생성.
									ㄴ 없으면, '모듈 레벨'에서 __metaclass__를 찾는다. (파이선 3으로 넘어가면서 클래스바디의 __metaclass__속성을
										클래스 정의시 상위클래스 인자부분에 metaclass= (*메타클래스*) 형식으로 넣도록 문법이 변경되었는데,
										모듈레벨에서 metaclass찾는것도 변경되었는지는 모름)
									ㄴ 있으면 그거쓰고, 없으면, 기본인 type을 사용하여 클래스 생성.
								ㄴ 클래스의 상위클래스 인자에 'metaclass = (*메타클래스*)'를 넘겨주면 메타클래스를 사용하여 클래스객체를 생성한다.
									ㄴ ex) 	class Foo(metaclass = (*메타클래스 정의 클래스 또는 함수*) ):
												~~~~~
								ㄴ (*메타클래스 정의 클래스 또는 함수*)
									ㄴ 커스텀으로 클래스를 생성하는 '호출가능한' 무언가??가 오면 된다.
									ㄴ ????? 보통 type()을 호출하여 클래스를 생성하거나 다른 클래스를 생성하게된다.
									ㄴ 여기서 반환하는 클래스 객체가 생성되게 된다.
									ㄴ 위의 upper_attr()예제처럼 함수를 사용해 정의하지 않더라도 class를 정의하여 정의할 수 있다.
										ㄴ ex)
											class UpperAttrMetaclass(type):
												def __new__(upperattr_metaclass, future_class_name,
															future_class_parents, future_class_attr):	#__new__를 오버라이드하여 메타클래스의 기능을 넣는다.

													uppercase_attr = {}
													for name, val in future_class_attr.items():
														if not name.startswith('__'):
															uppercase_attr[name.upper()] = val
														else:
															uppercase_attr[name] = val

													return type(future_class_name, future_class_parents, uppercase_attr)
								ㄴ 메타클래스를 통해 할 수 있는 것들
									ㄴ 클래스 생성 가로채기
									ㄴ 클래스 수정
									ㄴ 수정된 클래스 반환
								ㄴ 보통 함수보다는 클래스형태로 메타클래스기능을 사용하는게 좋다고함.
									ㄴ ~~~~~
								ㄴ 거의 대부분의 경우에는 사용할 일이 없는 기능이다.
							</pre>
					ㄴ 클래스 객체 )
						ㄴ 두 종류의 연산을 지원. 'attribute참조', '인스턴스 생성'
						ㄴ 어트리뷰트 참조 )
							ㄴ (*클래스명*).(*어트리뷰트명*)
							ㄴ 클래스 정의시, 클래스의 '이름 공간'에 있던 모든 이름이 (*어트리뷰터명*)이 된다.
							ㄴ 대입도 가능하다.
							ㄴ 클래스 변수 )
								ㄴ 클래스에서 정의하고 있는 변수.
								ㄴ 클래스로도 접근이 가능하고 인스턴스로도 접근이 가능하다.
								ㄴ 클래스의 모든 인스턴스들이 공유하게 된다.
						ㄴ 인스턴스 생성 )
							ㄴ 인스턴스 만들기 연산 : ex) (*클래스명*)()
							ㄴ 함수호출처럼 클래스명을 호출해주면 인스턴스가 생성되어 반환.
							ㄴ ????? 인스턴스 만들기 연산은 빈 객체를 만든다.
							ㄴ __init__()라는 특수메소드를 통해 인스턴스 생성시 처리할 로직을 정의할 수 있다.
								ㄴ 인스턴스 만들기 연산 실행시, 자동으로 호출된다.
								ㄴ 이 메소드의 인자는 인스턴스 생성 호출시 넘어간 인자들이 들어간다.
									ex) (*클래스*)( (*인자1*), (*인자2*) )
										__init__( (*인자1*), (*인자2*) )
						ㄴ 함수를 꼭 내부에서 def로 정의를 통해 만들지 않아도 된다. 외부에서 정의된 함수객체를 변수 인자에 넣어도 되고 내부에서 정의한 함수를 변수에 넣어도 된다.
							ㄴ ex)
								def aFunc1():
									print('hello1')

								class AAA:
									def aFunc2():
										print('hello2')
									aFuncV1 = aFunc1 #AAA.aFuncV1()과 같이 호출 할 수 있다.
									aFuncV2 = aFunc2 #AAA.aFuncV2()와 같이 호출 할 수 있다.


					ㄴ 인스턴스 객체 )
						ㄴ 어트리뷰트 참조 연산만 가능하다.
						ㄴ 어트리뷰트가 두 종류가 있다. '데이터 어트리뷰트', '메소드'
							ㄴ 데이터 어트리뷰트 )
								ㄴ 인스턴스 변수로서, 해당 인스턴스에서만 접근 가능하다.
								ㄴ 따로 선언할 필요 없이, 인스턴스에 대고 대입하면 인스턴스변수가 생성된다.
									ㄴ ex)
										a = AAA()
										a.xyz = 123 #AAA클래스 정의시, xyz란 변수를 따로 선언하여 만들지 않았어도, 이 문장으로 xyz란 인스턴스변수가 생성된다.
							ㄴ 메소드 )
								ㄴ 인스턴스의 '함수 객체'를 의미.
								ㄴ 똑같은 함수이더라도, 클래스 객체의 함수와 인스턴스 객체의 함수는 구분되어있다. 인스턴스 객체의 함수를 '메소드 객체'라고 한다.
								* 메소드 객체
									 ㅡ 메소드 객체는 호출시, 인스턴스의 객체가 자동으로 함수의 첫번째 인자로 전달된다.
										ㄴ ex) AAA의 인스턴스가 x에 들어있다고 한다면,
											x.aaa() #이는 곧, AAA.aaa(x)와 동일하다.
									ㅡ ????? 인스턴스객체와 클래스의함수 객체를 묶어 '메소드 객체'를 생성.
					ㄴ 클래스 객체와 인스턴스 객체 )
						ㄴ 클래스 변수, 인스턴스 변수를 생각해보면, 전자는 약간 java의 static변수같은 개념이다. 클래스에 정의해놓고 해당 클래스의
							모든 인스턴스에서 접근 가능한 변수. 후자는 해당 인스턴스에서만 접근 가능한 변수.
							ㄴ ex)
								class AAA:
									a = 1;

								aaa1 = AAA();
								aaa1.a2 = 2;
								aaa2 = AAA();
								aaa2.a3 = 3;

								print(aaa1.a)#클래스변수인 1 출력
								print(aaa1.a2) 	#인스턴스변수인 2출력
								print(aaa1.a3) 	#aaa1인스턴스에는 a3이란 인스턴스변수가 없다
								print(aaa2.a) 	#클래스변수인 1출력
								print(aaa2.a3) 	#인스턴스변수인 3출력
							ㄴ class 정의에서 self인자를 통하여 인스턴스 변수 정의도 가능하다
								ㄴ ex)
									class AAA:
										def aFunc(self):
											self.a1 = 1 #self를 통해 인스턴스변수 a1을 생성.

									aaa = AAA();
									print(aaa.a1) #아직 인스턴스변수 생성안되었으므로 에러.
									aaa.aFunc(); #함수호출되며 인스턴스변수 a1생성.
									print(aaa.a1) #인스턴스변수 a1인 1출력
						ㄴ 근데 파이선에서는 jvaa와 다르게 클래스를 선언하는게 아니라 클래스라는 객체 자체를 생성하는 것.
							ㄴ 인스턴스가 클래스변수에 접근하는건 단지, 인스턴스에서 해당 이름의 변수를 찾을 수 없을때, 그 인스턴스의 클래스 객체로
								거슬러올라가서 이름을 찾고 이를 반환해주는 것뿐.
						ㄴ 클래스 변수와 인스턴스 변수와 같으면 인스턴스 변수를 우선하여 참조한다.
						ㄴ 클래스 변수와 인스턴스 변수 모두 파이선에서는 데이터 은닉이 될 수 없다. 어디에서도 참조될 수 있다.따라서 사용에 주의를 해야 한다.
					ㄴ 상속 <button>더보기</button>
					<pre>
						ㄴ ex)
							class DerivedClassName ( BaseClassName ):
								~~~~~
							ㄴ BaseClassName 부분에 상위 클래스 이름이 오면 'DerivedClassName'은 그 상위 클래스를 상속.
							ㄴ 상위 클래스의 '이름'은 이 자식 클래스를 정의하는 스코프에 포함되어 있어야 한다.
						ㄴ 참조하는 어트리뷰트가 해당 자식 클래스에서 발견되지 않으면 상위 클래스를 참조하여 어트리뷰트를 찾는다.
						ㄴ ?????
						ㄴ 관련 내장 함수 )
							ㄴ isinstance( (*객체*), (*클래스*) ) : (*객체*)의 __class__가 (*클래스*)와 일치하면 true반환.
							ㄴ issubclass( (*하위클래스*), (*상위클래스*) ) : 첫번째인자가 두번째 인자의 하위 클래스이면 true반환.
						ㄴ 다중 상속 )
							ㄴ ex)
								class DerivedClassName ( Base1, Base2, Base3 ):
									~~~~~
							ㄴ ????? 다중상속의 다이아몬드 문제에 대한 해결책으로?? 위와 같이 baseclass들이 나열되어잇으면 왼쪽에서 오른쪽 순서대로
								참조를 검색하게 된다.
					</pre>
					ㄴ 파이선의 private 변수 )
						ㄴ 파이선에선 클래스 외부에서 접근 불가한 private변수 같은 것이 존재하지 않는다.
						ㄴ 다만, 관례에 의해서 특정한 패턴의 이름을 가진 변수들은 외부에 의해 접근되어서는 안되는 이름들로 여겨진다고함.
						ㄴ ?????
						ㄴ name Mangling )
							ㄴ '__name' 형태로 정의된 이름들은(변수이든 함수이든) '_classname__name'형태로 자동으로 변환된다.
								ㄴ ex)
									class AAA:
										__a = 1
										def __f1():
											print("in AAA's f1()")

									AAA.__a #__a라는 이름이 없다고 오류발생.
									AAA._AAA__a #1 출력.
									AAA.__f1() #__f1이란 이름이 없다고 오류 발생.
									AAA._AAA__f1() # "in AAA's f1()" 출력.
							ㄴ 완전하지는 않지만 이름을 이런식으로 바꾸어 private와 비슷한 효과를 주게하는 것.
							ㄴ 하위 클래스가 해당 변수를 재정의하는 것들 방지.
					ㄴ ????? 잡동사니
						ㄴ ?????
					ㄴ 이터레이터 )
						ㄴ __iter__와 __next__를 직접 정의하여 정의한 클래스가 iterator와 동작할 수 있게 한다.
						ㄴ ?????
					ㄴ 제너레이터 )
						ㄴ 일반 함수와 동일한데, 'yield'라는 키워드를 사용하여 이터레이터의 기능을 하는? '제너레이터 이터레이터'를 반환하는 함수.
						ㄴ ex)
							class AAA:
								def f1( data ): # f1이 '제너레이터'이다.
									for i in range(0, 10, 1): #0~10까지 반복하면서 3으로 나누어 떨어지는 경우 'yield'를 사용하여 해당 값을 내보내고있다.
										if i%3 == 0:			#다음번 반복실행시, 이전에 yield를 했던 부분부터 시작하게 된다.
											yield i

							for i in AAA.f1( range(0, 10, 1) ): #이렇게 '제너레이터'를 for문이나 next()를 사용해 반복할 수 있다.
								print(i) #0,3,6,9 출력.

				</pre>

				ㄴ import system<button>더보기</button>
				<pre>
					ㄴ 한 모듈 안에 있는 파이선 코드는 '임포팅'을 통해 다른 모듈에 있는 코드들에 대한 접근권을 얻는다.
						ㄴ 임포팅 이란? 한 모듈의 파이선 코드가 다른 모듈의 파이선 코드에서 사용될 수 있도록 하는 과정.
					ㄴ 임포트 방법
						ㄴ import문 (가장 보편적방법)
						ㄴ importlib.import_module()
						ㄴ __import__()
					ㄴ import 문 )
						ㄴ from절이 없는 경우 )
							ㄴ 과정
								ㄴ 모듈을 찾고, 로드하고, 필요하면 초기화합니다.
									ㄴ 찾는 과정은 적절한 인자들로 __import__()를 호출하는 것이다.
									ㄴ 이후, __import__()의 반환값으로 다음단계인 이름연결연산을 수행한다.
								ㄴ import문이 등장한 스코프의 지역 이름공간에 '이름'이나 '이름 공간'정의.
									ㄴ 모듈 이름 뒤에 'as'가 오면, as뒤에 오는 이름이 모듈과 연결됨.
									ㄴ ?????
						ㄴ from절이 있는 경우 )
					ㄴ __import__()
						ㄴ 파이선 내장함수.
						ㄴ 모듈을 찾고, 발견된다면 모듈을 만드는 연산만을 수행.
						ㄴ __import__(name, globals=None, locals=None, fromlist=(), level=0)
							ㄴ 주어진 globals, locals 함수를 이용하여 name을 적절하게 해석한다.
							ㄴ name으로 모듈을 결정한다. name에 해당하는 모듈이 결정되는게 아니라 해당 모듈의 최상위 패키지가 반환된다.
								ㄴ ex) import spam.ham 은 다음과 같이 호출되며 spam.ham이 아니라 최상위인 spam을 반환한다.
									__import__('spam', globals(), locals(), [], 0)
							ㄴ fromlist으로 서브모듈을 결정한다.
								ㄴ ex) from spam.ham import eggs, sausage as saus 는 다음과 같이 호출되며 spam의 eggs, sausage를 반환한다.
									_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
									eggs = _temp.eggs
									saus = _temp.sausage
						ㄴ ????? 구체적인 내부 동작은 아직 모름.

					ㄴ 모듈 검색과정에서 찾지 못한다면, ModuleNotFoundError 발생.
					ㄴ 모듈을 찾는 다양한 전략들이 존재. 커스텀 가능.
					ㄴ importlib )
						ㄴ 파이선 표준 라이브러리 중 하나. import system과 관련한 여러가지 api들을 제공한다.
					ㄴ 패키지 )
						ㄴ 서브 모듈이나 서브 패키지들을 포함할 수 있는 파이선 '모듈'. __path__ 어트리뷰트가 있는 파이선 모듈이다.
						ㄴ __path__ 어트리뷰트
							ㄴ 임포트시 서브 모듈을 검색할 위치가 문자열로 담겨있는 이터러블 데이터. 모듈 임포트시 sys.path와 기능이 유사하다.
								ㄴ sys.path : 모듈의 검색 경로를 지정하는 문자열 리스트.
							ㄴ 비어있을 수 있다.
						ㄴ 종류 )
							ㄴ 정규 패키지 )
								ㄴ 파이선 3.2 이하에서 존재하던 전통적인 패키지. __init__.py라는 파일을 가지는 디렉터리고 구현된다.
								ㄴ 임포트 될때, __init__.py가 실행됨.
								ㄴ ex)
									parent/
										__init__.py
										one/
											__init__.py
										two/
											__init__.py
										three/
											__init__.py
									ㄴ 위와 같은 패키지의 파일구조가 있다고할때, parent.one을 임포트하면 parent/__init_.py와 parent/one/__init__.py가
										실행된다.
							ㄴ 이름 공간 패키지 )
								ㄴ '포션'들의 집합체.
									ㄴ '포션'이란, 이름공간 패키지를 구성하는 하나의 디렉터리에 들어있는 파일 집합.
										ㄴ 파이선이 임포트시 검색하는 어떤 곳에도 위치할 수 있음?????
					ㄴ 검색 )
						ㄴ 임포트될 모듈의 '완전히 정규화된 이름'을 필요로 한다.
							ㄴ '완전히 정규화된 이름'이란, 네임스페이스안의 이름 입력시, (*네임스페이스*).(*이름*) 과 같은식으로,
								점을 이용해 모듈, 클래스, 함수에 이르는 모든 경로를 나타낸 이름.
						ㄴ 완전히 정규화된 이름의 최상위 모듈부터 차례대로 모두 임포트한다.
							ㄴ ex) aaa.bbb.ccc를 임포트하면, aaa임포트, aaa.bbb임포트, aaa.bbb.ccc를 임포트한다.
							ㄴ 중간에 하나라도 없다면 'ModuleNotFoundError'를 발생시킨다.
						ㄴ 모듈 캐시 )
							ㄴ 가장 먼저 검색하는 대상은 'sys.modules'이다.
								ㄴ 이는 모듈 이름과 이미 로드된 모듈을 매핑하는 '딕셔너리'이다.
								ㄴ 즉, 이미 임포트된 모든 모듈들의 캐시로서 기능한다.
							ㄴ sys.modules안에 이름이 있고, 그 이름이 현재 import하려는 모듈이면 검색이 완료된다.
							ㄴ 이름은 있으나 값이 'None'이면, 'ModuleNotFoundError'를 발생.
							ㄴ sys.modules에 쓰기 작업이 가능하다.
								ㄴ 키를 삭제하여 캐시목록에서 해당 모듈을 없앨 수 있다. (당연히 모듈 자체를 삭제하지는 않는다)
								ㄴ 다음 임포트때, 다시 그 모듈을 찾도록 한다.
								ㄴ None을 대입하여 다음 임포트때 'ModuleNotFoundError'가 발생하게 할 수 있다.
								ㄴ ?????
						ㄴ finder, loader )
							ㄴ 모듈이 sys.modules 안에 없으면 파이선의 임포트 프로토콜이 실행.
							ㄴ 임포트 프로토콜은 두가지 객체에 의해 동작한다. 'finder', 'loader'
							ㄴ finder )
								ㄴ 임포트될 모듈을 위한 'loader'를 찾으려하는 객체.
								ㄴ 두 종류의 finder 존재. '메타 경로 파인더', '경로 엔트리 파인더'
							ㄴ ?????
							ㄴ
							* ModuleSpec 클래스
								ㅡ 임포트 시스템에서 쓰이는 클래스. 모듈 임포트와 관련하여 모듈에 관한 여러 정보를 가지고 있는 클래스이다.
									ㄴ '정규화된 모듈 이름', 모듈의 '로더', 모듈 위치, 등의 정보를 담고있다.
								ㅡ 일반적으로 임포트된 모듈이름의 __spec__ 어트리뷰트를 통해 확인 가능하다.
								ㅡ 흔히 '모듈 스펙'이라고 말하는게 이 클래스의 인스턴스이다.
						ㄴ ????? 뭐 아무튼 '메타 경로 파인터'가 'sys.meta-path'를 사용해 모듈을 찾아준다는 내용.
					ㄴ 로딩 )
						ㄴ ?????
					ㄴ ?????
				</pre>

				ㅡ 표현식<button>더보기</button>
				<pre>
					ㄴ 말 그대로 표현식에 대해 설명. 리터럴, 식별자(파이썬에서 '이름'), 리스트, 어트리뷰트 참조, 호출 등등.
					ㄴ 산술 변환 )
						ㄴ ~~~~~
					ㄴ 아톰(Atoms)
						ㄴ ~~~~~
						ㄴ 리스트, 집합, 딕셔너리의 display
				</pre>

				ㅡ 단순문<button>더보기</button>
				<pre>
					ㄴ 흔히 하나의 코드 줄로 구성되는 단위를 의미. 그냥 표현식 하나일 수도, 대입문, 증감문, del, return문, raise, break, import문 등등.
				</pre>

				ㅡ 복합문<button>더보기</button>
				<pre>
					ㄴ 여러 절로 이루어져 코드를 구성하고, 다른 코드 부분에 영향을 주거나 제어하는 문.
					ㄴ ex) if, while, for, try, 함수정의 등
					ㄴ ~~~~~
					ㄴ try 문 )
						ㄴ ex)
								try:
									~~~~~
								except ( (*예외1*), (*예외2*), ... ):
									(*예외처리*)
								except ( (*예외3*), (*예외4*), ... ):
									(*예외처리*)
								~~~~~
								else:
									(*로직*)
						ㄴ 동작 과정 )
							ㄴ try 절 실행.
								ㄴ try절이란, try와 except사이의 문장들
							ㄴ 예외 발생 안하면 except절 스킵
							ㄴ 예외 발생시, 남은 try절 스킵후, except매칭 시작
							ㄴ 인자로 받은 예외가 발생하면 매칭. 이후 (*예외처리*)부분 수행.
							ㄴ 인자 예외 옆에 as키워드를붙이고 변수를 입력할시, 예외 처리 구문 안에서 해당 예외가 변수로서 들어간다.
								ㄴ ex)
									except E as a
										print(a);
								ㄴ 당연히, 해당 예외처리구문이 종료되면 해당 변수는 없어진다.
							ㄴ 인자가 없는 except절은 모든 예외와 매칭.
							ㄴ (*예외*)인자와 같은 클래스이거나 상위 클래스일 때 매칭된다.
							ㄴ else절 : 간단히말해, 예외가 발생하지 않으면 실행되는 부분.
								ㄴ 모든 except뒤에 위치해야함.
								ㄴ try절 실행에서 예외가 발생하지않고, try절에서 return, continue, break문이
									발생하지 않았으면 실행된다. 여기서 발생한 예외는 이전의 except절에서 처리되지 않는다.
							ㄴ finally 절 )
								ㄴ try문 전체 통틀어서 맨 마지막에 호출되는 절.
								ㄴ except에서 예외가 잡히든, 안잡히든, try, except절 어디서든 return, continue, break를 하든
									finally절이 있다면 항상 마지막에 한번 호출된다.
									ㄴ 따라서 try절에 return문이 있더라도 finally절에 return문이 있다면 덮어씌워진다.
								ㄴ else절과 마찬가지로 finally절 안에서 발생한 예외는 except절에서 처리되지 않는다.
									또한, try문에서 발생한 예외를 덮어씌워 예외를 발생시킨다. (????? 다른 '컨텍스트'로 설정된다고 한다)
								ㄴ try절에서 예외가 발생하고 이 예외가 except절에서 처리되지 않으면, 예외가 잠시 저장되었다가 finally절이
									실행된 후에 다시 발생된다.
					ㄴ with 문 )
						ㄴ
				</pre>

				ㅡ 표준 라이브러리<button>더보기</button>
				<pre>
					ㄴ 파이썬에서 기본적으로 제공하는 표준 라이브러리 목록
					ㄴ 내장 함수<button>더보기</button>
					<pre>
						ㄴ https://docs.python.org/ko/3/library/functions.html#built-in-funcs
						ㄴ ~~~~~
						ㄴ int(x)
							ㄴ x는 숫자 또는 문자열.
							ㄴ x로부터 만들어진 정수 객체 반환.
						ㄴ isinstance( (*객체*), (*클래스 정보*) )
							ㄴ (*객체*)가 (*클래스 정보*)에 해당하는 클래스의 객체이거나, 그 하위 클래스의 객체이면 true.
							ㄴ ex)
								class AAA:
									pass;
								class BBB(AAA):
									pass;

								bbb = BBB();
								isinstance(bbb, AAA); #True.
						ㄴ issubclass( (*클래스*), (*클래스정보*) )
							ㄴ
						ㄴ len( (*객체*) )
							ㄴ 객체의 길이 반환.
							ㄴ (*객체*)는 시퀀스, 컬렉션이다.
						ㄴ open()
							ㄴ 파일을 열고 해당 '파일 객체'를 반환.
							ㄴ ~~~~~
						ㄴ eval()
							ㄴ 파이썬의 '표현식'을 계산하는 함수.
							ㄴ 동적으로 생성된 파이선 표현식 '하나'를 계산하기위해 쓰임.
							ㄴ ex)
								x = 1
								eval('x+1') #2출력.
							ㄴ ~~~~~
						ㄴ exec()
							ㄴ 파이썬 코드를 실행시켜주는 함수.
							ㄴ 동적으로 생성된 파이선 코드를 실행하기 위해 쓰임.
							ㄴ ~~~~~
					</pre>

					ㄴ 내장 상수<button>더보기</button>
					<pre>
						ㄴ https://docs.python.org/ko/3/library/constants.html
						ㄴ ~~~~~
						ㄴ False : bool 클래스의 거짓값.
						ㄴ True : bool 클래스의 참값.
						ㄴ None :
					</pre>

					ㄴ 내장형 <button>더보기</button>
					<pre>
						ㄴ ~~~~~
						ㄴ 논리값 검사
							ㄴ 모든 객체는 논리값 검사 대상이 될 수 있다.
							ㄴ 객체가 False를 반환하는 __bool__(), 0을 반환하는 __len__()를 구현하지 않는한 True로 간주된다.
							ㄴ 따라서 다음의 객체들은 거짓으로 간주된다.
								ㄴ '거짓'형태의 내장 상수 : None, False
								ㄴ 0을 나타내는 숫자들 : 0, 0.0, 0j, Decimal(0), Fraction(0,1)
								ㄴ 빈 시퀸스와 컬렉션 : '', (), [], {}, set(), range(0)
						ㄴ 논리 연산
							ㄴ or : x or y 형태. 앞에 것이 참인지를 확인한다 생각하면 된다. x가 참이면 x반환, 아니면 y반환.
									'단일 회로 연산'이므로 왼쪽에서 부터 차례대로 연산하며, 더 확인해봐야할때만 다음 부분이 연산된다.
							ㄴ and : x and y 형태. 앞에것이 거짓인지를 확인한다 생각하면 된다. x가 거짓이면 x반환, 아니면 y반환.
									역시 '단일 회로 연산'.
							ㄴ not : not x 형태. x의 참 거짓값의 반대를 반환.
						ㄴ 비교
							ㄴ 흔히 아는 <, <=, >, >=, ==, != 와
							ㄴ is, is not이 존재. 이건 객체의 'identity'를 비교하여 동일한지 판별.
						ㄴ 숫자형
							ㄴ int, float, complex
							ㄴ ~~~~~
						ㄴ 이터레이터 형
							ㄴ ~~~~~
						ㄴ 시퀸스 형
							ㄴ list, tuple, range
							ㄴ 공통 연산
								ㄴ x in s : s의 항목중 하나가 x와 같으면 true.
								ㄴ x not in s : s의 항목 중 하나가 x와 같으면 false.
								ㄴ s + t : s와 t 이어붙이기.
								ㄴ s * n : s에 자기자신s를 n번 이어붙이기
									ㄴ s가 복사되는것이 아닌, 같은 객체가 여러번 참조되는 것.
								ㄴ s[i]
								ㄴ s[i:j] : 슬라이스
								ㄴ s[i:j:k] : i에서 j까지 k크기로 슬라이스
								ㄴ len(s)
								ㄴ min(s)
								ㄴ max(s)
								ㄴ ?????
								ㄴ s.count(x) : s에서 x의 개수.
							ㄴ 불변시퀸스, 가변 시퀸스
								ㄴ 불변시퀸스
									ㄴ
								ㄴ 가변시퀸스
									ㄴ ~~~~~
									ㄴ 가변 시퀸스 연산
										ㄴ x는 임의의 객체, t는 임의의 이터러블 객체.
										ㄴ ~~~~~
										ㄴ s[i] = x : i번째 값을 x로 대체
										ㄴ s[i:j] = t : i~j까지의 슬라이스를 t로 대체.
										ㄴ del s[i:j] : 해당 부분 제거
										ㄴ s.append(x) : 끝에 x를 추가
										ㄴ s.clear() : s의 모든 항목 제거
										ㄴ s.copy() : s의 얕은 복사
										ㄴ s.extend(t) : t으로 s를 확장
										ㄴ s.insert(i, x) : s[i:i] = [x]와 동일
										ㄴ s.pop(i) : i번째 인자를 반환하고 삭제. i의 디폴트는 -1로, 맨 마지막을 가리킴.
										ㄴ s.remove(x) : x와 같은 첫번째 항목을 제거.
										ㄴ s.reverse() : s의 항목들의 순서를 뒤집음.
							ㄴ 리스트 )
								ㄴ 일반적으로 동일한 성질의 항목들의 모음을 저장.
								ㄴ class list([iterable])
								ㄴ 생성 )
									ㄴ []
									ㄴ [ a,b,c ]
									ㄴ
								ㄴ ~~~~~
							ㄴ 튜플 )
								ㄴ 보통 성질이 다른 여러 항목들을 저장할때 사용. 성질이 같은 경우에도 사용할 수 있다.
								ㄴ 불변 시퀸스.
								ㄴ ~~~~~
							ㄴ range )
								ㄴ 숫자의 불변 시퀸스.
								ㄴ ~~~~~
							ㄴ 텍스트 시퀸스 )
								ㄴ 문자열을 의미.
								ㄴ class str
								ㄴ ~~~~~
							ㄴ ~~~~~
						ㄴ 집합 형
							ㄴ 자바의 set과 유사
							ㄴ 서로 다른 요소. 해시 가능한 객체. 순서 없음.
							ㄴ ~~~~~
						ㄴ 매핑 형 )
							ㄴ class dict
							ㄴ 자바의 map과 유사.
							ㄴ ~~~~~
						ㄴ 문자열 메소드<button>더보기</button>
							ㄴ (*문자열*).format( (*인자1*), (*인자2*), ... )
							ㄴ 'hello, {0}, {1}'.format( 'hehe', 'haha' ) #'hello, hehe, haha' 출력.
							ㄴ 인자로 받는 문자열에 인자 인덱스를 포함한 중괄호를 추가하여, 해당 중괄호 부분에 (*인자1,2,...*)부분의 값이 문자열로
								치환된 값이 들어간다.
							ㄴ '위치 인자'말고도 '키워드 인자'를 사용 할 수 있다.
					</pre>

					ㄴ 내장 예외 <button>더보기</button>
					<pre>
						ㄴ ~~~~~
					</pre>

					ㄴ 텍스트 처리 기능<button>more</button>
					<pre>
						ㄴ ~~~~~
						ㄴ
					</pre>

					ㄴ 마크업언어 처리 도구<button>더보기</button>
					<pre>
						ㄴ 파이선에서는 구조화된 마크업 데이터를 처리할 수 있는 도구들을 제공.
							ㄴ 마크업에는 SGML(Standard Generalized Markup Language), HTML, XML이 포함되어 있다.
						ㄴ ~~~~~
						ㄴ html <button>더보기</button>
						<pre>
							ㄴ html 모듈.
							ㄴ ~~~~~
							ㄴ html 파서 )<button>더보기</button>
							<pre>
								ㄴ html모듈의 서브모듈.
								ㄴ html, xhtml문서를 파싱할 수 있는 'HTMLParser'클래스를 제공하는 모듈.
								ㄴ ~~~~~
							</pre>
						</pre>


					</pre>
				</pre>

				ㄴ 파이썬 인터프리터 <button>더보기</button>
				<pre>
					ㄴ 인터프리터 실행하기 )
						ㄴ python3.9 명령어를 실행하여 실행 가능하다.
						ㄴ python -c (*명령어들*) (*인자들*)  을 통해서도 사용 가능하다.
					ㄴ 종료하기 ) EOF문자( 윈도우에선 Ctrl+z )를 누르거나 quit()명령어 입력.
					ㄴ ????? 'GNU Readline' 라이브러리를 제공하는 시스템에서 줄 편집 기능으로 대화형 편집, 히스토리 치환, 코드 완성 등을 제공???
					ㄴ ????? 스크립트 파일 실행 후 대화형 모드로 들어가려면 스크립트 앞에 -i 옵션 전달.
					ㄴ 인자 전달 )
						ㄴ ?????
					ㄴ 대화형 모드 )
						ㄴ tty (콘솔이나 터미널)에서 명령을 읽는 것을 인터프리터가 '대화형 모드'로 동작한다고함.
						ㄴ 기본 프롬프트는 '>>>'이고, 여러줄이 이어지는 입력일 때의 보조 프롬프트는 '...'이다.
					ㄴ 디폴트로 파이선 소스 파일들은 UTF-8로 인코드 된 것으로 취급.
				</pre>

				ㄴ 주석 )
					ㄴ 해시문자, #로 시작하는 부분 뒤쪽으로 모두 주석취급.
					ㄴ ex)
						# this is the first comment
						spam = 1  # and this is the second comment
								  # ... and now a third!
						text = "# This is not a comment because it's inside quotes."
				ㄴ 연산 )
					ㄴ 나누기 연산자(/)는 항상  float를 반환. 정수 나누기를 하려면 '//'연산자를 이용해야함.
					ㄴ '**'를 이용해 거듭제곱 연산 가능. ex) 5 ** 2 #25
				ㄴ 문자열 )
					ㄴ 작은따옴표나 큰따옴표로 표시.
					ㄴ 이스케이프 문자는 백슬래쉬 '\'이다.
					ㄴ 문자열 앞의 따옴표 앞에 'r'문자를 붙여 'raw string'을 만들 수 있다.
						ㄴ ex ) print( r'C:\some\name' ) # C:\some\name
					ㄴ 문자열 리터럴은 삼중 따옴표를 이용하여 여러줄로 될 수 있다.
						ㄴ ex)
							print("""\
							Usage: thingy [OPTIONS]
								 -h                        Display this usage message
								 -H hostname               Hostname to connect to
							""")
					ㄴ + 연산자로 이어붙이고, * 연산자로 반복가능하다.
						ㄴ 두개 이상의 문자열 리터럴이 연속해서 나오면 자동으로 이어붙여짐. (문자열 리터럴이 연속으로 나오는 경우만 해당. 변수는 안됨)
					ㄴ js의 문자열처럼 배열로 취급 될 수 있다.
						ㄴ ex) word = 'Python'  word[0]='P'
						ㄴ '문자'에 해당하는 별도의 자료형은 없다. 단순히 길이가 1인 문자열이다.
						ㄴ index가 음수이면 끝에서부터 결정.
						ㄴ 이를 이용해 '슬라이싱'도 가능하다.
							ㄴ ex) word[0:2] #'Py'. index 0 자리 부터 2자리 이전까지의 문자열 추출.
							ㄴ 슬라이싱에서 index 값을 주지 않으면 디폴트값이 잇다.
								ㄴ ex) word[ :2] #앞부분 디폴트값은 0. 뒷부분은 문자열의 길이.
						ㄴ 범위를 벗어나는 인덱싱은 오류이나, '슬라이싱'에서 범위를 벗어나는 인덱싱은 알아서 처리가 된다.
							ㄴ ex) word[100] #오류.       word[ :100] #'Python'
					ㄴ 문자열 리터럴은 '불변'이다.
					ㄴ 내장함수 len() : 문자열 길이 반환. len( (*문자열리터럴*) )

				ㄴ 제어 흐름 도구<button>더보기</button>
				<pre>
					ㄴ if )
						ㄴ ex)
							if (*판별식*):
								(*로직*)
							elif (*판별식*):
								(*로직*)
							...
							else:
								(*로직*)
						ㄴ 조건식 )
							ㄴ while, if에 오는 조건절에는 비교연산자 뿐만 아니라, 모든 종류의 연산자 사용이 가능하다.
								ㄴ in,not in, is, is not 등.
							ㄴ 비교는 여러개가 겹칠 수 있다.
								ㄴ a < b == c 와 같이 사용 가능.
							ㄴ not으로 true, false를 뒤집을 수 있다.
							ㄴ and, or으로 자바의 &&, ||의 기능을 할 수 있다.
							ㄴ 논리연산자는 '단락-회로(short-circuit)' 연산자이다.
								ㄴ 왼쪽부터 오른쪽으로 가다가 값이 결정되면 더 이상 계산하지 않음.
					ㄴ for )
						ㄴ ex) for (*item*) in (*컬렉션*):
									(*로직*)
						ㄴ 컬렉션에 대해? 반복하는 방식으로 동작.
						ㄴ c나 java처럼 반복횟수와 조건을 따로 설정하지 않음.
					ㄴ range() )
						ㄴ 수열을 반환하는 함수.
						ㄴ for에서 숫자들 순서로 반복하려할 때 편리.
						ㄴ ex) for i in range(5):
									print(i)
						ㄴ ex)
							range(5,10) #5,6,7,8,9
							range(0, 10, 3) #0,3,6,9
							range(-10, -100, -30) #-10,-40,-70
						ㄴ 리스트를 반환하는게 아닌, 'iterable'을 반환.
						ㄴ range()에서 리스트를 얻으려면 list( range(4) )를 호출.
					ㄴ 루프의 break, continue, else )
						ㄴ break는 가장 가까운 for, while 루프를 빠져나오게한다.
						ㄴ else 절 )
							ㄴ for이 'iterable'을 모두 돌렸거나 while에서 조건이 거짓이 되면 실행된다.
							ㄴ ex)
								for x in range(2,10):
									~~~~~
								else:
									~~~~~
							ㄴ break로 루프가종료되면 호출되지 않음.
						ㄴ continue )
							ㄴ 루프에서 다음 반복으로 넘어감.
					ㄴ pass 문 )
						ㄴ 아무것도 하지않고 그냥 넘어가는 문장.
						ㄴ ex)
							while True:
								pass
				</pre>

				ㄴ 함수<button>더보기</button>
				<pre>
					ㄴ ex) 	def (*함수명*) ( (*매개변수*) ):
								(*함수 바디*)
					ㄴ (*함수 바디*)
						ㄴ 첫번째 문장을 선택적으로 문자열 리터럴을 입력하여 함수에 대한 설명을 하는 'docstring'을 정의할 수 있다.
							ㄴ 다른 여러 곳에서 이 docstring을 볼 수 있다함.
							ㄴ 일반적으로 사용되는 관습 )
								ㄴ 첫줄은 함수의 목적을 짧고 간결하게 요약. 대문자로 시작하고 마침표로 종료.
								ㄴ 추가적인 설명이 있다면, 두번째 줄은 비워서 요약과 나머지 설명을 구분.
								ㄴ 나머지 설명에서는
					ㄴ 변수 범위
						ㄴ (*함수 바디*)에서의 지역 변수들과 매개변수들은 지역 심볼 테이블에 저장된다.
							ㄴ 따라서 매개변수들은 '값에 의한 참조'이다.
						ㄴ 변수는 지역 심볼 테이블, 전역 심볼 테이블, 내장된 이름 테이블 순으로 확인한다.
					ㄴ 함수 정의는 함수 이름을 심볼 테이블 안에 함수 객체와 연결한다. 인터프리터는 그 함수 이름이 가리키는 객체를 사용자 정의 함수로 인식한다.
						ㄴ 다른 이름의 변수 또한 동일한 함수 객체를 가리킬 수 있다.
							ㄴ ex) 	fib란 함수가 정의되었다면,
									fib #fib함수 객체를 가리킴.
									f = fib #f도 이제 fib함수 객체를 가리킴.
					ㄴ return문이 없는 함수는 'None'이라는 내장 정의된 값을 반환한다.
						ㄴ 인터프리터는 보통 'None'값을 출력하지 않는다.
					ㄴ (*매개변수*) )
						ㄴ 인자들의 기본값을 지정 할 수 있다.
							ㄴ ex) def ask_ol( prompt, retries = 4, reminder='Please try again'):
										(*body*)
							ㄴ 기본값은 함수 정의 시점에서의 스코프로, 함수정의할때 단 한번만 설정된다.
								ㄴ ex)
									i = 5
									def f(arg=i):
										print(arg)

									i=6
									f() #5가 출력된다.
								ㄴ 기본값이 리슽, 딕셔너리, 클래스 인스턴스일 경우, 함수 호출시마다 그 기본값이 유지되므로 주의가 필요하다.
									ㄴ ex)
										def f(a, L=[]):
											L.append(a)
											return L

										print(f(1)) # [1]
										print(f(2)) # [1,2]
										print(f(3)) # [1,2,3]출력.
						ㄴ 호출 시, 디폴트값이 정해져있는 인자는 넘기지 않아도 된다.
						ㄴ 매개변수 키워드 )
							ㄴ 함수 호출시, 매개변수 명을 키워드로 넘겨서 함수를 호출 할 수 있다.
							ㄴ ex) aks_ol('aaa')
									ask_ol('aaa', retries=11)
									ask_ol(prompt='aaa', retries=11)
							ㄴ 규칙 )
								ㄴ 키워드 인자는 키워드가 없ㄴ느 인자 뒤에 나와야 한다.
								ㄴ 키워드는 중복될 수 없고
								ㄴ 매개변수명으로 존재하는 키워드가 와야한다.
						ㄴ **(*매개변수명*) 형식의 매개변수
							ㄴ js에서 정의된 매개변수 이외의 인자들을 argument?인자가 모두 받듯이, 함수 호출 시, 정의된 매개변수에 대응되지 않는
								키워드 인자들을 담은 '딕셔너리(dict)'를 받는다.
								ㄴ ex) def cheeseshop( kind, *arguments, **keywords)
							ㄴ ?????
						ㄴ 매개변수 형식 지정 )
							ㄴ 함수 호출 시, 매개변수가 지정될 형식을 엄격하게 정해 놓을수 있다.
							ㄴ def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
								ㄴ '/'인자와 '*'인자는 매개변수 형식지정에 사용되는 선택적 인자이다.
								ㄴ '/'인자 앞부분의 매개변수들은 위치만으로 매개변수 지정이 가능해진다.
								ㄴ '/'인자와 '*'인자 사이의 매개변수들은 위치와 키워드 둘 다로 매개변수 지정이 가능하다.
								ㄴ '*'인자 뒷부분의매개변수들은 키워드만으로 매개변수 지정이 가능하다.
						ㄴ 임의의 인자 목록 )
							ㄴ 임의의 개수의 인자로 함수가 호출 될 수 있게하는 기능
							ㄴ 인자가 정해지지 않은 남은 인자들이 '튜플'이라는 자료구조로 묶여서 함수에 전달된다.
								ㄴ ex)
									def concat( *args, sep='/'):
										return sep.join(args)

									conat( 'earth', 'mars', 'venus' ) # earth/mars/venus
						ㄴ 람다 표현식 )
							ㄴ 이름없는 작은 함수를 만드는데 사용된다.
							ㄴ ex) lambda a, b: a+b
							ㄴ 함수 객체가 올 수 있는 곳에 사용될 수 있다.
					ㄴ 함수 어노테이션
						ㄴ ?????
				</pre>
				ㄴ 코딩 스타일
					ㄴ 탭 말고 스페이스바 4번으로 들여쓰기를 사용하라.
						ㄴ 스페이스 4개가 작은 들여쓰기, 큰 들여쓰기 사이의 철충안이라함.
						ㄴ ????? 탭은 혼란을 일으킨다함??
					ㄴ 79자를 넘기면 줄넘김을 ㅎ라
					ㄴ 함수, 클래스, 함수 내의 큰 코드블럭 사이에 빈줄을 넣어 분리
					ㄴ 주석은 별도의 줄에
					ㄴ docstring 사용
					ㄴ 연산자들과 컴마 뒤에 스페이스를 넣고, 괄호 바로 안쪾에 스페이스를 넣지 마라.
					ㄴ 클래스와 함수에 일관성있는 이름규칙. 관례는 클래스의 경우 UpperCamelCase, 함수의 경우 lowercase_with_underscores.

				ㄴ 자료 구조 <button>더보기</button>
				<pre>
					ㄴ 리스트
						ㄴ ex) squares = [ 1, 3,5 ]
						ㄴ 안의 값들은 자료형이 다를 수도 있지만 일반적으로 같다함.
						ㄴ 문자열처럼 인덱싱과 슬라이싱이 된다.
							ㄴ 슬라이스 연산은 원본 리스트가 아닌, 복사본을 반환해준다.
							ㄴ 슬라이스에 대입도 가능하다.
								ㄴ ex) squares[ : 2] = [9,9] #[9,9,5]
						ㄴ + 연산자르 이용한 이어붙이기 연산도 지원한다.
						ㄴ append()를 이용하여 항목을 추가 할 수 있다.
							ㄴ ex) squares.append(2*3) # [1,3,5,6]
						ㄴ '가변'이다.
						ㄴ 문자열 리터럴에 사용되던 len()을 리스트에도 사용가능ㅎ다.
						ㄴ 리스트 중첩도 가능하다.
							ㄴ ex) a=[1,2,3]   b=['x', 'y']
									c=[a,b] #[ [1,2,3], ['x','y'] ]
						ㄴ 메소드 )
							ㄴ append(x) : 리스트 끝에 항목을 추가.
							ㄴ extend( (*iterable*) ) : 리스트 끝에 iterable의 모든 항목 추가.
							ㄴ ~~~~~
						ㄴ 정렬과 비교가 없다. 여러 타입이 항목에 포함 될 수 있기 때문에.
						ㄴ 스택으로써 사용)
							ㄴ append()와 pop()을 사용하면된다.
						ㄴ 큐로써 사용 )
							ㄴ 가능은 하지만, 맨 앞에서 꺼내거나 붙이는 것은 모든 항목을 한칸씩 밀거나 당겨야 하기때문에 속도가 느려 적합치 않다.
							ㄴ 파이선 표준라이브러리의 collections.deque를 사용하라함.
						ㄴ 컴프리핸션???
						ㄴ del 문 )
							ㄴ 인덱스를 이용하여 리스트에서 항목을 제거
							ㄴ ex) del a[0], del a[ : 4] #리스트 a에서 해당 부분을 제거.
					ㄴ 튜플과 시퀸스 )
						* 시퀸스
							ㅡ ?????
							ㅡ 대표적 자료형 : list, tuple, range
						ㄴ 튜플은 쉼표로 구분되는 여러 값을 가지는 데이터형.
						ㄴ ex) t = 111, 222, 'hello'
						ㄴ 출력시 괄호로 감싸져서 출력된다. ex) ( 111, 222, 'hello')
						ㄴ '불변'이다.
						ㄴ 빈 괄호를 사용하여 빈 튜플을 만들 수 있다. ex) t = ()
						ㄴ 하나의 항목을 가지는튜플은 끝에 컴마를 붙여 만들 수 있다. ex) t = 111,
						ㄴ 패킹, 언 패킹 )
							ㄴ t = 111, 222, 'hello' 와 같은 예를 '튜플 패킹'이라 한다.
							ㄴ x, y, z = t 와 같은 예를 '시퀸스 언 패킹' 이라 한다.
								ㄴ 요소와 같은 개수가 와야한다.
					ㄴ 집합 )
						ㄴ 중복되는 요소가 없는, 순서 없는 컬렉션.
						ㄴ 생성 )
							ㄴ 중괄호 또는 set() 사용.
								ㄴ 빈 집합을 만드려면 set()을 사용해야함. 빈 중괄호 {}는 빈 '딕셔너리'를 만드는데 사용된다.
							ㄴ ex) 중괄호 이용.
								basket = {'aaa', 'bbb', 'aaa', 'ccc'}	#{'aaa','bbb','ccc'} 집합 생성.
							ㄴ ex) set() 이용.
								x = set('abcdef')	#{'a','b','c','d','e','f'}
								y = set('def')	#{'d','e','f'}
						ㄴ 집합 연산 )
							ㄴ - : 차집합. ex) x-y 	#{'a','b','c'}
							ㄴ | : 합집합.
							ㄴ & : 교집합.
							ㄴ ^ : XOR연산.
					ㄴ 딕셔너리 )
						ㄴ '키'로 인덱싱되는 자료형. java의 Map과 유사한듯하다. 키 : 값 쌍의 집합.
						ㄴ 생성 )
							ㄴ 중괄호 안에 (*키*) : (*값*) 쌍을 컴마로 구분하여 넣으면 생성 가능.
								ㄴ ex) 	tel = {'aaa':111, 'bbb':222}
							ㄴ 빈 중괄호는 빈 딕셔너리를 생성. ex) {}
						ㄴ ex) tel['ccc'] = 333
						ㄴ del 문을 사용하여 키값쌍 삭제가능. ex) del tel['aaa']
						ㄴ 이미 존재하는 키로 저장시, 덮어씌워짐.
						ㄴ 없는 키로 조회시, 에러.
						ㄴ list()에 딕셔너리를 인자로 넘길시, 딕셔너리의 키값목록을 삽입순으로 반환해줌.
						ㄴ in 키워드로 키값 확인 가능.
						ㄴ 가능한 키값 )
							ㄴ 문자열과 숫자는 항상 키값이 될 수 있다.
							ㄴ 튜플이 문자열, 숫자, 튜플만 포함한다면 키로 사용될 수 있다.
							ㄴ 튜플이 직간접적으로 가변 객체를 포함하면 불가.
					ㄴ 자료형들의 반복 )
						ㄴ 딕셔너리로 반복시, items()를 사용하면 키와 값을 동시에 얻을 수 있음.
							ㄴ ex)
								for k,v in (*딕셔너리*).items():
									~~~~~
						ㄴ 시퀸스 반복시, enumerate() 사용하면 인덱스와 값을 동시에 얻을 수 있음.
							ㄴ ex)
								for i,v in enumberate( (*시퀸스*) ):
									~~~~~
						ㄴ 둘 이상의 시퀸스 반복하려면, zip()으로 엔트리들의 쌍 생성 가능.
							ㄴ ex)
								for a,b in zip( (*시퀸스1*), (*시퀸스2*) ):
									~~~~~
						ㄴ 시퀸스를 거꾸로 반복하려면, reversed() 사용
							ㄴ ex) for i inreversed( (*시퀸스*) ):
										~~~~~
						ㄴ 시퀸스를 정렬하려면 sorted()사용
							ㄴ ex) for i in sorted( (*시퀸스*) ):
										~~~~~
						ㄴ 시퀸스에 대해 중복 요소 제거하려면 set()사용
							ㄴ ex) for f in sorted( set( (*시퀸스*) ) ):
										~~~~~
					ㄴ 시퀸스의 비교 )
						ㄴ 두 시퀸스 객체를 비교 할 수 있다.
						ㄴ ex)
							(1, 2, 3)              < (1, 2, 4)
							[1, 2, 3]              < [1, 2, 4]
							'ABC' < 'C' < 'Pascal' < 'Python'
							(1, 2, 3, 4)           < (1, 2, 4)
							(1, 2)                 < (1, 2, -1)
							(1, 2, 3)             == (1.0, 2.0, 3.0)
							(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
						ㄴ 첫번째 항목끼리부터 차례대로 비교하여 해당 항목에서 차이가 나면 바로 그결과를 결정.
						ㄴ 동일하면 다음 항목들끼리 비교, 시퀸스안에 시퀸스가 있을시, 재귀적으로 또 비교, 이런식으로 모든 항목을 비교.
						ㄴ 모든 항목이 같으면 동일.
						ㄴ 다 같은데 한쪾이 개수가 부족하면 그 시퀸스가 더 작은 것.

				</pre>

				ㅡ 모듈<button>더보기</button>
				<pre>
					ㄴ 여러 정의한 내용들을 파일에 넣고, 스크립트나 인터프리터의 대화형 모드에서 사용할 수 있고, 이러한 파일들을 '모듈'이라 한다.
					ㄴ 파일을 정의하고, import (*파일명*) 을 한뒤, (*파일명*).(*함수명*) 과 같이 사용하면, 해당 모듈에 있는 함수 등을 사용할 수 있다.
					ㄴ 모듈 파일 안에는 함수 정의뿐만 아니라 다른 실행 가능한 문장들도 포함되어있고 이것들은 모듈이 처음 import될 때(모듈이 초기화 될때?) 실행된다.
					ㄴ 모듈의 심볼 테이블은 그 모듈의 함수들의 전역 심볼 테이블로 사용된다. 물론 import한 모듈명을 이용해 이 모듈의 변수들에 접근가능하다.
					ㄴ 모듈역시 다른 모듈을 import할 수 있다. import되는 모듈의 이름은 import하는 모듈의 전역 심볼 테이블에 들어간다.
					ㄴ ????? 모듈의 이름을 import하는게 아닌 직접 선택적으로?? import하는 import문도 있다.
						ㄴ from (*모듈명*) import (*모듈의 함수 또는 변수*)
						ㄴ from (*모듈명*) import *
							ㄴ 모듈에서 정의하는 모든 이름들을 import.
						ㄴ import (*모듈명*) as (*별칭*) : 모듈이름을 별칭으로 지정하여 import.
					ㄴ 모듈 안에서 모듈의 이름은 전역변수 __name__을 이용해 접근가능하다.
					ㄴ 스크립트로 모듈 실행 )
						ㄴ python (*모듈명*) (*인자*) : 모듈 실행하는 명령어.
						ㄴ 모듈의 코드는 import할 때와 같이 실행된다.
						ㄴ __name__은 '__main__'으로 고정된다.
							ㄴ 모듈의 끝에 다음의 코드를 붙여서 파일이 import되고 스크립트로 사용될 수 있도록 하기위해서이다.
							ㄴ 	if __name__ == "__main__":
								import sys
								fib(int(sys.argv[1]))
						ㄴ 모듈을 import하면 코드는 실행되지 않는다. import (*모듈명*)
					ㄴ 모듈 검색 )
						ㄴ 특정 이름의 모듈이 import되면, 인터프리터는 우선 내장 모듈 중 같은 이름을 찾는다.
							없으면, sys.path 변수에서 주어지는 디렉토리 중에서 찾는다.
							* sys.path
								ㅡ 모듈의 검색 경로를 지정하는 문자열 리스트.
								ㅡ ?????
						ㄴ ?????
					ㄴ 컴파일된 파이선 파일
						ㄴ 모듈 로딩을 빠르게 하기 위해, 파이선은 각 모듈들의 컴파일된 버전을 '__pycache__'란 디렉토리에 '(*모듈명*).(*버전*).pyc'란
							이름으로 캐싱한다.
						ㄴ 소스의 수정시간과 컴파일 버전을 비교하여 재컴파일 필요 여부를 자동으로 결정한다.
						ㄴ ?????
						ㄴ 명령행에 직접 로드되는 모듈은 캐시검사를 하지 않는다.
						ㄴ 컴파일된 파일만 있고 소스가 없어도 캐시검사를 하지 않는다.
					ㄴ 표준 모듈들 )
						ㄴ 여러 표준 모듈들의 라이브러리가 기본으로 존재한다.
						ㄴ 이중ㅈ 몇몇은 인터프리터에 내장된다.
							ㄴ 'sys'모듈은 인터프리터에 내장된다.
								ㄴ sys.ps1, sys.ps2 : 기본 프롬프트, 보조 프롬프트를 정의하는 문자열
								ㄴ sys.path : 인터프리터의 모듈 검색 경로를 결정하는 문자열 리스트.
					* dir( )
						ㅡ 인자로 모듈명을 넘기면, 해당 모듈이 정의하는 이름들을 리스트로 반환.
						ㅡ 인자가 없으면, 현재 정의한 이름들을 나열. (내장함수, 변수들은 반환안함)
					ㄴ 패키지 )
						ㄴ 모듈들을 이름 공간으로 구조화하는 방법.
						ㄴ 이를 통해, 모듈의 이름이 다른 외부의 모듈명과 겹칠 걱정을 안해도된다. 패키지명만 다르면 다를테니까.
						ㄴ import )
							ㄴ import (*패키지1*).(*패키지2*). ... .(*모듈명*)
								ㄴ 이 경우 모듈을 사용하려면 앞의 패키지들을 모두 적어주어야 한다.
							ㄴ from (*패키지1*).(*패키지2*). ... import (*모듈명*)
								ㄴ 이 경우, 모듈명만으로 모듈 사용이 가능하다.
								ㄴ (*모듈명*)에 모듈 전체 말고, 각 이름을 따로 import할 수도 있다.
				</pre>

				ㅡ 입력과 출력 <button>더보기</button>
				<pre>
					ㄴ
				</pre>

				ㅡ 에러와 예외<button>더보기</button>
				<pre>
					ㄴ 문법예외, 실행중에 감지되는 에러를 '예외'라 한다.
					ㄴ ~~~~~
					ㄴ raise 문 )
						ㄴ java의 throw문과 비슷한 것. 특정 예외를 명시적으로 발생시킴.
						ㄴ
					ㄴ 예외 연쇄
					ㄴ 사용자 정의 예외 )
						ㄴ Exception 클래스를 직,간접적으로 상속하여 커스텀 예외 클래스를 만들 수 있다.
						ㄴ '클래스'이기 때문에, 일반 클래스가 할 수있는 모든 기능을 할 수 있지만, 일반적으로 에러 정보에 관한 몇가지 기능이나
							어트리뷰트만을 가진다.
					ㄴ finally 문 )
						ㄴ
					ㄴ with
				</pre>

				ㅡ 가상환경<button>더보기</button>
				<pre>
					ㄴ 파이썬 어플리케이션에서 표준 라이브러리가 아닌 외부 라이브러리를 사용할 경우, 이를 파이썬에 따로 설치해 주어야 한다.
						그리고 어플리케이션이 그 외부 라이브러리의 특정 버전을 요구하는 경우들이 있다. 이때, 어플A에서는 버전 1.0을 요구하는데
						어플B에서는 버전 2.0을 요구하는 등 요구하는 버전이 다른경우가 발생한다.
						파이썬에서는 이러한 문제를 'virtual environment'를 이용하여 해결한다.
						ㄴ 파이썬의 virtaul environment란?
							한 파이썬 어플이 같은 시스템 상에 있는 다른 파이썬 어플에 영향을 주지 않으면서 파이썬 패키지를 설치하고 업그레이드
							할 수 있게 해주는 cooperatively isolated runtime environment.
						ㄴ 어플이 각자의 가상환경을 가지고, 이곳에 필요한 패키지를 설치하거나 업그레이드 하는 것.
					ㄴ venv 모듈 )
						ㄴ 간단한 '가상환경'을 만들어주는 기능과 관련된 모듈.
						ㄴ????? 각 '가상환경'은 각자의 'site directory'를 가지며, system site directory와 분리될 수 있다
						ㄴ 각자의 site directory에 각자의 파이선 패키지들을 가질 수 있다.
						* site-packages : 파이선 패키지들이 저장되는 폴더라고보면된다. 보통 윈도우에선 Lib\site-packages에 위치해있다.
					ㄴ 가상환경생성
						ㄴ python -m venv (*경로를포함한 가상환경폴더명*)
							ㄴ ex) python -m venv ./sampleVirtualEnv
						ㄴ 해당 위치에 입력한 폴더명으로 가상환경이 생성된다.
						ㄴ 입력한 이름의 폴더가 생기며, pyvenv.cfg파일, Scripts폴더, site-packages폴더 등이 생긴다.
					ㄴ 가상환경 활성화
						ㄴ 가상환경 폴더의 Scripts/activate.bat을 실행시키면 된다.
							ㄴ ex) C:\Users\kai> .\sampleVirtualEnv\Scripts\activate.bat
						ㄴ 커맨드입력 맨 앞에 'prompt'가 바뀌어 현재 어떤 가상환경인지 알려준다.
							ㄴ ex) (sampleVirtualEnv) C:\Users\kai >
					ㄴ ~~~~~
				</pre>
			</pre>

			ㅇ Anaconda <button>더보기</button>
			<pre>
				ㄴ 패키지 관리, 가상 환경 관리 기능이 있는 데이터 과학용 파이선/R의 배포판..?
				ㄴ 기본 시작방법 )
					ㄴ 아나콘다 설치후,
					ㄴ anaconda prompt실행하고
					ㄴ conda create -n (*환경이름*) 으로 환경생성.
					ㄴ activate (*환경이름*) 으로 환경실행.
					ㄴ 맨앞 괄호 ()안에 환경이름이 바뀔것.
					ㄴ 여기서 python명령어 입력하여 파이선 실행.
				ㄴ 아나콘다 안에는 파이선이 포함되어있기때문에, 파이선이 이미설치되어있는데 아나콘다 설치시, 파이선의 환경변수 등이 충돌이 일어날 수도 있다.
					파이선을 삭제해야함.
					ㄴ 일단 나는 ㅇ나ㅏ콘다 설치과정에서 기존파이선을 사용할거냐고 물어보는창이있어 yes클릭.
				ㄴ ~~~~~
			</pre>

			ㅇ 파이썬 라이브러리, 모듈<button>more</button>
			<pre>
				ㅡ Numpy <button>더보기</button>
				<pre>
					ㄴ Numpy란? )<button>더보기</button>
					<pre>
						ㄴ 대량의 다차원 배열을 효과적으로 다룰수 있게 해주는 라이브러리. 과학, 수학 분야에서 많이 사용.
						ㄴ 다차원 배열객체, 이로부터 파생되는 여러 객체(행렬 등), 배열에 관한 여러 연산기능을 제공.
						ㄴ 'ndarray'객체라는 핵심 객체를 중심으로 동작.
							ㄴ ndarray 객체란? 같은 데이터 타입인 요소들의 n차원 배열을 추상화한 객체.

						ㄴ numpy의 편리함, 효과?
							ㄴ 리스트의 곱을 예로들면, 파이선 리스트를 이용해 리스트간 곱셈을 하려면,
								c = []
								for i in range(len(a)):
									c.append(a[i]*b[i])
								위와 같이 코드를 작성해야한다. 근데 이것도 두 리스트의 길이가 다르면 빠지는 부ㅜㅂㄴ이 생긴다.
							ㄴ ~~~~~
							ㄴ numpy를 이용하면 다음과 같이 간단하게 작성할 수 있다.
								c = a * b
								ㄴ 이는 c언어만큼 빠르고 직관적으로 이해하기 쉽다.
								ㄴ 넘파이 연산자가 미리 만들어진 최적화되고 컴파일된 c언어 코드를 호출하여 동작하게된다. 따라서 파이선 루프문보다 훨씬 빠르다.
							ㄴ 이것이 numpy의 기본적인 두가지 기능. '벡터화', '브로드캐스팅'을 보여준다.
						ㄴ 벡터화와 브로드캐스팅
							ㄴ 벡터화 )
								ㄴ 각 요소들이 각각의 상응하는 요소들과 한번에 연산되는것? 아님 c언어 레벨에서 이런 연산을 시켜주는 것?
									ㄴ 위의 곱셈예시에서 반복문을 통해 각 요소를 하나씩 연산해주는게 아닌 numpy의 *연산을 통해 한번에 각 요소들을 연산하는 것.??
								ㄴ 이러한 작업들이 내부적으로 최적화된 컴파일된 c코드를 통해 동작한다.
								ㄴ 이를 통해 코드가 매우 간결해 진다.
							ㄴ 브로드 캐스팅 )
								ㄴ 형태가 다른 배열들도 알아서 조절하여 연산을 하게 해준다.
					</pre>

					ㄴ 개요 )<button>더보기</button>
					<pre>
						ㄴ n차원 배열을 어떻게 다루는지에 대해 배운다.
							ㄴ numpy에서 1,2, n차원 배열의 차이점에 대해
							ㄴ ~~~~~
						ㄴ 넘파이의 기본 객체는 동일한 타입의 다차원 배열이다.
						ㄴ 넘파이에서 '차원'은 'axes'(축)이라 불린다.
							ㄴ [1., 0., 0.]은 one axis, [ [1., 0., 0.], [0., 1., 2.] ]은 2 axis
						ㄴ 이 기본 배열을 ndarray, 또는 alias array라고 한다.
							ㄴ numpy.array와 파이선의 array와는 다르다.
						ㄴ ndarray의 속성
							ㄴ ndarray.ndim : axis의 개수.
							ㄴ ndarray.shape : 각 axis의 array의 개수를 나타내는 정수 튜플. 가령, n개의 row와 m개의 column인 행렬이 있으면 shape는 (n,m).
							ㄴ ndarray.size : 배열의 총 요소의 개수.
							ㄴ ndarray.dtype : 배열안에든 요소의 데이터 타입을 알려주는 속성.
							ㄴ ndarray.itemsize : 배열안에 든 각 요소의 바이트 크기.
							ㄴ ????? ndarray.data : 배열의 실제 요소들을 담고있는 버퍼?????
						ㄴ 배열 생성
							ㄴ array함수를 통해 파이선의 기본 list나 tuple을 사용하여 ndarray를 생성할 수 있다.
								ㄴ ex)
									a = np.array( (*파이선 시퀸스*) )
									a = np.array( [ [1,2,3], (4,5,6) ] ) # 결과는 array([ [1,2,3], [4,5,6] ])
									ㄴ '시퀸스'의 '시퀸스'는 2차원 배열로 변환한다.
								ㄴ dtype 파라미터를 넘겨 명시적으로 데이터 타입을 지정할 수 있다.
									ㄴ ex) a = np.array( [1,2,3], dtype=object )
							ㄴ 넘파이의 함수 이용하여 생성 )
								ㄴ np.zeros(), np.empty() 등의 함수로 배열을 생성할 수 있다.
								ㄴ ex)
									a = np.zeros( (*배열의 shape*) ) #넘겨진 shape에 맞는, 요소가 모두 0인 배열생성
									a = np.ones( (*배열의 shape*) ) #넘겨진 shape에 맞는, 요소가 모두 1인 배열 생성
									a = np.empty( (*배열의 shape*) ) #넘겨진 shape에 맞는, 요소가 랜덤값인 배열생성. ????? 랜덤값은 메모리의 상태에 따라 다름??
																		랜덤값의 디폴트 타입은 'float64'이다.
								ㄴ 위 예시의 함수들 모두 np.array()에서처럼 dtype파라미터를 통해 명시적으로 데이터타입지정가능.
								ㄴ arange()
									ㄴ arange()를 사용해, 파이선 내장함수 range()와 같은 숫자배열을 생성할 수 있다.
										ㄴ ex)
											a = np.arange( 0, 10, 0.5 )
									ㄴ 소수점으로 배열을 생성할 경우, 유동소수점 표현으로 인해 정확한 요소의 개수를 알기 어려우므로?????
										np.linspace()를 대신 사용한다.
										ㄴ ex) np.linspace(0,2,9) #0~2사이의 소수를 9개로 나누어 표현.
						ㄴ 배열의 출력
							ㄴ 마지막 axis는 왼쪽에서 오른쪽으로 출력
							ㄴ 마지막에서 두번째는 위에서 아래로
							ㄴ 그 이상의 axis는 한 줄을 띄워가며 위에서 아래로 출력.
							ㄴ ex)
								[[[ 0  1  2  3]
								  [ 4  5  6  7]
								  [ 8  9 10 11]]

								 [[12 13 14 15]
								  [16 17 18 19]
								  [20 21 22 23]]]
							ㄴ 데이터가 너무 길면 numpy는 자동으로 중간을 생략.
						ㄴ 배열의 연산 )
							ㄴ 산술연산은 배열의 각 요소별로 적용된다.
								ㄴ * 연산의 경우도, 각 요소별로 적용된다. (보통 행렬에서의 연산과 달리. 행렬에서의 * 연산은 @을 이용하여 할 수 있다)
							ㄴ 새 배열이 생성되고 여기에 결과가 저장된다.
							ㄴ +=, *= 연산은 결과값으로 새 배열을 생성하지 않고 기존의 배열을 수정한다.
							ㄴ 다른 타입끼리의 연산인 경우, 결과 배열의 타입은 더 범위가 크거나 정교한 데이터 타입이 된다. 가령, 정수 배열과 실수배열의 연산이면 실수 배열이 결과가된다.
							ㄴ sum(), min() 등의 단항연산자들이 여러개 정의되어있다.
								ㄴ 이런 연산자들은 디폴트로 배열이 숫자의 리스트인것처럼 동작한다. n차원 배열이어도 1차원 배열처럼 취급하여 합을 구하거나 최솟값을 찾거나 한다는말.
								ㄴ 함수호출시 axis 매개변수를 넘겨서 어떤 axis를 기준으로 계산을 할지 결정할 수 있다.
									ㄴ ex)
										b = np.arange(12).reshape(3,4)
										b.sum(axis=0) # 결과는 array([12,15,18,21])
						ㄴ Universal 함수 )
							ㄴ numppy에서는 수학과 관련된 함수를 제공한다. sin, cons, exp등. 이런 함수들을 universal함수라한다.
							ㄴ 배열의 각 요소별로 적용된다.
						ㄴ 인덱싱, 슬라이싱, Iterating
							ㄴ 일차원 배열은 파이선의 시퀸스처럼 인덱싱, 슬라이싱, Iterating이 가능하다.
							ㄴ 다차원 배열은
								ㄴ axis별로 인덱싱이 가능하다. ex) b[2, 3] # axis=0에서 인덱스2, axis=1에서 인덱스3을 의미.
								ㄴ 슬라이싱도 동일하게 가능. ex) b[0:, 1:]
								ㄴ dots, ...)
									ㄴ '...'표기는 dots라 하여, 인덱싱에서 필요한만큼의 충분한 콤마(,)를 의미한다.
									ㄴ 해서 b[...]라고 하면, b[ : , : ]와 같이 axis수만큼의 :가 채워진다.
								ㄴ Iterating은 첫번째 axis를 기준으로 실행된다.
									ㄴ 모든 요소를 1차원으로 보고 실행하고 싶으면, 배열의 flat속성에 대해 반복하면 된다. '
										ㄴ ex)
											for e in a.flat:
												print(e) # 0,1,2,3, ... ,12
							ㄴ 배열을 이용한 인덱싱 )
								ㄴ 인덱싱은 정수 뿐만 아니라 또다른 배열을 이용하여도 할 수 있다.
									ㄴ ex) a = np.array([0,0,2])
											b = np.array( [1,2,3] )
											b[a] # 0번째, 0번째, 2번째 요소가 인덱싱되어 [1,1,3]반환.

											a = np.array([ [0,0], [1,2] ])
											b[a] # [ [1,1], [2,3] ] 반환.
								ㄴ 다차원 배열의 인덱싱의 경우, 인덱스로 넘겨주는 배열들의 shape이 동일해야한다.
									ㄴ ex)
										a = np.array([ [1,2,3], [4,5,6], [7,8,9] ])
										i = np.array([ [0,2], [2,1] ])
										j = np.array([ [1,1], [0,1] ])
										a[i,j] # [ [2,8], [7,5] ] 반환.
							ㄴ boolean 배열을 통한 인덱싱
								ㄴ ex)
									a = np.array([1,2,3])
									b = np.array([False, True, True])
									a[b] # array([2,3])출력.
								ㄴ 다차원 배열에도 적용가능하다.
								ㄴ 인덱싱 대상인 배열과 인덱스로 넘겨줄 boolean배열의 'shape'가 일치해야한다.
									ㄴ ex)
										a = np.array([ [1,2,3], [4,5,6] ])
										i = np.array([ [True,True,False], [False,False,True] ]) #이런식으로 shape가 일치해야한다. [1,2,6]이 반횐된다.
										또는
										i = np.array([ False, True ]) #이런식으로 일치해도 된다. a의 axix=0에서 두번째인덱스만 추출되어 [ [4,5,6] ]이 반환된다.
						ㄴ shape 조작 )
							ㄴ 값의 리스트는 같아도 axis에 따라 shape가 변화할 수 있다.
								ㄴ ex)
									똑같은 [1,2,3,4,5,6]이어도,
									[ [1,2,3], [4,5,6] ] #a.reshape(2,3)
									[ [1,2], [3,4], [5,6] ] #a.reshape(3,2)
									등과 같이 변경가능.
							ㄴ shape 변경 방법)
								ㄴ a.ravel() : shape를 1차원 배열로 변경.
								ㄴ a.reshape(6,2) : 6행 2열 형태로 변경.
								ㄴ a.T : 대각선 축 대칭으로 변환
						ㄴ 배열 이어붙이기 )
							ㄴ column_stack )
								ㄴ 배열을 컬럼을 추가하며 이어붙인다
								ㄴ hstack()과 동일하다.
								ㄴ ex)
									np.column_stack( (a,b) ) # 		[ [1,4],
																		[2,5],
																		[3,6] ]
							ㄴ row_stack )
								ㄴ
						ㄴ 배열 쪼개기 )
							ㄴ np.split( (*배열*), (*쪼개는방식정보*), (*축*) )
								ㄴ 기존의 배열을 특정 방식대로 '쪼개어' 쪼개어 나뉘어진대로 각각 조각이 새 배열이 되어 그 배열들의 배열을 반환해준다.
								ㄴ (*배열*)을 (*쪼개는방식정보*)대로 쪼개어 새로운 각 배열들을 만들고 그 배열들의 배열을 반환.
									ㄴ ex)
										a = np.array( [1,2,3,4] )
										np.split(a,2) #[1,2,3,4]를 2개로 쪼개므로 [1,2], [3,4]로 두개의 배열이 생성되고
														[ array([1,2]), array([3,4]) ]가 반환된다.
								ㄴ (*축*)은 어느 축을 기준으로 쪼갤지 선택하는 것. 옵션사항이고 디폴트는 0.
									ㄴ ex)
										a = np.array( [ [1,2,3], [4,5,6] ] )이라하면,
										np.split( a, 3, 1) #축이 1이므로, a의 축1부분 즉, [1,2,3], [4,5,6]을 쪼개게 된다. 3개로쪼갠다 했으므로
															각각 [1],[2],[3]과 [4],[5],[6]으로 쪼개지고 쪼갠대로 [ [1],[4] ], [ [2],[5] ], [ [3],[6] ] 세 배열이 생성되어
															배열로 반환.
							ㄴ hsplit( (*배열*), (*쪼갤개수*) ) : np.split()에서 (*축*)이 1인 것과 동일하다.
						ㄴ 배열의 복사 )
							ㄴ 배열과 관련한 연산들 중에는 새 배열이 생성되는 경우가 있고 아닌 경우가 있다.
							ㄴ 단순 할당은 객체를 복사하지 않는다.
							ㄴ (*배열*).view()는 같은 데이터를 참조하는 새 배열 객체 생성. 이를 'view'라하는듯하다.
								ㄴ ex)
									a = np.array([1,2,3])
									b = a.view()
									b[0] = -1
									a[0] # -1로 바뀌어있다.
								ㄴ 배열의 '슬라이싱'은 이런 'view'를 반환해주는 것.
							ㄴ (*배열*).copy()는 들어있는 데이터까지 복사하여 새 데이터와 새 배열객체 생성.
						ㄴ 브로드 캐스팅
							ㄴ 넘파이에서 서로 'shape'가 다른 배열들간의 산술연산을 할때, 이 배열들을 어떻게 다루는지에 대한 개념.
							ㄴ 개념적으로 간단히 설명하면, '특정한 조건'만족한다면, 넘파이가 '더 작은' 배열이 'broadcast'되어 서로 'shape'가 맞도록 한다.
								ㄴ 내부적으로 알아서 배열을 'stretched'하여 계산을 한다.
							ㄴ 이를 통해 '벡터화'가 되도록 해준다.
							ㄴ 브로드캐스팅이 되기 위한 '특정한 조건' )
								ㄴ 배열의 'shape'의 값들을 비교한다.
								ㄴ 두 배열의 shape에서 각 마지막 차원들의 값끼리 비교하기 시작하여 처음방향으로 이동하면서 비교한다.
									ㄴ shape의 길이가 같을 필요는 없다. 각 배열의 shape에서 마지막 항목끼리 비교하는 것.
								ㄴ 비교하고있는 두 차원의 값이 동일하거나, 둘 중 하나가 1이면 조건에 부합한다.
								ㄴ 조건에 부합하지 않으면 'ValueError: operands could not be broadcast together'라는 에러가 발생한다.
								ㄴ ex)
									a = np.array([[[ 1,2,3],
												   [ 4,5,6]],

												  [[ 7,8,9],
												   [ 10,11,12]]]) #a.shape는 (2,2,3). a가 이렇다고 할때,
									b가 아래와 같을 때, a*b할때 조건 부합하는지 예시.
									b = np.array([0,1,2]) #b.shape가 (3,)이고, a의 맨 마지막 차원은 3, b의 마지막 차원은 3이므로 조건에 부합,
															b에는 더 이상 차원이 없으므로 브로드캐스팅 가능하다.
									b = np.array( [0] ) #b.shape 는 (1,). 맨 마지막 비교시 3과 1로 다르나, b의 차원이 1이므로 조건에 부합.
									b = np.array( [ [1,2] ] ) #b.shape는 (1,2). 맨마지막 차원의 값이 3과 2이므로 맞지않음. 오류발생
									b = np.array( [ [10,100,1000] ] ) #b.shape는 (1,3). 맨마지막 차원이 3으로 같고 그다음 차원은 2와 1이므로 1이 있어 부합.
									b = np.array( [ [10,100,1000], [-1,-1,-1], [-2,-2,-2] ] ) #b.shape는 (3,3). 맨마지막은 3으로 같으나 그 다음이 2,3이므로 맞지않음.
									b = np.array( [ [10,100,1000], [-1,-1,-1] ] ) #b.shape는 (2,3). 맨마지막이 3으로 같고, 그 다음도 2로 같아 부합.
						ㄴ ix_() 함수 )
							ㄴ ?????

					</pre>

					ㄴ 기본 <button>더보기</button>
					<pre>
						ㄴ Numerical Python. 숫자 데이터를 다루는데 사용되는 오픈소스 라이브러리.
						ㄴ ~~~~~
						ㄴ vector : 1차원 배열
						ㄴ matrix : 2차원 배열
						ㄴ tensor : 3차원 이상의 배열.
						ㄴ 위의 '개요'에서 다룬 내용 살짝 더 자세하게 반복.
						ㄴ ~~~~~

					</pre>

					ㄴ Array object<button>더보기</button>
					<pre>
						ㄴ ~~~~~
						ㄴ ndarray<button>더보기</button>
						<pre>
							ㄴ N-dimensional array
							ㄴ 같은 데이터 타입과 크기를 가진 item들의 다차원 배열.
							ㄴ 배열의 요소들의 데이터 타입은 각 ndarray마다 분리된 'data-type object'(일명 dtype)에 따로 정의되어있다.
							ㄴ ndarray의 내용물들은 파이선의 컨테이너들처럼 '인덱싱', '슬라이싱' 등을 통해 접근되고 수정될 수 있다.
							ㄴ 서로 다른 ndarray가 같은 데이터를 참조할 수 있다. ('view')
							ㄴ 파이선 '시퀸스'와의 차이점.
									ㄴ ndarray는 생성시 고정된 크기를 가진다. 사이즈 변경시, 기존 객체는 삭제되고 새 객체가 생성된다.
									ㄴ ndarray는 같은 타입의 데이터들만 담을 수 있다.
									ㄴ ndarray는 대량의 데이터에 대한 수학적 연산에 더 효과적이다.
									ㄴ 여러 수학, 과학 관련 파이선 라이브러리에서 ndarray를 사용하고 있다.

						</pre>
						ㄴ scalar<button>더보기</button>
						<pre>
							ㄴ 파이선에는 기본데이터 타입이 몇가지 없다. 정수타입하나, 실수타입하나 이런식.
							ㄴ 과학, 수학적인 계산이 필요한 경우, 더 다양한 데이터 타입들이 필요하고 numpy에서는 c언어의 데이터 타입에 근거하여
								24가지 새로운 데이터 타입을 정의하였고 이를 scalar라고 부른다.
							<img src="image/python%20dtype.png" height="413"/>
							ㄴ ~~~~~
						</pre>

						ㄴ dtype<button>더보기</button>
						<pre>
							ㄴ 배열에 할당된 메모리에 있는 바이트들이 어떻게 해석되어야 하는지를 나타내는 객체.
							ㄴ 다음의 정보를 가지고 있다.
								ㄴ 데이터 타입
									ㄴ numpy의 scalar 타입들 중 하나가 된다.
								ㄴ 데이터의 크기
								ㄴ 데이터의 바이트 순서(little endian, big endian)
								ㄴ ?????데이터 타입이 'structured data type'인
									ㄴ ?????
								ㄴ ?????
							ㄴ 인덱싱에 의해 배열에서 요소가 추출되면, 이 요소는 데이터 타입에 해당하는 파이선 객체가 된다.
							ㄴ ~~~~~
						</pre>

						ㄴ Indexing<button>더보기</button>
						<pre>
							ㄴ
						</pre>

					</pre>

					ㄴ 무제 <button>더보기</button>
					<pre>
						ㄴ 데이터 타입<button>더보기</button>
						<pre>
							ㄴ

						</pre>
						ㄴ 배열 생성
							ㄴ 다섯가지
							ㄴ 파이선 데이터로부터의 변환
							ㄴ 넘파이 배열 생성 함수 이용
							ㄴ 디스크로부터 배열 읽어들이기
							ㄴ raw 바이트로 배열생성
							ㄴ 특정 라이브러리 함수 사용
							ㄴ ?????
						ㄴ genfromtxt )
							ㄴ 표형태의 데이터로부터 배열을 생성할 수 있다.
					</pre>

				</pre>
				ㅡ Pandas<button>더보기</button>
				<pre>
					ㄴ 판다스란?
						ㄴ '관계형', '라벨형' 데이터를 잘 처리할 수 있게 해주는 데이터 구현체를 제공하는 파이썬 패키지.

					ㄴ data structures <button>더보기</button>
					<pre>
						ㄴ ????? Here is a basic tenet to keep in mind: data alignment is intrinsic.
							The link between labels and data will not be broken unless done so explicitly by you.
						ㄴ Series<button>더보기</button>
						<pre>
							ㄴ 어떠한 데이터 타입도 담을 수 있는 1차원의 라벨링 배열.
							ㄴ 축 라벨은 'index'라고 불린다.
							ㄴ 생성 )
								ㄴ s = pd.Series( (*data*), index=(*인덱스*) )
									ㄴ (*data*)
										ㄴ 스칼라값, 파이선 dict, ndarray가 올 수 있다.
									ㄴ (*인덱스*)
										ㄴ 축 라벨의 리스트. (*data*)가 무엇인지에 따라 몇가지 경우로 분류된다.
											ㄴ (*data*)가 ndarray인 경우 )
												ㄴ index는 (*data*)와길이가 같아야 한다.
												ㄴ index가 전달되지 않으면, 0부터 시작하는 정수인덱스가 자동으로 전달된다.
											ㄴ dict인 경우)
												ㄴ index가 전달되지 않으면, dict의 key값이 자동으로 label이 된다.
												ㄴ index가 전달되면, index의 값과 일치하는 key값이 매핑된다.
													ex)
														d = {'b':1, 'a':0, 'c':2}
														s = pd.Series(d, index=[0,1,2]) #index에 넘어온 0,1,2와 일치하는 dict의 key값이
																						없으므로, 출력은다음고 ㅏ같다.
																						0 NaN
																						1 NaN
																						2 NaN
							ㄴ Series는 ndarray와 유사하다.
								ㄴ Series는 numpy의 'ndarray'와 매우 유사하다.
								ㄴ 대부분의 Numpy함수에 ndarray대신 Series를 인자로 넘겨도 동작한다.
								ㄴ ndarray처럼 Series도 'dtype'속성을 가지고 있다.
									ㄴ dtype의 값은 numpy의 dtype값들을 포함하며 더 확장된 것들도 포함되어 있다.
								ㄴ Series.array
									ㄴ Series에서 'ExtensionArray'를 반환.
									ㄴ ?????
								ㄴ to_numpy(), numpy.asarray( (*Series*) )
									ㄴ Sereis로부터 numpy의 ndarray를 추출해 반환.
							ㄴ Series는 dict와 유사하다
								ㄴ 인덱스 label로 Series의 값을 다룰 수 있다는 점에서 고정크기의 dict와 유사하다.
								ㄴ index와 일치하는 label이 없으면, 예외발생.
									ㄴ get( (*label이름*) [, (*없을시 디폴트값*) ] ) 을 이용하면, label이 없을시 디폴트값 또는 None을 반환.
							ㄴ Series끼리의 연산을 하면, Series의 label에 따라 알아서 매핑이 되어 연산이 진행된다.
								ㄴ 연산중, 어느 한쪽에서 특정 label이 발견되지 않으면 NaN값이 할당된다.
							ㄴ Series는 name속성으로 이름을 가질 수 있다.
								ㄴ ex) s = pd.Series( data, name='noName' )
										s.name # 'noName'
						</pre>

						ㄴ DataFrame<button>더보기</button>
						<pre>
							ㄴ 여러 column을 가지는 2차원 레이블링 데이터 구조. column들은 서로 다른 유형의 데이터 타입일수 있다.
								ㄴ 스프레드 시트, sql테이블, Series의 dict을 생각하면 되ㅗㄴ다.
							ㄴ 생성 )<button>more</button>
							<pre>
								ㄴ 올 수 있는 데이터 타입 )
									ㄴ 1차원 ndarray, list, dict, Series의 dict
									ㄴ 2차원 numpy.ndarray
									ㄴ ????? Structured or record ndarray
									ㄴ Series
									ㄴ DataFrame
								ㄴ index와 column을 인자로 전달할 수 있다.
									ㄴ Sereies와 마찬가지로 인덱스가 일치하지 않으면 데이터를 버린다.
								ㄴ index는 여러 Series들의 합집합이 된다.
								ㄴ ex)<button>더보기</button>
								<pre>
									In [37]: d = {
									   ....:     "one": pd.Series([1.0, 2.0, 3.0], index=["a", "b", "c"]),
									   ....:     "two": pd.Series([1.0, 2.0, 3.0, 4.0], index=["a", "b", "c", "d"]),
									   ....: }
									   ....:

									In [38]: df = pd.DataFrame(d)

									In [39]: df
									Out[39]:
									   one  two
									a  1.0  1.0
									b  2.0  2.0
									c  3.0  3.0
									d  NaN  4.0

									In [40]: pd.DataFrame(d, index=["d", "b", "a"])
									Out[40]:
									   one  two
									d  NaN  4.0
									b  2.0  2.0
									a  1.0  1.0

									In [41]: pd.DataFrame(d, index=["d", "b", "a"], columns=["two", "three"])
									Out[41]:
									   two three
									d  4.0   NaN
									b  2.0   NaN
									a  1.0   NaN
								</pre>
								ㄴ 데이터가 ndarray, list의 dict인 경우)
									ㄴ ndarrys, list의 길이가 모두 같아야 한다.
									ㄴ 생성시 index를 전달하려면, ndarray, list와 길이가 같아야한다.
									ㄴ ex)
										In [44]: d = {"one": [1.0, 2.0, 3.0, 4.0], "two": [4.0, 3.0, 2.0, 1.0]}

										In [45]: pd.DataFrame(d)
										Out[45]:
										   one  two
										0  1.0  4.0
										1  2.0  3.0
										2  3.0  2.0
										3  4.0  1.0

										In [46]: pd.DataFrame(d, index=["a", "b", "c", "d"])
										Out[46]:
										   one  two
										a  1.0  4.0
										b  2.0  3.0
										c  3.0  2.0
										d  4.0  1.0
								ㄴ structured or record ndarray인 경우 )
									ㄴ ?????
								ㄴ dict의 list인 경우 )
									ㄴ ~~~~~
								ㄴ tuple의 dict인 경우 )
									ㄴ ~~~~~
								ㄴ Series인 경우 )
									ㄴ 입력된 Series와 동일한 인덱스를 사용하고, 하나의 열을 가진 DataFrame이 된다.
								ㄴ namedtuple 리스트인 경우 )
									ㄴ ~~~~~
								ㄴ dataclass의 list인 경우 )
									ㄴ ~~~~~
								ㄴ 대체 생성자들 )
									ㄴ DataFrame을 생성하는 다른 방법들 설명.
									ㄴ (*DataFrame*).from_dict()
										ㄴ dict의 dict, 또는 array형태값의 dict를 인자로 받아서 DataFrame을 반환해줌.
										ㄴ ex)	pd.DataFrame.from_dict(dict([("A", [1, 2, 3]), ("B", [4, 5, 6])]))
											ㄴ dict([("A", [1, 2, 3]), ("B", [4, 5, 6])]) 에서 다음과 같은 dict 생성
												{'A': [1, 2, 3], 'B': [4, 5, 6]}
											ㄴ 위의 생성된 dict로 DataFrame을 생성.
											ㄴ dict의 키가 열 레이블에 되고, 인자로 orient='index'를 주면 키가 행 레이블이 된다
												ㄴ ex)
													In [66]: pd.DataFrame.from_dict(
													   ....:     dict([("A", [1, 2, 3]), ("B", [4, 5, 6])]),
													   ....:     orient="index",
													   ....:     columns=["one", "two", "three"],
													   ....: )
									ㄴ (*DataFrame*).from_records
										ㄴ tuples의 list 또는 structured dtype인 ndarray를 받아 DataFrame생성.
										ㄴ 생성된 DataFrame의 index가 structured dtype의 특정 필드일 수 있다는 점만 제외하고는
											일반 DataFrame 생성자와 동일하다.
								</pre>
							ㄴ 열 선택, 추가, 삭제 )
								ㄴ DataFrame을 index된 Series의 dict로 생각할 수 있다. 열의 선택, 추가, 삭제도 dict의 작업문법과 유사하다.
								ㄴ ex)
									df["three"] = df["one"] * df["two"]
									df["flag"] = df["one"] > 2
									del df["two"]
									three = df.pop("three")
									df["foo"] = "bar"
								ㄴ ndarray삽입시 df와 길이가 일치해야한다.
								ㄴ drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise')
									ㄴ 열 또는 행을 제거.
									ㄴ
							ㄴ 메소드 체인에서의 새 열 할당 )
								ㄴ (*df*).assign()
									ㄴ ?????
									ㄴ 인자로 받은 열을 df에 추가한 '새로운 df'를 반환한다.
									ㄴ 새로운 df를 반환하므로 메소드 체인이 가능.
									ㄴ ?????
							ㄴ 인덱싱, 선택 )
								ㄴ 기본 인덱싱 방법들 )
									ㄴ df[col] : 컬럼 선택.
									ㄴ df.loc[lable] : 라벨로 row선택.
									ㄴ df.iloc[label] : 위치로 row선택.
									ㄴ df[5:10]  : row 슬라이스.
									ㄴ df[bool_vec] : ????? boolean vector로 row선택.
							ㄴ 데이터 정렬과 연산 )
								ㄴ df간의 정렬은 자동으로 행과 열을 정렬한다.
								ㄴ df와 Series간의 연산은 디폴트로, df의 컬럼과 Series의 index를 매핑한다.
								ㄴ 스칼라 값과의 연산은 당연히 모든 데이터에 적용된다.
								ㄴ boolean 연산도 적용된다.
							ㄴ Transposing, 행열뒤집기)
								ㄴ df의 T속성에 접근하면 된다.
							ㄴ NumPy 함수 사용 )
								ㄴ Series와 df에 NumPy의 함수를 사용할 수있으며, 데이터는 숫자값이어야한다.
								ㄴ df와 ndarray는 인덱스의 의미와 데이터 모델이 많이 달라 서로 대체하기 어렵다.
								ㄴ ?????
							ㄴ 콘솔 출력 )
								ㄴ df가 크다면 콘솔에는 일부가 생략되어 출력된다.
								ㄴ to_string()을 사용하면 콘솔창의 크기에 상관없이 표형식으로 df가 출력된다.
						</pre>
					</pre>

					ㄴ 기본 필수 기능들<button>더보기</button>
					<pre>
						ㄴ 판다스에서 사용되는 data structure들에 대한 기본적인 기능들을 살펴본다.
						ㄴ head(), tail()
							ㄴ data structure의 맨 앞부분, 끝부분을 보여주는 메소드.
							ㄴ 인자로 숫자를 넘기면 맨앞에서 또는 끝에서 해당 개수만큼 데이터를 보여줌. 디폴트는 5.
						ㄴ 속성들,
							ㄴ 속성들 )
								ㄴ shape : ndarray의 shape와 동일
								ㄴ axis 정보
									ㄴ Series인 경우 : index
									ㄴ DataFrame인 경우 : index, columns
								ㄴ ~~~~~
								ㄴ
								ㄴ ~~~~~
								ㄴ ????? DataFrame의 한 컬럼안의 데이터들이 동일한 타입이 아닐 경우 해당 컬럼에 값을 할당할 수 없다??
								ㄴ Series.values나 DataFrame.values로 실제 들어있는 데이터에 접근 가능하나, 다음의 이유로 Series.array, Series.to_numpy()를
									사용하라고함
									ㄴ Series가 pandas의 extension type을 포함하고 있을 경우, Series.values가 ndarray를 반환할지 extension array를
										반환할지 알 수 없다. 그에 반해, Series.array는 항상 'ExtensionArray'를 반환하고 복사본을 반환하지 않는다.
									ㄴ ?????
							ㄴ to_numpy()를 통해 내부의 데이터들을 numpy array로 변환할 수 있다.
								ㄴ dtype 매개변수로 변활할 때 내부 데이터의 타입을 지정할 수 있다.
								ㄴ DataFrame의 경우, 컬럼마다 데이터형이 다른 경우, 각 컬럼마다 변환이 적용되고,
									한 컬럼 내에서도 타입들이 다른 경우, 모든 데이터를 포함할 수 있는 타입이 결정된다.
									ㄴ ex ) float, integer 타입이 섞여있으면, float으로 결정되는 등.
								ㄴ to_numpy()
									ㄴ 내부의 numpy array를 반환한다.
									ㄴ 기본적으로 반환되는 numpy array의 dtype은 common numpy dtype이다.
						ㄴ ????? Accelerated operations
						ㄴ 이진 연산
							ㄴ ~~~~~
							ㄴ DataFrame.add(), DataFrame.sub(), DataFrame.mul(), DataFrame.div(), DataFrame.radd(), DataFrame.rsub() 등등의 메소드들이 있다.
							ㄴ 고차 데이터와 저차 데이터 사이의 이진 연산시의 '브로드 캐스팅'
								ㄴ 연산대상에 Series가 있을 경우, Series가 중심이 된다. 위 연산 함수들에서 'axis'라는 키값의 매개변수를 넘겨서 Series가
									어떤 축을 기준으로 계산될지 결정할 수 있다.
								ㄴ ex)
									In [19]: df
									Out[19]:
											one       two     three
									a  1.394981  1.772517       NaN
									b  0.343054  1.912123 -0.050390
									c  0.695246  1.478369  1.227435
									d       NaN  0.279344 -0.613172

									In [20]: row = df.iloc[1]

									In [21]: column = df["two"]

									In [22]: df.sub(row, axis="columns")	#column축을 기준으로 연산하도록 설정.
									Out[22]:
											one       two     three
									a  1.051928 -0.139606       NaN
									b  0.000000  0.000000  0.000000
									c  0.352192 -0.433754  1.277825
									d       NaN -1.632779 -0.562782
								ㄴ 'axis'매개변수의 값으로는 'columns'와 'index'가 올 수 있다. 문자열이다.
								ㄴ Series와 Index는 파이썬 내장함수 divmod()에도 사용할 수 있다.
									ㄴ (*몫*), (*나머지*) = divmod( (*Series또는 Index*), (*나눌값*) )
									ㄴ (*Series또는 Index*)를 (*나눌값*)으로 나누어, (*몫*)에는 나눈 몫의 Series를 넣고 (*나머지*)에 나머지값들을 넣는다.
									ㄴ ex)<button>더보기</button>
									<pre>
										In [29]: s = pd.Series(np.arange(10))

										In [30]: s
										Out[30]:
										0    0
										1    1
										2    2
										3    3
										4    4
										5    5
										6    6
										7    7
										8    8
										9    9
										dtype: int64

										In [31]: div, rem = divmod(s, 3)

										In [32]: div
										Out[32]:
										0    0
										1    0
										2    0
										3    1
										4    1
										5    1
										6    2
										7    2
										8    2
										9    3
										dtype: int64

										In [33]: rem
										Out[33]:
										0    0
										1    1
										2    2
										3    0
										4    1
										5    2
										6    0
										7    1
										8    2
										9    0
										dtype: int64
									</pre>
									ㄴ (*나눌값*)을 배열로넘겨 항목마다 나눌값을 따로 설정할 수도 있다.
							ㄴ 연산시에 missing data 처리
								ㄴ 위의 연산 함수들에 'fill_value'키값을 가지는 매개변수를 넘겨서 값이 비어있는 데이터인 경우(NaN같은), 어떤 값을
									채워넣어 연산을 할지 결정할 수 있다.
								ㄴ ex) df.add(df2, fill_value=0)
						ㄴ 비교연산 )
							ㄴ Series와 DataFrame에는 eq, ne, lt, gt, le, ge 등의 비교연산 메소드가 존재한다.
							ㄴ 위의 연산 메소드들과 유사하게 동작한다.
							ㄴ ?????
						ㄴ Boolean 관련 함수
							ㄴ DataFrame.empty : 해당 DataFrame이 비었는지 아닌지 판별하여 bool값 반환. NaN도값이 있는것으로 취급한다.
							ㄴ DataFrame.any()
								ㄴ 어떤 한 요소라도 true이면 true 반환.
							ㄴ DataFrame.all()
								ㄴ 모든 요소가 true이면 true반환.
							ㄴ DataFrame.bool() : 요소가 단 하나이고 그 요소가 boolean값인 DataFrame이나 Series에서 사용할 수 잇는 함수.
													해당 boolean값이 뭔지 알려준다.
							ㄴ 이런 함수들을 boolean값을 점차줄여나간다하여 'boolean reduction'이라고 소개하고있다.
						ㄴ 동등성 비교 )
							ㄴ '==', equals() 사용가능
							ㄴ == : 각 요소별로 값을 비교하여 동등하면 true. 단, 값이 NaN인 경우 똑같이 NaN이어도 동등하지 않다고 판단
							ㄴ equals() : ==와 동일한 기능. 단, 값이 NaN으로 같으면 동등하다고 판단.
							ㄴ ex)

						ㄴ 값 비교 )
							ㄴ Series, DataFrame을 스칼라 값이나 array-like값과 '=='를 사용하여 비교할 수 잇다.
							ㄴ ndarray와 달리 길이가 다르면 오류발생.
						ㄴ ~~~~~
						ㄴ dtype <button>더보기</button>
						<pre>
							ㄴ 대부분의 경우에 pandas는 numpy의 array와 dtype을 사용한다.
							ㄴ 몇몇 경우에 pandas와 third-party 라이브러리는 numpy의 type을 확장한다.
							ㄴ 커스텀으로 확장된 type을 만들어 판다스에서 사용할 수 있다.
							ㄴ 확장된 type들의 리스트 <button>더보기</button>
							<pre>
								ㄴ
							</pre>
						</pre>

					</pre>
					ㄴ 인덱싱, selection <button>more</button>
					<pre>
						ㄴ

					</pre>

					ㄴ 무제 <button>더보기</button>
					<pre>
						ㄴ 데이터 구조와 분석에 사용되는 여러 도구를 제공해주는 오픈소스 라이브러리.
						ㄴ '관계형', '라벨형?' 데이터에 대해 데이터 구조를 표현해주는 파이선 패키지이다.
						ㄴ 두가지 판다스의 대표 데이터 구조 : Series(1차원), DataFrame(2차원)
						ㄴ Numpy위에서 구축되었다.
						ㄴ ?????
						ㄴ Series )
							ㄴ 1차원의 라벨이 붙은 배열
						ㄴ DataFrame )
							ㄴ 2차원의 라벨이붙은 사이즈가 변할 수 있는 표형태.
							ㄴ ex)
								import pandas as pd
								df = pd.DataFrame({
									'name':['aaa','bbb','ccc'],
									'age' : [1,2,3],
									'sex' : ['m','f','m']
								})
								df #0  aaa    1   m
									1  bbb    2   f
									2  ccc    3   m와 같이 출력된다.
								ㄴ 인자로넘긴 객체의 키값은 표의 컬럼이 된다.
							ㄴ 각 컬럼들은 'Series'이다.
								ㄴ ex)
									df['name'] # 	0    aaa
													1    bbb
													2    ccc 와 같이 출력된다.
						ㄴ Series, DataFrame에 대해 여러 함수를 호출 할 수 있다.
							ㄴ ex) df.max() # 	name    ccc
												age       3
												sex       m 와 같이 출력
									df['name'].max() # 'ccc'출력
							ㄴ ex) df.describe() 숫자형 데이터에 대해 간략한 정보를 제공
											age
											count  3.0
											mean   2.0
											std    1.0
											min    1.0
											25%    1.5
											50%    2.0
											75%    2.5
											max    3.0 와 같이 출력.
								ㄴ name, sex컬럼은 문자형 데이터라서 안나옴.
						ㄴ CSV파일로부터 데이터 읽기
							ㄴ
						ㄴ ????? 왜 하나 이상의 데이터 구조인가?
							ㄴ ?????

						ㄴ 표형식 데이터 읽고 쓰기 )
							ㄴ read_csv()
								ㄴ csv파일을 읽어주는 함수. DataFrame형식으로 읽어준다.
							ㄴ DataFrame의 맨 위 8줄 읽기.
								ㄴ (*DataFrame*).head(8)
							ㄴ (*DataFrame 또는 Series*).dtypes : 각 컬럼들이 어떤 데이터 타입으로 해석되는지를 확인할수 있는 속성.
							ㄴ ex) to_excel("titanic.xlsx", sheet_name="passengers", index=False) : 데이터를 엑셀파일로 내보낼 수 잇는 함수.
							ㄴ read_(*읽기대상유형*)(), to_(*쓰기대상유형*)() 함수는 각각, 대상 파일을 읽어들여 DataFrame 또는 Series로 만들거나 그 반대
								작업을 하는 함수.ex) to_excel(), read_csv()
							ㄴ DataFrame의 info() : DataFrame의 데이터에 대한 메타정보?를 알려주는 함수.
						ㄴ DataFrame의 하위 집합 다루기 )
							ㄴ (*DataFrame 또는 Series*).shape 속성 : row와 column의 개수정보를 가지고있는 속성.
							ㄴ ex) bbb = df[ df["age"] > 35 ]
								ㄴ DataFrame에다 중괄호로 조건을 붙여 특정 row들만 추출.
							ㄴ ex) bbb = df[ df['pclass'].isin([2,3]) ]
								ㄴ pclass라는 컬럼이 2,3인 row추출.
								ㄴ isin()은 row의 값이 인자로 넘어간 리스트 중에 있으면 true반환.
								ㄴ df[(df["pclass"] == 2) | (df["pclass"] == 3)] 와도 동일.
							ㄴ ex) bbb = df[ df['age'].notna() ]
								ㄴ notna() : 'age'컬럼이 not null인 row이면 true 반환.
							ㄴ ex) bbb = df.loc[ df['age'] > 35, 'name' ]
								ㄴ age컬럼이 35이상인 row들의 name을 추출.
								ㄴ loc[ (*row선택*), (*column선택*) ], iloc[ ~~~~~ ] :
								ㄴ 대입도 가능하다.
								ㄴ iloc[]는 인덱스로 접근할 수 있는 loc[]라고 보면 된다.
						ㄴ 그래프 그리기 )
							ㄴ import matplotlib.pyplot as plt
							ㄴ (*DataFrame*).plot()
								plt.show() #그래프 출력.
						ㄴ 새로운 컬럼 추가 )
							ㄴ ex) df['newColumn'] = df['name']+'New'
							ㄴ 위와 같이, 중괄호안에 새로 추가할 컬럼명을 넣고, 알맞은 column값들을 넣어주면 새로생김.
						ㄴ 컬럼명 수정 )
							ㄴ ex)
								renamedDf = df.rename(
									columns={
										'name' : 'name2',
										'age' : 'age2'
									}
								)
							ㄴ 컬럼명이 바뀐 새로운 DataFrame이 반환된다.
						ㄴ groupby() : 데이터를 그룹화하여 통계처리가 가능하게함.
							ㄴ
						ㄴ Categorical 데이터 타입 : 숫자이기는 하나, 카테고리 분류 숫자 같은 것이어서 평균값계산등이 의미가 없는 데이터들을 위한 타입.
						ㄴ value_counts()
						ㄴ df.sort_values(by='age'), df.sort_values(by=['pclass','age'])
						ㄴ DataFrame 재구성 )
							ㄴ ex)
																city country            location parameter  value   unit
								date.utc
								2019-04-09 01:00:00+00:00  Antwerpen      BE             BETR801       no2   22.5  µg/m³
								2019-04-09 01:00:00+00:00      Paris      FR             FR04014       no2   24.4  µg/m³
								2019-04-09 02:00:00+00:00     London      GB  London Westminster       no2   67.0  µg/m³
								2019-04-09 02:00:00+00:00  Antwerpen      BE             BETR801       no2   53.5  µg/m³
								2019-04-09 02:00:00+00:00      Paris      FR             FR04014       no2   27.4  µg/m³
								2019-04-09 03:00:00+00:00     London      GB  London Westminster       no2   67.0  µg/m³
								기본 표가 위와 같을때,
								no2_subset.pivot(columns="location", values="value") #pivot()을 이렇게 호출해주면,

								location                   BETR801  FR04014  London Westminster
								date.utc
								2019-04-09 01:00:00+00:00     22.5     24.4                 NaN
								2019-04-09 02:00:00+00:00     53.5     27.4                67.0
								2019-04-09 03:00:00+00:00      NaN      NaN                67.0
								위와 같이 location이 컬럼이 되고 value컬럼이 value값이 된다.
							ㄴ pivot()
								ㄴ 값을 재배치만 한다.
							ㄴ pivot_table() : 값을 집계를 하며 재배치하고자 할때 사용.
								ㄴ ex) air_quality.pivot_table( values="value", index="location", columns="parameter", aggfunc="mean" )
							ㄴ wide table, long table?????
							ㄴ 두 테이블 결합 )
								ㄴ concat() )
									ㄴ row또는 column을 기준으로 두 테이블을 합침.
									ㄴ 디폴트로는 추가하는 테이블의 row를 붙이는 식으로 동작한다고함.
						ㄴ

					</pre>


				</pre>
				ㅡ KoNLPy<button>more</button>
				<pre>
					ㄴ Korean Natural Language Processing (한국어 자연어 처리)
					ㄴ 한국어 텍스트로부터 의미 있는 정보를 처리하는 기술 제공.
					ㄴ 설치 )
						ㄴ window )
							ㄴ 	pip install --upgrade pip
								pip install jpype1
								pip install konlpy
							ㄴ 자바 모듈을 사용하기 때문에 JVM이 필요하다. 하여 자바 설치 필요.
							ㄴ 확인 사항 및 자주 일어나는 오류 )
								ㄴ konlpy에서 요구하는 버전 이상의 자바가 설치되어 있는지 확인.
								ㄴ 자바 설치 후, 환경 변수 추가 필요. JAVA_HOME 및 Path에 %JAVA_HOME%\bin
								ㄴ 자바와 파이썬의 bit수 일치하는지 확인.
								ㄴ konply DDL load fail시 'visual studio c++ redistributable(x86)'을 설치해라. 이유는 정확히 모른다.
								ㄴ Jpype를 못 찾을 경우 uninstall하고 다시 설치하거나 'https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype'에서
									알맞는 버전을 찾아 다운받은 후 install해라. 파일 이름 중 cp37은 파이썬 버전 3.7~~을 의미.
					ㄴ 형태소 분석, 품사 태깅 )
						ㄴ 글로부터 형태소, 어근, 접두사/접미사, 품사 등 언어의 구조를 파악하는 것.
						ㄴ 품사 태깅은 분석한 각 형태소들에 분석 결과를 표시하는 것?????
						ㄴ konlpy의 'tag package'의 클래스들에서 이러한 품사 태깅 기능을 제공한다.
							ㄴ 이 클래스들은 여러 '형태소 분석기'들의 wrapper 클래스이다. ex) '한나눔', '꼬꼬마', "코모란", "트위터", "MeCab"
						ㄴ 한국어 형태소 분석기별 품사 태그 목록 : https://docs.google.com/spreadsheets/d/1OGAjUvalBuX-oZvZ_-9tEfYD2gQe7hTGsgUpiiBSXI8/edit#gid=0
					ㄴ 형태소 분석기 비교 )
						ㄴ 속도 비교 )
							ㄴ Hannanum, Okt가 빠른 편이고, Kkma, Komoran은 좀 느리다.
								Mecab은 빠르다고 하나 윈도우 지원이 안되어 사용해보지는 못 했다.
						ㄴ 성능 비교 )
							ㄴ Hannanum, Kkma은 정확도가 좀 떨어지는 듯 했다. Okt, Komoran은 괜찮았다.
					ㄴ 말뭉치 )
						ㄴ 말뭉치를 사용하여 형태소 분석 및 품사 태깅을 한다.
						ㄴ 형태소 분석기별 사용하는 말뭉치 )
							ㄴ
					ㄴ KoNLPy 이외의 ㅎ여태소 분석기 라이브러리 )
						ㄴ https://konlpy-ko.readthedocs.io/ko/v0.6.0/references/ 참조.
						ㄴ C/C++ )
							ㄴ MeCab-ko, UTagger, MACH, KTS
						ㄴ Java/Scala )
							ㄴ twitter-korean-text, KOMORAN, KKMA, Arirang, HanNanum
						ㄴ Python )
							ㄴ KoNLPy, UMorpheme
						ㄴ R )
							ㄴ KoNLP
					ㄴ KoNLPy 구성 )
						ㄴ sub package )
							ㄴ tag Package )
								ㄴ ~~~~~
								ㄴ Hannanum Class <button>more</button>
								<pre>
									ㄴ class konlpy.tag._hannanum.Hannanum(jvmpath=None, max_heap_size=1024)
										ㄴ 인자 두개는 'jvm' 모듈의 init_jvm()메소드로 넘겨짐.
									ㄴ 자바의 형태소 분석기 라이브러리인 'JHannanum'의 Wrapper.
									ㄴ 메소드 )
										ㄴ analyze(phrase)
											ㄴ 분석결과로 가능한 후보들을 나열한다.
											ㄴ ex )
												>>> sample = '이곳에서는 형태소 분석된 결과와 nltk.chunk.regexp.RegexpParser 를 이용하여 간단하게 한국어 문장에서 명사구, 동사구, 형용사구를 찾는 법을 살펴보도록 하겠습니다.'
												>>> konlpy.tag.Hannanum().analyze(sample)
												[[[('이곳', 'npd'), ('에서는', 'jca')], [('이곳', 'npd'), ('에서', 'jca'), ('는', 'jxc')], [('이곳', 'npd'), ('에', 'jca'), ('서는', 'jxc')], [('이', 'nnc'), ('곳', 'nbu'), ('에서는', 'jca')], [('이', 'nnc'), ('곳', 'nbu'), ('
에서', 'jca'), ('는', 'jxc')], [('이', 'nnc'), ('곳', 'nbu'), ('에', 'jca'), ('서는', 'jxc')]], [[('형태소', 'ncn')], [('형태', 'ncn'), ('소', 'ncn')]], [[('분석', 'ncpa'), ('되', 'xsvn'), ('ㄴ', 'etm')]], [[('결과', 'ncn'), ('
와', 'jcj')], [('결과', 'ncn'), ('와', 'jct')]], [[('nltk', 'f'), ('.', 'sf')], [('nltk', 'f'), ('.', 'sy')]], [[('chunk', 'f'), ('.', 'sf')], [('chunk', 'f'), ('.', 'sy')]], [[('regexp', 'f'), ('.', 'sf')], [('regexp', 'f'), (
'.', 'sy')]], [[('RegexpParser', 'f')]], [[('를', 'ncn')], [('를', 'nqq')]], [[('이용', 'ncpa'), ('하', 'xsva'), ('어', 'ecs')], [('이용', 'ncpa'), ('하', 'xsva'), ('어', 'ecx')], [('이용', 'ncpa'), ('하', 'xsva'), ('어', 'ef')
]], [[('간단', 'ncps'), ('하', 'xsms'), ('게', 'ecc')], [('간단', 'ncps'), ('하', 'xsms'), ('게', 'ecs')], [('간단', 'ncps'), ('하', 'xsms'), ('게', 'ecx')], [('간단', 'ncps'), ('하', 'xsms'), ('게', 'ef')]], [[('한국어', 'ncn'
)]], [[('문장', 'ncn'), ('에서', 'jca')]], [[('명사구', 'ncn'), (',', 'sp')], [('명사', 'ncn'), ('구', 'ncn'), (',', 'sp')]], [[('동사', 'ncn'), ('구', 'ncn'), (',', 'sp')], [('동사', 'ncpa'), ('구', 'ncn'), (',', 'sp')]], [[('
형용사', 'ncn'), ('구', 'ncn'), ('를', 'jco')], [('형용', 'ncpa'), ('사구', 'ncn'), ('를', 'jco')], [('형용', 'ncpa'), ('사구', 'ncpa'), ('를', 'jco')]], [[('찾', 'pvg'), ('는', 'etm')]], [[('법', 'nbs'), ('을', 'jco')], [('법'
, 'ncn'), ('을', 'jco')]], [[('살펴보', 'pvg'), ('도록', 'ecs')], [('살피', 'pvg'), ('어', 'ecx'), ('보', 'px'), ('도록', 'ecs')]], [[('하', 'pvg'), ('겠', 'ep'), ('습니다', 'ef')], [('하', 'px'), ('겠', 'ep'), ('습니다', 'ef')
]], [[('.', 'sf')], [('.', 'sy')]]]
										ㄴ morphs(phrase) : 형태소 분석 결과를 나열.
											ㄴ ex)
												>>> konlpy.tag.Hannanum().morphs(sample)
												['이곳', '에서는', '형태소', '분석', '되', 'ㄴ', '결과', '와', 'nltk', '.', 'chunk', '.', 'regexp', '.', 'RegexpParser', '를', '이용', '하', '어', '간단', '하', '게', '한국어', '문장', '에서', '명사구', ',', '동사구', ',', '형
용사구', '를', '찾', '는', '법', '을', '살피', '어', '보', '도록', '하', '겠습니다', '.']
										ㄴ nouns(phrase) : 형태소 분석 결과 명사만을 나열.
											ㄴ ex)
												>>> konlpy.tag.Hannanum().nouns(sample)
												['이곳', '형태소', '분석', '결과', '를', '이용', '간단', '한국어', '문장', '명사구', '동사구', '형용사구', '법']
										ㄴ pos(phrase, ntags=9, flatten=True, join=False) : '품사 태깅' 결과를 반환.
											ㄴ ex )
												>>> konlpy.tag.Hannanum().pos(sample)
												[('이곳', 'N'), ('에서는', 'J'), ('형태소', 'N'), ('분석', 'N'), ('되', 'X'), ('ㄴ', 'E'), ('결과', 'N'), ('와', 'J'), ('nltk', 'F'), ('.', 'S'), ('chunk', 'F'), ('.', 'S'), ('regexp', 'F'), ('.', 'S'), ('RegexpParser', 'F'), (
'를', 'N'), ('이용', 'N'), ('하', 'X'), ('어', 'E'), ('간단', 'N'), ('하', 'X'), ('게', 'E'), ('한국어', 'N'), ('문장', 'N'), ('에서', 'J'), ('명사구', 'N'), (',', 'S'), ('동사구', 'N'), (',', 'S'), ('형용사구', 'N'), ('를', 'J
'), ('찾', 'P'), ('는', 'E'), ('법', 'N'), ('을', 'J'), ('살피', 'P'), ('어', 'E'), ('보', 'P'), ('도록', 'E'), ('하', 'P'), ('겠습니다', 'E'), ('.', 'S')]

								</pre>
								ㄴ Kkma Class
									ㄴ Hannanum과 유사한 방식으로 사용하면 된다.
								ㄴ Komoran Class
								ㄴ Mecab Class
								ㄴ Okt Class

							ㄴ corpus Package )
						ㄴ 'data' 모듈 )
						ㄴ 'downloader' Module )
						ㄴ 'jvm' Module )
							ㄴ konlpy.jvm.init_jvm(jvmpath=None, max_heap_size=1024)
								ㄴ JVM(자바 가상머신)을 초기화하는 메소드.
								ㄴ 인자 )
									ㄴ jvmpath :
									ㄴ max_heap_size : 사용될 메모리 최대치. MB단위. defaul = 1024.
						ㄴ 'utils' Module )



					* !!!!! Mecab()클래스는 윈도우에서 지원되지 않음.

					ㄴ 무제 <button>more</button>
					<pre>
						ㄴ okt의 경우, 2.1버전 기준으로, org\openkoreantext\processor\util에 사전들이 txt문서로 정리되어 있다.
							이를 수정하여 형태소 분석의 결과를 조정할 수 있다.
					</pre>


				</pre>
                ㅡ Shapely<button>more</button>
                <pre>
                    ㄴ ~~~
                    ㄴ Geometric Object )
                        ㄴ ~~~
                        ㄴ 모든 생성자에서 숫자값들은 python의 'float'으로 변환된다.
                        ㄴ ??? 위상학적 함축성이나 인스턴스의 유효성을 검증하지 않는다?
                            ㄴ 'is_valid' predicate로 커스텀하면 된다함.
                        ㄴ 공통 속성, 메소드들 )
                            ㄴ ~~~
                        ㄴ 클래스 )
                            ㄴ Point )
                                ㄴ Point( (*x좌표값*), (*y좌표값*) )  또는 Point( (*좌표값을 담은 튜플*) )
                                    ㄴ ex ) Point(0.0, 0.0), Point( (0.0, 0.0) )
                                ㄴ ~~~
                            ㄴ LineString )
                            ㄴ LinearRing )
                            ㄴ Polygon )
                                ㄴ Polygon( (*순서대로정렬된 좌표 튜플 리스트*), [ (*polygon 내부 구멍을 나타낼 좌표튜플 리스트*) ] )
                                ㄴ 유효한 polygon )
                                    ㄴ shapely는 입력값에 대한 검증을 하지 않으므로 잘못된 좌표값 입력으로 인해 유효하지 않은 polygon이 생성될 수 있고
                                        이로 인한 예외가 발생할 수 있다.
                                    ㄴ 유효한 polygon이라면, 첫번째 인자로 그려진 linestring과 두번째 인자로 그려진 linestring이 만나지 않거나 단 한점에서만
                                        만난다.
                    ㄴ ??? 2차원 평면에 대한 라이브러리이기 떄문에 3차원좌표에 해당하는 z값은 Shapely안에서 무시된다.
                </pre>
			</pre>

			ㅇ Django<button>more</button>
			<pre>
				ㅡ ~~~~~

                ㅡ Migration <button>more</button>
                <pre>
                    ㄴ ~~~
                    ㄴ migration 꼬였을시,
                        ㄴ migration, db를 모두 날리고 다시 만들거나
                        ㄴ migrate --fake 이용
                            ㄴ 과정 )
                                ㄴ 현재 적용된 마이그레이션 현황 확인. manage.py showmigrations
                                ㄴ manage.py migrate --fake (*앱이름*) zero  를 통해 적용된 마이그레이션을 fake로 모두 되돌림.
                                ㄴ 되돌려졌는지 확인. manage.py showmigrations
                                ㄴ migrations 폴더 하위의 '__init__.py'를 제외하고 마이그레이션 파일 모두 삭제.
                                ㄴ 다시 마이그레이션 파일 생성. manage.py makemigrations (*앱이름*)
                                ㄴ fake migrate. manage.py migrate --fake-initial
                                    ㄴ 새로 만든 마이그레이션 파일임에도 manage.py showmigrations를 보면 적용된 마이그레이션이라 표시되고
                                        이로인해 의존성 관련 오류가 뜰 수 있다.
                                        ㄴ 이 경우, django_migrations 테이블에 같은 이름의 이전 마이그레이션이 존재해서 인듯 하다?
                                        ㄴ 이를 삭제하든 하면, 적용되었다는 표시가 사라진다.
                            ㄴ fake migrate를 하므로, db와 model이 불일치하는 부분이 없어야함.

                </pre>

                ㅡ manage.py <button>more</button>
                <pre>
                    ㄴ ~~~
                    ㄴ runserver )
                        ㄴ ~~~
                        ㄴ 상용 서버가 아닌 개발용 서버이기 때문에, 보안이나 성능에 대해 보장하지 않는다고 한다.
                            ㄴ 오래 실행되면 혼자 꺼지는 이슈도 이와 관련된게 아닌가 싶다.
                        ㄴ 옵션 )
                            ㄴ --noreload : runserver 실행중에 파이썬 코드 변경시 자동으로 서버를 재시작하는 기능을 끄겠다는 옵션.

                </pre>

				ㅡ Model <button>more</button>
				<pre>
                    ㄴ ~~~
                    ㄴ ForeignKey
                        ㄴ ~~~
                        ㄴ no_delete
                            ㄴ ~~~
                            ㄴ CASCADE
                            ㄴ PROTECT
                            ㄴ RESTRICT
                                ㄴ
					ㄴ 인스턴스 메소드<button>more</button>
					<pre>
						ㄴ __str__()
							ㄴ 객체에 대한 str( (*객체*) ) 호출시 호출되는 메소드.
							ㄴ 장고 admin 페이지에서 객체를 나타낼 때 str()호출을 통해 나타내므로, 이 메소드가 사용된다.
					</pre>
				</pre>

                ㅡ transaction <button>more</button>
                <pre>
                    ㄴ ~~~
                    ㄴ settings.py에 databases 설정에 'ATOMIC_REQUEST'=True 설정시,
                        request 단위로 transaction이 묶임.
                    ㄴ DRF의 exception_handler 기능을 view에 적용시,
                        view에서 exception발생시, transaction rollback이 안되는 이슈.
                        ㄴ exception handler가 view에서 발생한 예외를 받아 처리하기 때문으로 보임.
                            ㄴ 예외가 발생해야 이를 인지하여 transaction을 rollback시키는데 예외를 처리해버리므로.
                            ㄴ 다음과 같은 경우도 transaction rollback 안됨. 예외가 밖으로 던져지지 않고 내부에서 처리되기 때문.
                                ex )
                                    @api_view(["GET"])
                                    def aaa(request):
                                        try:
                                            raise Exception

                                        exception Exception as e:
                                            return (*Response*)
                        ㄴ 이 경우, DRF의 exception handler에서 명시적으로 rollback해주어야함.
                            ex )
                                from rest_framework.views import exception_handler, set_rollback

                                def custom_exception_handler(exc, context):
                                    handlers = {
                                        # "ValueError": _handle_generic_error,
                                        # "AttributeError": _handle_generic_error,
                                        "CustomException": _handle_generic_error,
                                    }

                                    response = exception_handler(exc, context)

                                    exception_class = exc.__class__.__name__
                                    if exception_class in handlers:
                                        set_rollback()  # rollback시킴. db 설정에 'ATOMIC_REQUESTS'=True이어야 rollback함.
                                        return handlers[exception_class](exc, context, response)

                                    return JsonResponse({"success": 0, "status": 500, "message": "서버에러입니다. 관리자에게 문의 주세요."})
                </pre>

                ㅡ 서버 세팅<button>more</button>
                <pre>
                    ㄴ Gunicorn )
                        ㄴ 방법 )
                            ㄴ gunicorn 설치
                                ㄴ pip install gunicorn
                            ㄴ 프로젝트 홈 디렉토리에서 gunicorn 실행 명령어 실행
                                ㄴ ex )
                                    gunicorn (*프로젝트폴더명*).(*wsgi파일명*):application (*옵션들...*)

                                    gunicorn deepqapps.wsgi:application --bind 0.0.0.0:8888
                                ㄴ 옵션 )
                                    ㄴ --bind : 포트 설정
                                        ㄴ ex ) --bind 0.0.0.0:8080
                                    ㄴ --daemon : 데몬으로 실행
                            ㄴ gunicorn 종료 명령어 )
                                ㄴ pkill gunicorn
                            ㄴ 정적 파일 반환 )
                                ㄴ gunicorn으로 정적 파일을 지원하려면 파이썬 'whitenoise' 모듈 필요.
                                ㄴ pip install whitenoise
                                ㄴ 장고 wsgi.py에 다음 설정 추가
                                    ㄴ ex )
                                        from whitenoise import WhiteNoise

                                        application = get_wsgi_application()

                                        application = WhiteNoise(application, root='/opt/deepq')
                                        application.add_files('/opt/deepq/static/', prefix='')

                </pre>

                ㅡ 설정 <button>more</button>
                <pre>
                    ㄴ ~~~
                    ㄴ DATABASES 설정
                        ㄴ ex )
                            DATABASES = {
                                'default': {
                                    'ENGINE': 'django.db.backends.postgresql',
                                    'NAME': 'openmetric',
                                    'USER': 'openmetric',
                                    'PASSWORD': ')!metricAdmin01',
                                    'HOST': '112.220.72.179',
                                    'PORT': '2345',

                                    # request 단위로 트랜잭션을 묶을지 여부. True설정시 당연히 view에 @transaction.atomic() 설정 필요 없다.
                                    "ATOMIC_REQUESTS": True,
                                }
                            }
                    ㄴ timezone )
                        ㄴ

                </pre>

                ㅡ DRF, Django Rest Framework<button>more</button>
                <pre>
                    ㄴ ~~~
                    ㄴ exception handler )

                </pre>

                ㅡ django test
                    ㄴ ~~~
                    ㄴ

				ㅡ 무제 <button>more</button>
				<pre>
					ㅡ 장고 db 테이블 생성
						ㄴ 장고 설치
							ㄴ pip install Django
							ㄴ pip3 install djangorestframework
							ㄴ pip install psycopg2
						ㄴ 프로젝트 폴더 안의 setting.py
							ㄴ 장고 설정 파일.
							ㄴ DATABASES name에서 db관련 설정.
							ㄴ TIME_ZONE name에서 시간 설정.
							ㄴ INSTALLED_APPS
								ㄴ ????? 현재 장고 인스턴스에서 활성화된 모든 장고 어플리케이션의 이름 목록 포함.
								ㄴ 기본적으로 몇 가지 앱들을 포함.
									ㄴ 'django.contrib.admin',
									  'django.contrib.auth',
									  'django.contrib.contenttypes',
									  'django.contrib.sessions',
									  'django.contrib.messages',
									  'django.contrib.staticfiles',
						ㄴ python manage.py migrate
							ㄴ migrate명령어는 setting.py의 INSTALLED_APPS를 보고 필요한 db 테이블들을 생성해 준다.
							ㄴ 아직 적용되지 않은 migration들을 수집하여 적용시켜줌.
						ㄴ 모델 생성
							ㄴ ~~~~~
						ㄴ 모델 활성화
							ㄴ 모델 정의 후, INSTALLED_APPS 목록에 정의가 들어있는 앱을 추가.
							ㄴ python manage.py makemigrations polls
								ㄴ 모델의 변경 사항에 대한 migration을 만드는 명령어.
							ㄴ 적용 내용들은 해당 앱의 migrations 폴더 안에 0001_initial.py 등과 같은 형태로 저장된다.
						ㄴ migrate시 실행되는 sql문 확인
							ㄴ python manage.py sqlmigrate polls (*mirgrations번호??*)
							ㄴ 해당 migration실행시 실행되는 sql을 보여준다.
					ㅡ 장고 프로젝트
						ㄴ 원하는 폴더 생성 후, 그 안에서 'startproject'옵션으로 장고 프로젝트 생성.
							ㄴ 이 폴더가 플젝의 리포지토리 폴더가 된다.
							ㄴ 리포지토리 폴더 안에 conf폴더 (또는 플젝 이름 폴더)를 만들고
						ㄴ 스프링 프레임워크와 같은 웹 프레임워크 중 하나.
							ㄴ 스프링처럼 MVC패턴을 따른다.
								ㄴ python을 이용해 db부분을 orm으로 다룰 수 있고(M)
								ㄴ 스프링의 컨트롤러처럼 url을 받아서 특정 함수 등으로 매핑시켜 처리할 수 있고(C)
									ㄴ 장고에서는 이를 'view'라고 부른다. (내가 생각하던 mvc의 view와 헷갈린다)
								ㄴ '템플릿'이라는 구성요소를 이용해 보여줄 페이지를 처리한다(V)
					ㅡ 장고 설치 및 실행
						ㄴ 파이썬 설치 후 django패키지를 설치.
						ㄴ 장고 프로젝트를 만들 폴더로 이동 후,
							django-admin startproject (*플젝이름*)
							실행.
						ㄴ 구조 )<button>more</button>
						<pre>
							ㄴ (*임의의 폴더명*)/
									manage.py
									(*플젝명*)/
										__init__.py
										settings.py
										urls.py
										asgi.py
										wsgi.py
							ㄴ 맨 위 폴더는 그냥 플젝이 들어있는 단순 폴더. 이름 변경해도 상관없음.
							ㄴ manage.py
								* django-admin, manage.py
									ㅡ 장고에서 제공하는 커맨드라인 명령어. 이ㅣ 명령어를 통해 장고 프로젝트의 여러 기능들을 사용할 수 있다.
									ㅡ 다음과 같은 형태로 사용된다.
											django-admin < command> [options]
											manage.py < command> [options]
											python -m django < command> [options]
									ㅡ 명령어 목록 )<button>more</button>
									<pre>
										ㄴ django-admin runserver [ (*주소와 포트*) ] )
											ㄴ '경량 개발 서버'를 실행시킨다.
										ㄴ manage.py startapp (*앱 이름*)
											ㄴ 어플 하나 생성.

									</pre>
								* WSGI, python web server gateway interface
									ㅡ 웹 서버와 파이썬 어플리케이션(또는 파이선 프레임워크)간의 커뮤니케이션, 호출을 어떻게 하는지
										그 방식에 대한 협약, 관례, 정의된 스펙이다.
										ㄴ 배경 )
											ㄴ 이전에는 파이썬의 프레임워크들이 각각 특정 웹 서버를 사용해야 해서 프레임워크와
												웹 서버 선택에 있어서 제약이 존재.
											ㄴ 자바의 servlet과 같이 서버와 프레임워크 사이에 스펙을 정의하여 이를 준수하는
												웹 서버와 프레임워크는 서로 제약 없이 어느 것을 선택하더라도 사용이 가능하도록
										ㄴ 웹 서버로부터 요청을 받아서 파이썬 어플리케이션에 전달해 주는 미들웨어에 대한 스펙.
									ㅡ 파이선 표준 WSGI에 대해서는 공홈의 'PEP 3333'에 자세히 나와있다.
								* CGI, WAS, Servlet 등..<button>more</button>
								<pre>
									ㅡ 모두 웹 서버로 들어온 요처에 대해 동적인 결과물을 반환해 주기 위한 기술이다?
									ㅡ CGI
										ㄴ ~~~~~
										ㄴ 서버가 동적인 결과를 위해 외부 프로그램을 실행해야 하는데, 이 때, 이 외부 프로그램을
											실행하고 데이터를 넘겨주고 하는 '서버와 외부 프로그램간의 커뮤니케이션 방식'에 대해
											스펙을 정한 것.
											서버가 받은 요청의 추가 데이터를 어떤 방식으로 외부 프로그램에 넘겨줄지에 대한 협약.
											ㄴ 가령, 'http get메소드 요청에서 url 뒤에 오는 쿼리스트링은 'QUERY_STRING'환경변수에
												저장해둔다' 등. 이렇게 정해 두면 외부 프로그램은 정해진 곳에서 데이터를 찾으면 되므로.
											ㄴ 그 전에는 서버마다 다른 방식으로 커뮤니케이션을 하여 서버에 따라 공통적으로 실행 가능한
												프로그램을 개발하기 어려웠다함.
										ㄴ 이슈
											ㄴ 초기의 CGI프로그램들(cgi를 따르는 프로그램들)은 웹 서버의 'security context'??? 안에서 실행되었는데,
											이로 인해 유저 인풋값을 제대로 보안 처리하지 못 할 경우 악성 명령어가 웹 서버에서 그대로
											실행된다는 문제점이 있었다.
											ㄴ 하여, 웹 서버에서 새로운 프로세스를 생성하여 cgi프로그램을 실행시키고 처리가 끝나면
												프로세스를 죽이는 방식으로 변경되었다.
											ㄴ 새 프로세스를 생성하고 죽이는 방식 때문에, cgi프로그램은 필요 이상의 cpu와 메모리를
												할애하였고, request가 많아지면 쉽게 과부하에 걸렸었다.
											ㄴ 다음과 같은 방법으로 보완하였다고 한다.
												ㄴ ~~~~~ https://en.wikipedia.org/wiki/Common_Gateway_Interface#Using_CGI_scripts
								</pre>
							ㄴ (*플젝명*)폴더
								ㄴ 프로젝트의 실제 파이썬 패키지들이 위치.
							ㄴ (*플젝명*)/__init__.py : 단순히 파이썬에서 패키지를 나타낼때 사용되는 그 __init__.py파일.
							ㄴ (*플젝명*)/settings.py : 장고 플젝의 설정 파일
							ㄴ (*플젝명*)/urls.py : 장고 플젝의 url 선언 및 저장
							ㄴ (*플젝명*)/asgi.py : ?????ASGI 호환 웹서버의 시작 파일??
							ㄴ (*플젝명*)/wsgi.py : ?????WSGI 호환 웹서버의 시작 파일??
						</pre>
					ㅡ ~~~~~
					ㅡ django shell
						ㄴ python manage.py shell
							ㄴ 파이선 shell을 열어준다.
							ㄴ manage.py가 'DJANGO_SETTINGS_MODULE' 환경 변수를 설정하여 프로젝트의 setting.py파일 등의 정보들을
								import할 수 있게 해주기 때문.
					ㅡ django model에 대해 filter메소드를 호출함으로서 db쿼리를 이용한 조회와 같은 기능을 사용할 수 있다.
						ㄴ fk와 같이 연결된 데이터도 가져올 수 있다. ( 더블언더바 '__'를 이용)
					ㅡ django.urls
						ㄴ path(route, view, kwargs=None, name=None)
							ㄴ route는 string타입의 url 패턴값.
								ㄴ 매개변수나 도메인 이름을 제외한 부분만을 대상으로 한다.
								ㄴ 패턴이 일치할 경우, HttpRequest객체를 첫번째 인수로 하고
								ㄴ <, >를 이용해 해당 부분의 url의 값을 view의 인자로 넘길 수 있다. 'bio/< username>/'
									ㄴ < > 안의 이름 앞에 타입을 넣어 값을 변환할 수도 있다. 'bio/< int:num>/'
							ㄴ view 인자
								ㄴ view함수 또는 view명칭.
								ㄴ django.urls.include()함수를 사용할 수도 있다.
							ㄴ kwargs 인자 : view에 추가적인 인자를 넘길 수 있다.
						ㄴ include
							ㄴ ????? 다른 URLconf의 파이선 full import path를 받아서 이를 URLconf에 추가시켜 준다.
							ㄴ ex) 'path('summernote/', include('django_summernote.urls'))'
								ㄴ 'summernote/'패턴과 일치하게 되면 'summernote/'부분을 제거하고 나머지 부분을 'django_summernote.urls'의
									URLconf로 보낸다.
					ㅡ setting.py의 'TEMPLATES'으로 탬플릿 설정 가능.
						ㄴ 어느 폴더로부터 탬플릿 파일을 찾을지 등.
					ㅡ ex)
						def index(request):
						latest_question_list = Question.objects.order_by('-pub_date')[:5]
						template = loader.get_template('polls/index.html')
						context = {
							'latest_question_list': latest_question_list,
						}
						return HttpResponse(template.render(context, request))
						ㄴ 'polls/index.html'탬플릿을 가져와 context 데이터와 함께 전달하며 호출.
						ㄴ 이를 render(request, 'polls/index.html', context)로 간단하게 쓸 수 있다. render()는 위 과정의
							shortcut 메소드.
					ㅡ 'Http404'예외를 발생시켜 404를 반환할 수도 있다.
						ㄴ shortcut
							ㄴ get_object_or_404( (*객체*), (*조건*) ) : 객체가 없을 경우 404예외 발생.
					ㅡ 모델 )
						ㄴ django.db.models.Model
						ㄴ 파이썬 클래스로서, db의 테이블에 해당한다고 보면 된다.
							ㄴ 속성 하나는 테이블의 필드 하나로 보면 되고.
						ㄴ ex)
							from django.db import models

							class Person(models.Model):
								first_name = models.CharField(max_length=30)
								last_name = models.CharField(max_length=30)
						ㄴ 위와 같이 모델 정의 후, 해당 모델을 이용할 것이라고 장고에 명시해야 한다.
							ㄴ setting.py의 'INSTALLED_APPS'에 해당 모델이 정의된 모듈이름을 추가하면 된다.
						ㄴ 필드 )
							ㄴ 클래스의 속성이 곧 필드.
							ㄴ 필드명이 models.Model의 이름과 겹치지 않도록 주의하라.
							ㄴ 'Field' 클래스
								ㄴ 적절한 'Field' 클래스의 인스턴스이어야 한다.
									ㄴ 어떤 'Field' 인스턴스인지에 따라 다음을 결정
										ㄴ db의 자료형
										ㄴ 템플릿에서 form 렌더링에 사용될 디폴트 html 위젯
										ㄴ 장고 어드민과 자동 생성 폼에서 사용될 최소한의 유효성 검증.
									ㄴ 'Field' 인스턴스 리스트 : https://docs.djangoproject.com/ko/3.2/ref/models/fields/#model-field-types
							ㄴ 'Field' 클래스의 옵션
								ㄴ 각 'Field' 인스턴스들에 인자로서 옵션을 줄 수 있다.
								ㄴ 인스턴스마다 다를 수 있고 필수인 것도, 아닌 것들도 있다.
								ㄴ 대표 예
									ㄴ null : 필드에 null 가능 여부. 디폴트는 false.
									ㄴ blank : 필드에 blank 가능 여부. 디폴트는 false.
									ㄴ choices : 필드에 대한 값이 선택형이 된다. 2개의 tuple로 된 파이썬 'sequence'를 인자로 받는다.
													form 위젯의 디폴트가 'select'가 된다.
										ㄴ 튜플의 첫 번째는 db에 저장될 값, 두번째는 form 위젯에 표시된다.
										ㄴ 두 번째 값은 모델의 get_(*필드명*)_display()를 통해 얻을 수 있다.
									ㄴ default : 필드의 디폴트 값. 값이나 callable object가 올 수 있다. 후자인 경우, 새 객체 생성시마다
													호출된다.
									ㄴ help_text : form 위젯에 표시될 도움말 텍스트. 주석으로서도 도움이 된다.
									ㄴ primary_key : True이면, 해당 필드가 모델의 pk가 된다.
													모델에 이게 True인 필드가 없으면 자동으로 pk인 IntegerField가 추가된다.
													자동 할당시, setting의 'DEFAULT_AUTO_FIELD'를 이용한다.
													pk는 read-only이며, 수정 후 저장하게 되면 수정이 아닌 그 pk값으로 새 객체 생성.
									ㄴ unique : True일시, 유니크 제약 추가.
								ㄴ 상세 필드 옵션 리스트 : https://docs.djangoproject.com/ko/3.2/ref/models/fields/#common-model-field-options
								ㄴ verbose name
									ㄴ ForeignKey, ManyToManyField, OneToOneField를 제외한 필드들은 optional first positional 인자로
										verbose name을 받는다.
									ㄴ ~~~~~
							ㄴ 관계
								ㄴ 장고는 다대일, 다대다, 일대일 관계를 제공.
								ㄴ 다대일 )
									ㄴ 모델의 필드 정의에 ForeignKey를 사용함으로서 정의.
									ㄴ ex)
										class Car(models.Model):
    										manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
									ㄴ class ForeignKey(to, on_delete, **options)
										ㄴ 인자 )
											ㄴ to : 연결될 모델 클래스
											ㄴ on_delete : 참조하는 객체 삭제시, 어떻게 처리할지를 설정.
												ㄴ db에 대하여 sql 제약을 생성하지는 않는다.
												ㄴ 가능한 값들 )
													ㄴ CASCADE : 참조되는 객체 삭제.
													ㄴ PROTECT : 삭제하지 않음.
													ㄴ RESTRICT : ?????
													ㄴ ~~~~~

								ㄴ 다대다 )
									ㄴ ManyToManyField 사용함으로서 정의.
									ㄴ ex)
										class Pizza(models.Model):
											# ...
											toppings = models.ManyToManyField(Topping)
									ㄴ 양방향인 두 모델 중 하나에만 정의하면 된다.
									ㄴ 다대다로 정의시 중간 매핑 테이블이 자동으로 생성되지만, ManyToManyField에
										'through' 인자를 추가하여 임의로 만들 수 있다. 이를 '중개 모델'이라고 한다.
										ㄴ 자동으로 생성되는 중개 모델은 필드로 id값만 가지고 있기 때문에 추가적인 데이터가 필요하면
											이를 사용한다.
										ㄴ ????? 개인적으로 임의로 중간 매핑 테이블을 생성하여 사용하는 것과 뭐가 다른지 잘 모르겠다.

						ㄴ 메소드 )
							ㄴ get_next_by_(*필드명*) (), get_previout_by_(*필드명*) ()
								ㄴ DateField, DateTimeField의 필드의 경우, 필드 옵션의 null=False인 경우 이 메소드를 통해 바로
									이전, 이후의 모델 객체를 반환받을 수 있다.
								ㄴ DoesNotExist 예외를 발생시킨다.


					ㅡ 마이그레이션 )
						ㄴ 개요 )
							ㄴ '모델'에 생긴 변화를 버전 관리 시스템처럼 관리하는 장고의 기능.
							ㄴ makemigrations 명령어로 모델에 생긴 변화를 '마이그레이션' 파일에 기록하고, migrate명령어로 이 변경점을
								db에 반영한다.
							ㄴ '마이그레이션 파일'은 각 앱의 'migrations' 폴더 안에 있다.
						ㄴ 명령어 )
							ㄴ migrate
							ㄴ makemigrations
								ㄴ --name 옵션으로 마이그레이션 파일에 이름을 부여할 수 있다.
									ㄴ python manage.py makemigrations --name (*이름*) (*앱*)
							ㄴ sqlmigrate
							ㄴ showmigrations
						ㄴ ????? db 별
							ㄴ ~~~~~
						ㄴ 과정 )
							ㄴ 모델 파일 수정 후, makemigrations 명령어 수행시, '마이그레이션 파일'들에서 최신 버전과 비교하여
								모델 파일을 스캔.
								ㄴ 장고가 인식한 마이그레이션 변경 사항이 정확한지 확인할 수 있다.
						ㄴ vc 관련 이슈
							ㄴ 두 개발자가 같은 이름의 마이그레이션 파일을 동시에 커밋 할 수도 있다.
							ㄴ 마이그레이션 파일 번호는 개발자의 편의를 위해서 있을 뿐이고, 장고는 각 마이그레이션에 대한 다른 이름을
								부여하고 있고, 각 마이그레이션들은 각각이 의존하고 있는 다른 마이그레이션들을 참조하고 있다.
						ㄴ 트랜젝션 이슈
							ㄴ DDL 트랜젝션을 지원하는 db의 경우(SQLite, PosgreSQL)는 모든 마이그레이션 작업이 한 트랜젝션 안에서 일어나지만,
								지원하지 않는 경우(Mysql, Oracle)는 트랜젝션 없이 일어난다.
					ㅡ Authentication system
						ㄴ ~~~~~
						ㄴ User
							ㄴ 기본 장고 User
								ㄴ ~~~~~
							ㄴ 커스텀 User 사용
								ㄴ django.contrib.auth.models.AbstractUser를 상속하는 모델을 커스텀으로 정의하여 사용.
								ㄴ 정의후, settings.py에 'AUTH_USER_MODEL = "(*커스텀 User모델*)"입력 필요.
								ㄴ ex )
									in models.py... )
									class DeepQUser(AbstractUser):
    									~~~

									in settings.py... )
									~~~
									AUTH_USER_MODEL = "member.DeepQUser"
								ㄴ 장고 기본 User와 동일한 기능을 하는 auth_user가 생성되며, 커스텀 model에서 table에 대해 커스텀이 가능하다.
								ㄴ 기존에 User를 사용하다 커스텀 User로 변경하려는 경우 )
									ㄴ
				</pre>

			</pre>


		</pre>
		스크래핑<button>더보기</button>
		<pre>
			ㄴ 웹 크롤링 vs 웹 스크래핑
				ㄴ 크롤링이란, 특정 '시드'?를 기준으로 관련된 데이터들을 탐색해가며 모두 가져오는 것. 중복이 당연히 없어야하고, 스케일이 크다.
					ㄴ 이를 수행하는걸 crawl agent, crawl bot, spider 이라고 불린다.
				ㄴ 스크래핑이란, 단순히 웹이나 기타 소스를 통해 필요한 데이터를 뽑아내는 것. 중복이 상관없고 소스로부터 데이터를 뽑아낼 수 있는 파서가 필요하다.
				ㄴ 두 단어가 혼동되어 사용되는 경우가 잦으며, 보통 단순한 웹 스크래핑을 웹 크롤링이라 잘 못 부르는 경우가 많다고 한다.
			ㄴ 여기서 다룰 내용은 웹 스크래핑이다.

			* 데이터 전처리<button>more</button>
			<pre>
				ㅡ 수집한 데이터를 분석에 사용하기 위해 가공하는 것을 말한다.
				ㅡ
				ㅡ 분석에 부적합한 구조, 누락 항목, 결측값 등을 처리
				ㅡ 노이즈 제거, 중복값 제거, 결측값 보정, 데이터 구조 변경 등
				ㅡ 그냥 분석에 안 맞는 데이터들을 수정해 주는 것.
				ㅡ 무제 )
					ㄴ 딱히 일반적인 기술이나 이론같은게 없는 것 같다. 그냥 수집한 데이터에 따라서 데이터를 잘 가공하면 되는 듯 하다.
			</pre>

			* Beautiful Soup 라이브러리.<button>더보기</button>
			<pre>
				ㅡ https://www.crummy.com/software/BeautifulSoup/bs4/doc/# 참고.
				ㅡ html, xml 문서를 받아서 이것으로부터 데이터를 뽑아 올 수 있게 해주는 파이썬 라이브러리.
					ㄴ ????? 파서들을 이용하여 요소들의 데이터를 뽑아오는식인듯 하다.
				ㅡ 내부적으로 파이선 표준 라이브러리의 HTML parser를 지원해주며, 추가적으로 third-party 파이선 parser인 'lxml parser'등도 지원해 준다.
					* lxml이란?
						ㅡ ????? C언어의 'libxml2'와 'libxslt'를 묶어서 파이썬에서 사용할 수 있게 해주는 xml도구?
				ㅡ find(), find_all()?등의 여러 함수 제공
				ㅡ ~~~~~
				ㅡ 파서의 종류가 다르면 반환되는 문서의 형태가 다를 수 있다.
					ㄴ ex)
						BeautifulSoup("< a>< /p>", "lxml")
						// < html>< body>< a>< /a>< /body>< /html>

						BeautifulSoup("< a>< /p>", "html5lib")
						// < html>< head>< /head>< body>< a>< p>< /p>< /a>< /body>< /html>

						BeautifulSoup("< a>< /p>", "html.parser")
						// < a>< /a>
					ㄴ 따라서 BeautifulSoup 객체 생성시 파서를 명시해주는것이 좋다.
				ㅡ 인코딩 )
					ㄴ ~~~~~
				ㅡ 무제 )
					ㅡ html, xml등의 문서를 파싱해주는 라이브러리???
					ㅡ 문서에서 특정 요소들을 추출해주는 기능을 해준다.
						ㄴ ex)
							from bs4 import BeautifulSoup

							soup = BeautifulSoup( (*html문서*) )
							soup.find('title') #html문서에서 title태그를 찾아 반환해준다.
					ㅡ 요소를 찾기위해 인자로 넘어가는 문자열은 css 셀렉터와 거의 동일한 듯하다.

			</pre>

			* selenium<button>더보기</button>
			<pre>
				ㅡ 참조 ) 공홈 https://www.selenium.dev/, https://selenium-python.readthedocs.io/, https://www.selenium.dev/selenium/docs/api/py/index.html
				ㅡ 웹페이지 테스트 자동화용 모듈.
				ㅡ 지원하는 브라우저들의 'WebDriver'와 자체적인 'WebDriver'를 사용하여 동작.
				ㅡ 각 브라우저의 'Web Driver'가 있어야 사용가능하다. ex) 크롬의 크롬드라이버, 파이어폭스의 geckodriver 등
					ㄴ 드라이버의 경로 또한 정확하게 있어야한다.
				ㅡ Navigating )
					ㄴ ?????
					ㄴ driver.get( (*url*) )
						ㄴ url에 해당하는 페이지를 드라이버가 받아온다.
						ㄴ 드라이버는 해당 페이지가 완전히 로드 될때까지('onload'이벤트 호출) 기다렸다가 그 이후에 완료된다.
						ㄴ 해당 페이지에 대해서만 완전히 로드되는걸 기다리는 것이고, ajax등으로 데이터를 로드하거나 문서구조가 바뀌는 것은
							드라이버가 이게 언제 완료되는지 알 수 없기때문에, get()에서 이런것들까지 기다리지는 않는듯하다.
							ㄴ 이런건 아래에 나오는 'Wait'기능으로 해결한다.
					ㄴ ~~~~~
				ㅡ ~~~~~
				ㅡ WebDriver<button>more</button>
				<pre>
					ㄴ ~~~~~
					ㄴ selenium.webdriver.remote.webdriver.WebDriver 클래스<button>more</button>
					<pre>
						ㄴ ~~~~~
						ㄴ 이름들<button>more</button>
						<pre>
							ㄴ ~~~~~
							ㄴ page_source : 현재 페이지의 소스가 'str'형태로 들어있다.
							ㄴ current_url : 현재 window의 url을 출력
							ㄴ current_window_handle : 현재 window handle의 이름이 'str'형태로 들어있다.
							ㄴ window_handles : 모든 window handle들의 이름 목록이 'list'형태로 들어있다.
							ㄴ ~~~~~
							ㄴ switch_to )
								ㄴ ~~~~~
								ㄴ window handle을 전환할 수 있다.
									ㄴ ex) driver.switch_to.window( (*window handle*) )
						</pre>
					</pre>

                    ㄴ webdriver Chrome <button>more</button>
                    <pre>
                        ㄴ ~~~
                        ㄴ Option<button>more</button>
                        <pre>
                            ㄴ chrome webdriver를 실행할 때, 여러가지 옵션을 주어 실행시킬 수 있다.
                            ㄴ 목록 )<button>more</button>
                            <pre>
                                ㄴ ~~~
                                ㄴ --headless
                                    ㄴ 창 없이
                                ㄴ user-agent
                                    ㄴ request headers의 user-agent라는 속성값을 설정하는 옵션.
                                    ㄴ user-agent가 무엇이느냐에 따라 웹페이지의 동작 방식이나 구성이 달라지는 듯 하다.
                                        ㄴ ex ) user-agent가 HeadlessChrome인 경우 페이지의 특정 요소가 렌더링이 안 되는 등.
                                    ㄴ headless 사용시 user-agent가 headless 관련된 값으로 자동 설정되고 이로인해 페이지 구성이 다른 경우가 많은 듯 하다.
                                        headless 사용시 꼭 user-agent를 설정하도록.
                            </pre>
                        </pre>
                    </pre>
				</pre>

				ㅡ Wait )
					ㄴ ajax등을 통해 페이지의 요소들이나 데이터들이 각기 다른 시점에 로드되는 경우, 드라이버를 통해 요소를 찾는 것이 어려워진다.
						이런 경우들을 위해, 잠깐 '대기'를 하는 기능을 제공한다.
					ㄴ 대기의 종류에는 '암시적 대기'와 '명시적 대기'가 있다.
					ㄴ Explicit Waits )
						ㄴ 특정 조건을 만족할 때까지 대기한다. ex) 특정 요소가 존재할때까지 대기, 특정 text가 있을때까지 대기 등
						ㄴ ~~~~~
					ㄴ Implicit Waits )
						ㄴ 요소를 찾는데 그 요소가 현재 없거나 하여 이용가능하지 않을 경우, 몇초동안 찾고있을지를 설정한다.
						ㄴ ex)
							chrome_driver = 'C:/Users/kai/Desktop/chromedriver_win32/chromedriver.exe'
							driver = webdriver.Chrome(chrome_driver)
							driver.get('https://deepsearch.com/analytics/economic-indicator?pageView=1&symbol=BOK%3A036Y001.0000001&chartEditSetting=JTdCJTIyc2VyaWVzTGlzdCUyMiUzQSU1QiU3QiUyMnN5bWJvbCUyMiUzQSUyMkJPSyUzQTAzNlkwMDEuMDAwMDAwMSUyMiUyQyUyMmF4aXMlMjIlM0EwJTdEJTVEJTJDJTIybGVnZW5kUG9zaXRpb24lMjIlM0EyJTJDJTIybGVnZW5kT3JpZW50YXRpb24lMjIlM0ElMjJoJTIyJTdE')
							driver.implicitly_wait(1) //implicit wait를 1초로 설정. 요소를 찾을때 요소가 없으면 1초동안 계속 찾도록 설정된다.
							data = driver.find_element_by_css_selector('div.rt-resizable-header-content')
							print(data.text)
						ㄴ 설정하지 않으면 디폴트값은 당연히 0이다.
						ㄴ 설정한 시간동안 못찾으면 못찾았다는 예외 발생.

				ㅡ 무제 )
					ㄴ WebElement의 click()는 해당 요소의 좌표를 클릭하는 식으로 동작하는 듯함.
						ㄴ 해당 요소가 화면에서 안 보이거나, 가려져 있으면 영어로 '해당 좌표에서 해당 요소르 ㄹ클릭할 수 없다는 오류'발생.
						ㄴ 해서, 'driver.execute_script("arguments[0].click();", button)' 등의 방법으로 클릭 실행.
						ㄴ click()사용시, clickInterrcept오류 발생시, 화면 안에 요소가 없어서 다른 요소가 클릭을 받았다는 오류.
							바로 위의 execute_script()를 쓰거나 안 되면, selenium의 Actions을 사용하여 해당 요소로 위치 이동 후,
							click()을 수행해 보자.
							ㄴ ex ) 	from selenium.webdriver import ActionChains
										ActionChains(self.driver).send_keys(Keys.PAGE_UP).move_to_element(button).click(button).perform()
								ㄴ 중간의 send_keys(Keys.PAGE_UP)은 해당 요소가 애매하게 현제 스크롤 위치 근처에 있으면 move_to_element()로
									스크롤이 이동하지도 않고 click()은 여전히 clickInterrcept되는 경우가 있어서, 스크롤 위치를 한번
									옮겨주고 클릭하려는 요소 위치로 이동하는 것.

			</pre>

			* Scrapy <button>더보기</button>
			<pre>
				ㅡ 공식문서 참조 https://docs.scrapy.org/en/latest/
				ㅡ Scrapy 2.5
				ㅡ 웹 크롤링, 웹 스크래핑에 사용되는 프레임워크.
				ㅡ 설치 )
					ㄴ 윈도우면 아나콘다 또는 미니콘다를 이용하여 설치하는걸 권장.
						ㄴ conda install -c conda-forge scrapy
				ㅡ Command line tool <button>더보기</button>
				<pre>
					ㄴ ?????
					ㄴ scrapy.cfg 파일로부터 설정정보를 읽어들인다.
						ㄴ scrapy.cfg파일은 시스템전체용, 유저전체용, 각 플젝용 세 종류가 있으며,
						ㄴ 이 세파일의 정보가 병합된다. 병합시 우선순위는 플젝용 > 유저전체용 > 시스템전체용 이다.
						ㄴ 시스템 전체용 : c:\scrapy\scrapy.cfg
						ㄴ 유저 전체용 위치 : ~/.scrapy.cfg
						ㄴ 플젝용 위치 : 각 scrapy플젝 루트폴더에 scrapy.cfg
					ㄴ 스크래피 플젝의 디렉토리 구조 )<button>더보기</button>
					<pre>
						ㄴ 디폴트 구조는 다음과 같다.
							scrapy.cfg
							myproject/
								__init__.py
								items.py
								middlewares.py
								pipelines.py
								settings.py
								spiders/
									__init__.py
									spider1.py
									spider2.py
									...
							ㄴ scrapy.cfg가 있는 위치가 '프로젝트 루트 디렉토리'이다.
						ㄴ scrapy.cfg
							ㄴ 플젝의 설정을 정의하는 파이선 모듈이름을 포함하고있다.
								ㄴ ex)
									[settings]
									default = myproject.settings
							ㄴ 여러 스크래피 플젝 사이에서 공유될 수 있다.
								ㄴ 이런 경우, 각 플젝마다 설정 모듈에 별칭을 부여해야한다.
									ㄴ ex)
										[settings]
										default = myproject1.settings
										project1 = myproject1.settings
										project2 = myproject2.settings
								ㄴ ?????scrapy command line은 디폴트로 'default'설정을 사용한다.
									ㄴ 'SCRAPY_PROJECT'환경변수를 변경하여 이를 변경할 수 있다.
										ㄴ ex) export SCRAPY_PROJECT=project2
											ㄴ 별칭 project2에 해당하는 myproject2.settings의 설정정보를 scrapy command line이 사용하게된다.
					</pre>
					ㄴ 사용법 )<button>더보기</button>
					<pre>
						ㄴ 명령어를 인자없이 입력하면 해당 명령어에 관한 도움말이 출력된다.
							ㄴ ex) scrapy 입력, scrapy crawl입력 등
							ㄴ 또는 '-h'옵션을 붙이면 더 자세한 도움말을 얻을 수 있다.
						ㄴ 스크래피 프로젝트 생성
							ㄴ scrapy startproject (*플젝이름*) [(*디렉토리*)]
							ㄴ 이후 해당 폴더로 이동하면, 해당 플젝에 대해 scrapy command를 사용할 수 있다.
						ㄴ 그 외 명령어들 )<button>더보기</button>
						<pre>
							ㄴ 명령어는 두가지로 구분할 수 있다. 플젝 안에서 실행시켜야하는 명령어('Project-only commands')와 그렇지 않아도 되는 명령어('Global command').
								ㄴ 후자의 경우, 플젝안에서 실행시키게되면 플젝의 설정이 override되기때문에 동작이 조금 다를 수 있다.
							ㄴ Global command)
								ㄴ startproject
								ㄴ genspider
								ㄴ settings
								ㄴ runspider
								ㄴ shell
								ㄴ fetch
								ㄴ view
								ㄴ version
							ㄴ Project-only commands)
								ㄴ crawl
								ㄴ check
								ㄴ list
								ㄴ edit
								ㄴ parse
								ㄴ bench
						</pre>
					</pre>
				</pre>
				ㅡ Spiders<button>더보기</button>
				<pre>
					ㄴ 어떻게 특정 사이트가 스크랩될지, 어떻게 크롤링을 수행할지, 어떻게 데이터를 추출할지를 정의하는 파이썬 클래스.
					ㄴ 동작과정 )
						ㄴ 초기 요청을 발생시키고, 해당 요청의 응답에 대한 콜백함수 지정.
							ㄴ 초기 요청은 'scrapy.http.Request'를 반환하는 'start_requests()'의 호출을 통해 얻어지고
							ㄴ 콜백함수는 parse()메소드가 된다. (디폴트로)
						ㄴ 콜백함수는 응답을 파싱하고 'item object' 또는 'scrapy.http.Request', 또는 이들의 iterable을 반환한다.
							ㄴ 반환하는 'Request'또한 각각의 콜백함수를 가지며, 응답에 대해 콜백함수가 호출된다.
							ㄴ scrapy의 'Selectors' 또는 BeautifulSoup, lxml등을 사용하여 응답을 파싱하고 scrapy의 'item'을 반환한다.
						ㄴ 반환된 scrapy의 'item'들은 db에저장되거나 파일로 씌여진다.
					ㄴ 목적에 따라 다양한 종류의 'Spider'가 존재한다.
					ㄴ scrapy.Spider <button>더보기</button>
					<pre>
						ㄴ scrapy.spiders.Spider 클래스<button>more</button>
						<pre>
							ㄴ 가장 기본형태의 스파이더이자, 다른 종류 또는 커스텀으로 정의한 모든 스파이더들이 상속해야하는 클래스.
							ㄴ ?????
							ㄴ 요소들 <button>more</button>
							<pre>
								ㄴ name )
									ㄴ 스파이더의 이름을 정의. 유일해야한다.
									ㄴ 필수값.
									ㄴ ?????
								ㄴ allowed_domains
								ㄴ start_urls
								ㄴ custom_settings
								ㄴ crawler
								ㄴ settings
								ㄴ logger
								ㄴ from_crawler()
								ㄴ start_requests()
									ㄴ 스파이더가 열리면, scrapy에 의해 처음 단 한번만 호출되는 메소드.
									ㄴ Request의 iterable을 반환해야한다.
									ㄴ override하지 않을시, 디폴트 구현체는 'start_urls'의 각 url에 대해 Request( (*url*), dont_filter=True)를 발생시킨다.
								ㄴ parse( (*response*) )
									ㄴ scrapy가 각 응답에 대해 디폴트 콜백으로 사용하는 메소드. 요청에 대해 콜백을 명시하지 않으면 이 디폴트 콜백이 사용된다.
									ㄴ 각 응답을 처리하거나 데이터를 추출하여 반환하거나 follow할 추가적인 url을 반환하는 역할이다.
									ㄴ 'scrapy.http.Request'의 iterable 또는 scrapy의 'item objects'를 반환해야한다. 둘다 반환할 수도 있다.
										ㄴ 이는 parse()뿐만 아니라, request에 대한 콜백함수 모두에 해당한다.
								ㄴ log()
								ㄴ closed()
							</pre>

						</pre>

					</pre>
					ㄴ Spider argument<button>more</button>
					<pre>
						ㄴ 스파이더는 호출시 인자를 받을 수 있다.
							인자는 스파이더 정의 안에서 자유롭게 사용할 수 있다.
							일반적으로 url을 설정하거나 크롤링할 url에 대한 조건을 설정하는데 사용된다.
						ㄴ 사용법 )
							ㄴ crawl명령어에 '-a'옵션을 주고 인자를 넘겨주면된다.
								ㄴ ex) scrapy crawl myspider -a category=electronics
							ㄴ 스파이더 클래스에서 __init__()을 통해 인자를 받을 수 있다
								* __init__() : 파이선에서 '인스턴스'생성시 호출되는 메소드.
								ㄴ ex)
									import scrapy

									class MySpider(scrapy.Spider):
										name = 'myspider'

										def __init__(self, category=None, *args, **kwargs):
											super(MySpider, self).__init__(*args, **kwargs)
											self.start_urls = [f'http://www.example.com/categories/{category}']
											# ...
								ㄴ __init__()을 정의하지 않으면 디폴트 __init__()은 인자들을 스파이더 인스턴스의 attribute로 만들어준다.
							ㄴ 인자는 'string'형태로만 들어온다. 필요하다면 직접 파싱해야한다.
					</pre>
					ㄴ Generic Spiders<button>more</button>
					<pre>
						ㄴ 자주사용될법한 스파이더 형태를 미리 정의해 둔것.
						ㄴ CrawlSpider<button>more</button>
						<pre>
							ㄴ scrapy.spiders.CrawlSpider 클래스
							ㄴ
						</pre>
						ㄴ XMLFeedSpider
						ㄴ CSVFeedSpider
						ㄴ SitemapSpider
					</pre>

				</pre>
				ㅡ Selectors<button>more</button>
				<pre>
					ㄴ BeautifulSoup, lxml 등과 같이 문서로부터 데이터를 추출해주는 기능을 하는 scrapy의 기능.
						ㄴ XPath나 css 표현식으로 문서의 특정 부분을 추출한다.
						ㄴ scrapy의 Selector들은 python의 'parsel'라이브러리의 wrapper이다.
							ㄴ 'parsel' 라이브러리란, XPath, Css선택자, 정규표현식을 이용해 html, xml문서로부터 데이터를 추출하고 제거하는 라이브러리.
								ㄴ 내부적으로 'lxml'을 사용한다고 한다.
							ㄴ 따라서 lxml과 매우 유사하다.
					ㄴ 사용법<button>more</button>
					<pre>
						ㄴ response객체의 'selector'속성을 통하여 'scrapy.selector.selector'에 접근할 수 있다.
							ㄴ 이 'selector'객체의 xpath(), css()를 통해 데이터를 추출한다.
								ㄴ ex) response.selector.xpath('//span/text()').get()
								ㄴ 이렇게 selector.xpath(), selector.css()와 같이 사용하는 경우가 아주많아서 shortcut을 제공한다.
									ㄴ ex) response.css(), response.xpath()
						ㄴ scrapy.http.Selector
							ㄴ response의 컨텐츠의 '선택된 부분'을 담고있는 wrapper이다.
								ㄴ xpath(), css()등으로 어느부분을 선택했느냐에 따라 내용물이 바뀐다.
								ㄴ 여기서 response란, 'HtmlResponse' 또는 'XmlResponse'객체이다.
							ㄴ selector객체는 'scrapy.http.TextResponse'객체나 문자열로된 마크업을 text 매개변수로 받아 생성된다.
								ㄴ ex)
									body = '< html>< body>< span>good< /span>< /body>< /html>'
									Selector(text=body).xpath('//span/text()').get()	//Selector객체를 body를 인자로 넘기며 생성하고있다.
								ㄴ ex)
									response = HtmlResponse(url='http://example.com', body=body)
									Selector(response=response).xpath('//span/text()').get()	//HtmlResponse객체를 넘기며 Selector객체를 생성하고있다.
																								//HtmlResponse는 TextResponse의 subclass이다.
								ㄴ Selector객체는 입력받은 데이터의 타입에따라 가장 적절한 파싱규칙을 선택한다(HTML인지 XML인지)
							ㄴ 요소들<button>more</button>
							<pre>
								ㄴ xpath( (*query*), (*namespaces=None*), )
									ㄴ XPath문법에 따라 (*query*)에 매칭되는 노드들을 찾고 'SelectorList'로 반환.
									ㄴ ~~~~~
								ㄴ css( (*query*) )
									ㄴ css selector를 나타내는 문자열을 인자로 받아 매칭되는 노드들을 찾고 'SelectorList'로 반환.
									ㄴ 내부적으로 입력받은 css selector를 xpath 쿼리로 변역하여('cssselect'라이브러리 이용) xpath()을 호출하여 동작한다.
								ㄴ get()
									ㄴ Selector가 담고있는 내용을 직렬화하여 unicode 문자열로 반환한다.
									ㄴ get()은 단 하나의 결과만 반환, getall()은 'SelectorList'의 메소드로, 배열형태로 내용을 모두 반환.
									ㄴ 매칭되는게 없으면 'None'반환. 메소드에 'default'란 키값으로 인자 넘길시 'None'대신 해당 인자값이 디폴트로 반환.
								ㄴ attrib 속성 : 요소에 대한 속성 'dict'를 반환.
								ㄴ re( (*정규표현식*), (*replace_entities=True*) )
									ㄴ
							</pre>
						ㄴ Selector 사용법
							ㄴ get(), getall()
								ㄴ Selector가 담고있는 내용을 직렬화하여 unicode 문자열로 반환한다.
								ㄴ get()은 단 하나의 결과만 반환, getall()은 'SelectorList'의 메소드로, 배열형태로 내용을 모두 반환.
								ㄴ 매칭되는게 없으면 'None'반환. 메소드에 'default'란 키값으로 인자 넘길시 'None'대신 해당 인자값이 디폴트로 반환.

							ㄴ css()
								ㄴ
								ㄴ 'SelectorList'객체를 반환.
							ㄴ attrib 속성
								ㄴ Selector에 해당하는 요소의 속성을 선택할 수 있다.
						ㄴ css 선택자의 확장
							ㄴ 요소의 text node를 선택하려면, '::text'를 사용하면된다.
								ㄴ ex) response.css('title::text').get()
							ㄴ 요소의 속성값을 선택하려면, '::attr( (*name*) )'을 사용하면된다.
								ㄴ ex) response.css('a::attr(href)'.getall()
						ㄴ css(), xpath()가 SelectorList를 반환하므로, 이 반환 Selector들에 대해 css(),xpath()를 체인형태로 계속 호출할 수 있다.
						ㄴ 속성 선택
							ㄴ xpath문법을 통해 선택
								ㄴ ex) response.xpath("//a/@href").getall()
						ㄴ 정규표현식을 통한 선택
							ㄴ re()
						ㄴ extract(), extract_first()
						ㄴ ~~~~~
					</pre>

				</pre>
				ㅡ Items<button>more</button>
				<pre>
					ㄴ 스크래핑을 통해 추출한 데이터를 반환하는 형태.
						ㄴ key-value쌍을 정의하는 파이선 객체이다.
						ㄴ 데이터 타입이 여러개이어도 상관없다.
						ㄴ 지극히 개인적인 비유를 하자면, scrapy에서 스크랩한 데이터를 저장하는 용도로 쓰이는 클래스. scrapy에서 지원하는
							여러 기능들을 사용할 수 있다.
						ㄴ ????? item type? item클래스가 있는건 알겠는데, item type중에 하나로 item 클래스? 그럼 item이 정확히 뭔가?
					ㄴ ????? 이후 Item Loaders, Item Pipeline, Item exporter 등에서 어떻게 쓰이는지를 봐야 정확하게 이해가 될 듯 하다.
					ㄴ scrapy.item.Item 클래스
						ㄴ ????? 파이썬의 'dict'와 유사한 메소드들과 여기에 scrapy에서 사용될 추가적인 기능들을 제공하는 scrapy의 내장 클래스..???
							ㄴ 'dict'와 유사하게 데이터 입력, 추출, 객체 생성 등이 가능
								ㄴ ex) product['last_updated'] = 'today'
										product['last_updated'] //'today'출력
						ㄴ 파이썬의 'dict'의 메소드들을 동일하게 가지고 있다. (__init__()을 포함하여)
						ㄴ 'Item exporter'는 디폴트로 모든 필드를 export한다
						ㄴ ????? 필드 메타데이터를 정의할 수 있다
						ㄴ ?????
						ㄴ 추가적인 메소드
							ㄴ copy()
							ㄴ deepcopy()
							ㄴ fields : 선언된 모든 'field'들을 담고있는 'dict'. 키값은 필드명이고, 값은 'Field'객체이다.
					ㄴ 사용법 )
						ㄴ Item객체의 subclass를 정의하여 사용한다.
							ㄴ ex)
								import scrapy

								class Product(scrapy.Item):
									name = scrapy.Field()
									price = scrapy.Field()
									stock = scrapy.Field()
									tags = scrapy.Field()
									last_updated = scrapy.Field(serializer=str)
						ㄴ Field 선언
							ㄴ scrapy.item.Field 클래스
								ㄴ 파이썬 dict클래스에 별칭만 달리한 것. 즉, 그냥 dict이다.
							ㄴ Field객체는 각 필드에 대한 메타데이터를 명시하는데 사용된다.
								ㄴ 위의 예에서 'last_updated'에 Field()를 생성하면서 넘겨준 인자들이 메타데이터로 쓰이는식.
							ㄴ 사용된 Field객체들은 Item클래스의 attribute로 존재하는게 아닌, Item클래스의 'fields' attribute안에 들어있다.
						ㄴ Item객체 생성
							ㄴ ex) product = Product(name='aaa', price=1000)
						ㄴ ex) product['name']
						ㄴ 복사 )
							ㄴ 파이썬 객체의 복사와 동일하다. copy(), deepcopy()
						ㄴ Item으로부터 dict생성 : dict(product)
						ㄴ dict로부터 item생성 : Product({'name': 'Laptop PC', 'price': 1500})
						ㄴ Item subclass 확장 )
							ㄴ 기존 subclass를 상속하는 또 다른 클래스를 정의하여 Item의확장이 가능하다
							ㄴ ?????
						ㄴ 'item pipeline'이나 'spider middleware'와 같이 Item을 받는 부분에서, item이 어떤 type이어도 item을
							받을 수 있게 하기 위해 'itemadapter.ItemAdapter'클래스나 'itemadapter.is_item()'을 사용하는것이 권장된다.
				</pre>
				ㅡ Item Loaders<button>more</button>
				<pre>
					ㄴ 스크랩된 'items'을 저장하는 편리한 기능들을 제공해주는 기능.
						ㄴ 그냥 item을 직접 저장할 수도 있지만 추출된 데이터의 파싱을 자동화 하는 등의 기능 제공.
						ㄴ 즉, item이 스크랩된 데이터의 '컨테이너'라 하면, 'item loader'는 이 '컨테이너'들을 잘 쌓아올리는 메커니즘을 제공.
					ㄴ ~~~~~
				</pre>
				ㅡ Scrapy Shell<button>more</button>
				<pre>
					ㄴ scrapy에서 사용할 몇가지 기능들이 추가된 파이썬 cnosole.
						ㄴ 파이썬 대화형 쉘처럼 scrapy를 shell로 빠르게 사용할 수 있는 기능.
						ㄴ 실제로 파이썬 대화형 인터프리터에서 동작한다.
						ㄴ 디버그, 테스트에 많이 사용된다.
					ㄴ ~~~~~
				</pre>
				ㅡ Item Pipeline<button>more</button>
				<pre>
					ㄴ item이 스크랩된 뒤, 이 item들이 어떤 컴포넌트들에 의해 연속적으로 처리되기 위해 보내지는 곳.
						ㄴ 각 컴포넌트를 'item pipeline component'라 부르고, 이는 몇몇 메소드들을 구현하는 일반 파이선 클래스이다.
							ㄴ 몇몇 메소드란 다음과 같다.
								ㄴ process_item(self, (*item*), (*spider*))
									ㄴ 모든 컴포넌트들에서 호출되는 메소드.
									ㄴ Item객체 또는 'Deferred'객체?????를 반환하거나ㅓ 'DropItem'예외를 raise해야한다.
									ㄴ DropItem발생시 해당 Item은 더이상 파이프라인에서 진행되지 않는다.
								ㄴ ~~~~~
						ㄴ item을 받아 특정 로직을 실행하고, pipeline을 계속 진행해야할지 말지 등을 결정한다.
					ㄴ 일반적인 쓰임새
						ㄴ ????? html데이터 cleaning
						ㄴ 스크랩트된 데이터의 유효성 검증
						ㄴ 중복검사
						ㄴ 스크랩트된 item의 db저장
					ㄴ ~~~~~
					ㄴ 예제 <button>more</button>
					<pre>
						ㄴ ~~~~~
						ㄴ MongoDB에 item 쓰기<button>more</button>
						<pre>
							ㄴ 'pymongo'를 이용하여 'item'을 MongoDB에 입력하는 예제이다.
							ㄴ MongoDB의 주소, db이름 등의 설정정보는 scrapy설정에서 설정한다.
							ㄴ pipeline의 item처리 부분에서 'pymongo'에서 얻은 MongoDB 객체의 메소드를 사용하여 db에 넣어주면 된다.
							ㄴ ex)<button>more</button>
							<pre>
								import pymongo
								from itemadapter import ItemAdapter

								class MongoPipeline:

									collection_name = 'scrapy_items'

									def __init__(self, mongo_uri, mongo_db):
										self.mongo_uri = mongo_uri
										self.mongo_db = mongo_db

									@classmethod
									def from_crawler(cls, crawler):
										return cls(
											mongo_uri=crawler.settings.get('MONGO_URI'),
											mongo_db=crawler.settings.get('MONGO_DATABASE', 'items')
										)

									def open_spider(self, spider):
										self.client = pymongo.MongoClient(self.mongo_uri)
										self.db = self.client[self.mongo_db]

									def close_spider(self, spider):
										self.client.close()

									def process_item(self, item, spider):
										self.db[self.collection_name].insert_one(ItemAdapter(item).asdict())
										return item
							</pre>
						</pre>
					</pre>
				</pre>
				ㅡ Feed exports<button>more</button>
				<pre>
					ㄴ scrapy에서 스크랩한 item을 export하는 기능을 말함.
						ㄴ 여러 직렬화 형태를 이용하여 데이터를 저장할 수 있게 해준다
					ㄴ 직렬화 format
						ㄴ 데이터 직렬화를 위해 'item exporter'를 사용한다.
					ㄴ ~~~~~
				</pre>
				ㅡ ~~~~~
				ㅡ 아키텍쳐<button>more</button>
				<pre>
					<img src="image/scrapy_architecture_02.png" height="940"/>
					ㄴ 흐름 )
						ㄴ '엔진'에 의해 전체적인 흐름이 제어된다.
						ㄴ 'spider'로부터 엔진이 초기 request를 받아온다.
							ㄴ 엔진과 'spider'의 데이터 교환은 'spider middleware'를 통해 이루어 진다.
						ㄴ '스케줄러'?????
						ㄴ 엔진이 요청을 'downloader'엑 주면 'downloader'는 요청을 보내고 응답을 받아와 엔진에게 넘겨준다.
							ㄴ 'downloader middleware'를 통하여 엔진과 데이터를 주고 받는다.
						ㄴ 엔진은 이 응답을 'spider'에게 넘겨준다.
						ㄴ 스파이더는 원하는 로직을 처리하고 'Item'또는 또 다른 요청을 반환하고 엔진이 이를 받는다.
						ㄴ 엔진이 'Item'은 'item pipeline'으로 넘기고 또 다른 요청은 다시 '스케줄러'에게 넘겨준다.
						ㄴ '스케줄러'?????
						ㄴ 이를 반복.
					ㄴ ~~~~~
				</pre>
				ㅡ 스케줄러<button>more</button>
				<pre>
					ㄴ
				</pre>
				ㅡ 스크래핑을 위한 브라우저 개발자 도구 사용에 관해<button>more</button>
				<pre>
					ㄴ 개발자 도구는 실시간 DOM을 보여준다.
						ㄴ 즉, 처음 받아온 html이 아닌, 어떤 js코드가 실행되어 수정되었을 수도 있는 페이지를 보여준다.
					ㄴ Scrapy는 이런 수정된 페이지가 아닌, 처음 받아온 html을 사용한다.
					ㄴ 하여, 다음과 같은 것들을 유의해야 한다
						ㄴ 스크래피를 사용하여 DOM에 접근할 때는 js기능을 꺼두는 게 좋다.
						ㄴ ????? full XPath path를 사용하지 마라??
						ㄴ ????? XPath 표현식 안에 'tbody' 태그를 포함시키지 마라.
					ㄴ ~~~~~
				</pre>
				ㅡ 동적 웹 페이지 스크래핑<button>more</button>
				<pre>
					ㄴ 웹 브라우저 상에서는 보이는 데이터들이 스크래피를 이용해 받으면 없는 경우들을 다루는 부분.
						ㄴ 간단하게 js ajax 등을 사용하여 데이터 받아와 dom업데이트로 보여주거나 하는 경우를 말한다.
							이런 경우, 스크래피를 사용하여 받아온 응답 html 안에는 ajax으로 요청해서 받아오게되는 데이터들은 당연히 없다.
					ㄴ 방법은 크게 두 가지를 소개하고 있다.
						ㄴ 해당 데이터가 어디서 오는지를 확인하고 거기서 데이터를 추출하는 방법. (우선적으로 사용하기를 추천한다함)
						ㄴ 'pre-rendering js'를 이용.
					ㄴ 데이터가 어디서 오는지 찾기 )<button>more</button>
					<pre>
						ㄴ 찾으려는 데이터가 text형태가 아니면, 브라우저의 네트워크 탭을 열어 해당 데이터를 받아오는 요청을 찾고 '요청을 복제'하라.
						ㄴ 찾으려는 데이터가 text형태인 경우, 해당 데이터가 js코드 안에 있거나 다른 리소스로부터 온 것일 수 있다.
							ㄴ 이런 경우, 'wgrep'등을 이용하여 해당 데이터가 오는 리소스를 찾고,
								ㄴ 해당 데이터가 처음 ?????
									ㄴ '페이지의 소스 코드를 조사'하여라.
								ㄴ 해당 데이터가 다른 url에서 오는 경우, '요청을 복제'하라.
					</pre>
					ㄴ 'Pre-rending js'
						ㄴ

					ㄴ 페이지의 소스코드 조사하기 )
						ㄴ 데이터가 js 코드 안에 있는 경우,
							ㄴ js code 파싱 )
								ㄴ 찾으려는 데이터가 js 코드로 하드 코딩되어 있다면, js코드를 읽어서 데이터를 추출해야 한다.
								ㄴ js code를 가져오기 위해선..
									ㄴ js파일이 따로 존재할 경우 해당 파일을 요청하여 response.text로 가져오면 된다.
									ㄴ html파일의 < script>태그 안에 들어있다면, scrapy의 'selector'로 < script>태그의 text정보를 가져올 수 있다.
								ㄴ js 코드에서 데이터 추출하기
									ㄴ 정규식 검색 이용
									ㄴ chompjs 이용
									ㄴ js2xml을 이용하여 js 코드를 xml문서로 변환후, 'selector'를 이용해 추출.
						ㄴ 아닌경우
							ㄴ curl, wget 등의 HTTP client를 이용하여 요청을 보내보고, 응답에 데이터가 있는지 확인 해 본다.
								있다면, 이 HTTP client의 요청과 유사하도록 scrapy.http.Request를 만들어 다시 요청한다.
						ㄴ ~~~~~
					ㄴ request 복사 )
						ㄴ 스크래핑 도중에 특정한 요청을 똑같이 복사하여 보내야 하는 경우가 있다.
						ㄴ 웹 브라우저의 네트워크 탭을 이용하여 해당 요청을 보고 스크래피를 이용하여 똑같이 만들면 된다.
						ㄴ 일반적으로는 요청의 메소드와 url을 동일하게하여 'scrapy.http.Request'를 yield하는 것으로 충분하지만,
							헤더나 body, parameter정보가 필요한 경우도 있다.
							ㄴ 이런 경우, scrapy.http.Request의 from_curl()을 사용하면 된다.
							ㄴ 인자로 curl command형식의 문자열을 받아 이 정보와 일치하는 Request를 반환해 주는 메소드이다.
							ㄴ 해당 요청에 대한 curl command는 대부분의 브라우저 네트워크 탭에서 해당 요청을 curl로 변환해주는 기능을 제공하니
								이를 이용하면 된다.
								ㄴ 크롬의 경우, 네트워크 탭에서 요청을 우클릭하면 'curl로 변환하여 복사'기능이 있다.
					ㄴ response 형태가 다른 경우 데이터 추출하기 )
						ㄴ html, xml이면 'selector'를 이용하면 된다.
						ㄴ json이면, 파이썬 표준 라이브러리인 'json'의 json.loads()를 이용하여 추출하라.
							ㄴ ex) data = json.loads(response.text)
						ㄴ js이면 위의 'js code 파싱' 부분처럼 하면 된다.
						ㄴ css이면, 정규식을 이용하여 추출.
						ㄴ ????? 이미지, pdf 등이면, 'response'의 'body'속성으로 바이트 코드로 읽어들인 다음, 'OCR 솔루션'?????을 이용하라.
						ㄴ sbg나 sbg를 포함한 html이면 'selector'로 추출이 가능하다. svg가 xml기반이라서 이라 한다.
					ㄴ 페이지가 추가적인 요청으로 데이터를 가져온다면 그 요청을 복사하여 원하는 데이터를 추출하는게 우선.
						근데 요청을 복사하기가 어렵거나 요청으로부터 얻을 수 없는 데이터인 경우 'Splash'를 사용하면 된다.
						ㄴ 요청에 대한 페이지를 로드하고 이를
						ㄴ js-rendering service이고 'scrapy-splash'를 통하여 사용할 수 있다.
						ㄴ 페이지의 dom을 html으로 반환한다고함.
					ㄴ headless browser 사용하기
						ㄴ 이미 작성된 스크립트가 아닌 파이선코드로 직접 dom과 상호작용하고자 한다면 'headles browser'를 이용하라함.
						* headless browser
							ㅡ 그래픽으로 된 유저 인터페이스가 없는 웹 브라우저.
							ㅡ 웹 브라우저와 비슷한 환경에서????? command-line 인터페이스를 통해 웹페이지 자동화 컨트롤 기능을 제공.
							ㅡ ?????
						ㄴ scrapy에서 headless browser를 사용하는 가장 쉬운 방법은 'selenium'을 이용한느 것이라 한다.

					ㄴ 무제 )

				</pre>
				ㅡ
				ㅡ 무제 )<button>more</button>
				<pre>
					ㄴ 웹 크롤링용 프레임워크
					ㄴ XPath 사용가능? (Beautiful Soup와 다르게)
					ㄴ spider를 정의한 파이선파일을 만들고, scrapy runspider (*파일명*) 식으로 scrapy프레임워크를 실행시키면
						scrapy가 spider정의를 찾아서 크롤러엔진을 통해 이 정의한 spider를 실행시킨다??
					ㄴ 크롤러는 url을 호출하는 것으로 시작, 응답을 parse메소드로 전달하며 parse()호출
					ㄴ 요청이 스케줄되고 비동기적으로 처리될 수 있다.
					ㄴ 그 외에 많은 기능들 존재
						ㄴ css selector, XPath표현식, 정규식을 통한 html, xml로부터 데이터 추출
						ㄴ 상호작용 shell 기능. css,xpath표현식이나 스파이더 테스트에 용이
						ㄴ json,csv,xml등의 파일 export 등등. ('Feed exports')
						ㄴ 인코딩 관련 기능
						ㄴ 확장기능?????
						ㄴ ?????
					ㄴ beatifulSoup처럼 단순히 html문서만을 가지고 동작하여 비동기요청으로 인한 데이터와 요소에 접근 못하는 문제는
						selenium을 사용하거나 scrapy안에 관련 기능이 있을 수 있는지 확인해봐야한다. scrapy동작 원리도 확인해 보면
						답이 나올 수도 있겠다.
						ㄴ https://stackoverflow.com/questions/8550114/can-scrapy-be-used-to-scrape-dynamic-content-from-websites-that-are-using-ajax?rq=1
						ㄴ api에 대고 호출하여 데이터를 가져오거나 selenium을 이용하란 답변들이 보인다.
					ㄴ scrapy 프로젝트 생성 )
						ㄴ 원하는 디렉토리로 이동하여 다음 명령어 입력
							scrapy startproject (*플젝이름*)
						ㄴ 대략 다음과 같은 구성으로 프로젝트폴더가 생성된다
							ㄴ scrapy.cfg 파일
							ㄴ (*플젝이름*) 폴더
								ㄴ 안에 다음과 같은 파일들
								ㄴ __init__.py
								ㄴ items.py
								ㄴ middlewares.py
								ㄴ pipelines.py
								ㄴ settings.py
								ㄴ spiders폴더
									ㄴ 하위에 __init__.py파일과 정의한 '스파이더'파일들이 저장됨.
					ㄴ scarpy에서 'spider'란 용어는 파이썬 클래스를 말하며, Scrapy가 웹사이트로부터 정보를 스크랩하는데 사용하는 클래스이고 개발자가 직접 정의하는 클래스이다.
						ㄴ 'Spider'라는 클래스를 상속하여 만든다.
						ㄴ 정해진 초기 조건을 만족시켜서 정의해야하며, 어떻게 링크를 타고갈건지, 다운받은 데이터들은 어떻게 파싱할건지 등도 설정가능하다.
							ㄴ 초기조건? 그냥 클래스에 정의해야할 속성이나 메소드를 말한다.
								ㄴ name : 정의해야하는 속성. 스파이더의 식별이름으로, 프로젝트에서 유일해야한다.
								ㄴ start_requests() : 정의해야하는 메소드. 'Requests'의 'iterable'을 반환해야한다. (리스트를 반환하든, generator를 만들든)
														스파이더가 크롤링을 시작할 요청목록을 반환하는것이다. 이 초기 요청들로부터 서브 요청들이 지속적으로
														생성되며 크롤링을 하게된다.
								ㄴ parse() : 정의해야하는 메소드. 각 요청이 반환하는 데이터들을 다루는데 쓰이려고 호출되는 메소드.
												'TextResponse'클래스의 인스턴스를 인자로받으며, 이는 응답페이지의 내용과 여러 유용한 메소드들을 포함하고있다.
												일반적으로 응답으로부터 데이터를 dict형태로 추출하고 새로운 url을 찾아 이에대한 새 request를 만드는 일을 한다.
						ㄴ ex)<buttoN>더보기</buttoN>
						<pre>
							import scrapy

							class QuotesSpider(scrapy.Spider):
								name = "quotes"

								def start_requests(self):
									urls = [
										'http://quotes.toscrape.com/page/1/',
										'http://quotes.toscrape.com/page/2/',
									]
									for url in urls:
										yield scrapy.Request(url=url, callback=self.parse)

								def parse(self, response):
									page = response.url.split("/")[-2]
									filename = f'quotes-{page}.html'
									with open(filename, 'wb') as f:
										f.write(response.body)
									self.log(f'Saved file {filename}')
						</pre>
						ㄴ start_requests()대신 클래스에 'start_urls'속성을 정의하여도 된다.
							ㄴ ex)
								 start_urls = [
									'http://quotes.toscrape.com/page/1/',
									'http://quotes.toscrape.com/page/2/',
								]
							ㄴ 디폴트로 start_requests()가 생성되고 각 요청에 대해 parse()가 호출된다.
					ㄴ 스파이더 실행방법
						ㄴ 프로젝트의 최상위 폴더로이동하여 다음 명령어 실행
							scrapy crawl (*스파이더이름*)
					ㄴ 실행 과정 )
						ㄴ Scrapy가 start_requests()로부터 'scrapy.Request'객체를 받아 이를 스케줄링.
						ㄴ 각 요청에 대해 응답을 받고 이를 'Response'객체로 객체화.
						ㄴ 각 요청에 맞는 콜백함수를 호출( 디폴트 콜백함수는 parse()이다. )
					ㄴ 데이터 추출 )
						ㄴ Scrapy shell )
							ㄴ 파이썬 대화형 쉘처럼 scrapy를 shell로 빠르게 사용할 수 있는 기능.
							ㄴ 실제로 파이썬 대화형 인터프리터에서 동작한다.
							ㄴ ex) scrapy shell (*url*)
								ㄴ url에 해당하는 요청을 보내고 response를 받은 상태로 파이썬 대화형 인터프리터를 실행시키는듯.
								ㄴ 켜진다음 response 이름을 입력하면 'scrapy.http.response.Response'객체가 들어있는걸 확인할 수 있다.
						ㄴ (*response*).css()
							ㄴ 인자로 css selector와 같은 문자열을 받아 이 selector와 매칭되는 'scrapy.selector.Selector'의 리스트형인 'scrapy.selector.SelectorList'를 반환한다.
							ㄴ 'Selector'로부터 html요소를 나타내는 파이선문자열을 얻을 수 있다. get()이나 'SelectorList'의 getall() 등
						ㄴ re()메소드를 통해 정규표현식으로 데이터 추출이 가능하다.
					ㄴ XPath )
						ㄴ css를 통한 데이터 추출 말고, scrapy는 'XPath 표현식'을 통한 selector도 지원한다.
						ㄴ ????? 나중에 필요하면 공부. 일단은 css selector로도 할수 있으니까.
					ㄴ 스크랩한 데이터 저장 )
						ㄴ scrapy의 'Feed exports'사용
						ㄴ ex) scrapy crawl quotes -O quotes.json
							ㄴ 스파이더를 실행시켜 요청에 대한 콜백함수에서 반환하는 데이터를 json형태로 저장.
							ㄴ -O 옵션은 파일이 이미존재하면 덮어씌움. -o옵션은 끝에 이어붙임.
								ㄴ 근데 json파일에 -o옵션으로 json파일을이어붙이면, json파일 내용물이 json으로서 유효하지않게됨.
								ㄴ json파일을 이어붙이려면, 'JSON Lines'파일형식을 이용하면된다.
									ㄴ ex) scrapy crawl quotes -o quotes.jl
								ㄴ 데이터량이 많을때는 JSON Lines만으로는 안되고 'Item Pipeline'을 이용하라고함.
									ㄴ
					ㄴ follwing link
						ㄴ ~~~~~
					ㄴ ~~~~~

					ㄴ 오류 기록 )
						ㄴ conda install -c conda-forge scrpay 설치시 파이선 버전이 맞지 않는다고 오류발생.
							ㄴ 해결) 가상환경을 낮은버전으로 새로만들어 설치.
				</pre>
			</pre>

			ㅡ 스크래핑 차단 방지<button>more</button>
			<pre>
				ㄴ (*대상 사이트 url*)/robots.txt 로 접속하면 해당 사이트에서 어느 부분이 크롤링이 허용되고 안되는지 명시되어 있다.
					ㄴ 강제력은 없지만 불법과 합법의 기준?이 된다고 한다???
					ㄴ 형식 )
						ㄴ ex)
							User-agent: *
							Allow: /
							Disallow: /search.php
						ㄴ User-agent는 대상 크롤러, 즉, 봇이름을 말하는 듯하다.
						ㄴ 그 봇에 대해 Allow는 크롤링 허용 url을 말하고, Disallow는 금지하는 url.
				ㄴ 요청시 헤더의 'User-Agent'를 브라우저로 만들어서 보내야 한다.
					ㄴ 'python-urllib'같은 걸로 보내면 바로 알아차린다.
				ㄴ 데이터 긁는 속도 조절
					ㄴ 사람이 사용하는 것보다 너무 빠른 속도로 요청을 하면 봇으로 인식하고 차단당함.
					ㄴ 중간중간에 랜덤한 텀을 두어서 방지.
				ㄴ IP 로테이션
					ㄴ 동일한 ip로 계속 접속하면 걸릴 위험이 있다.
					ㄴ ????? 'Tor'라는 암호화 네트워크???를 이용하여 ip확인을 못하도록.
					ㄴ 또는 aws ec2를 여러개 두어서 스크래핑 하는 방법도 ㅣㅇㅆ다함.
			</pre>
			ㅡ 스크래핑 실무<button>more</button>
			<pre>
				ㄴ html구조에서 클래스 명이 랜덤으로 바뀌는 경우가 있음.
			</pre>

            ㅇ 모니터링
                ㅡ 방법 목록 )
                    ㄴ (scrapy 사용시) scrapy의 logs, stat 이용
                    ㄴ (scrapy 사용시) 'ScrapeOps' 이용
                        ㄴ 스크래핑 모니터링 솔루션? 전용 대시보드에서 모니터링 화면을 보여주고, 여러 기능 제공
                        ㄴ 유료?
                    ㄴ (scarpy 사용시) 'Spidermon' 이용
                        ㄴ scrapy 전용 오픈소스 모니터링 모듈
                        ㄴ 대시보드가 따로 없음.
                        ㄴ 여러 기능들을 제공하며, 직접 구현 필요.
                    ㄴ 일반적인 모니터링 및 로깅 툴 사용
                        ㄴ 시중에 나와 있는 일반적인 로깅, 모니터링 툴로 직접 구현.

		</pre>
        결제???<button>more</button>
        <pre>
            ㅡ PG사 (payment gateway)
                ㄴ ??? 카드 단말기에서 여러 카드사들과 연결해서 결제를 해주듯이,
                    온라인 상에서 여러 카드사들과 연결하여 결제를 할 수 있게 해주는 중간 매개 서비스?
                ㄴ ex ) KG이니시스, 케이에스넷, lg u+, KCP, 나이스정보통신, KICC, ...
                    온라인에서 결제할 때 뜨는 창들.
                ㄴ 간편결제도 지원해주는 추세.
            ㅡ VAN사

            ㅡ <img src="image/결제_서비스_프로세스.png"/>
                ㄴ 중간단계로 카드 정보를 전달하지 않기 위해, 카드사와 고객사이에서 먼저 카드 유효성 검증을 진행,
                    완료 후, 이 카드 인증 정보를 가지고 결제를 진행하는 방식.
                ㄴ 카드 유효성 검증을 하면 카드사에서 1회성 결제 인증 정보를 준다함.
                ㄴ 카드사와 고객 사이에 직접적인 통신을 통해 카드 유효성 검증을 하기 위해 카드사에선 특정한 프로그램 설치를
                    요구한다함. (결제할때 깔으라하는 여러 프로그램들)
                ㄴ ???모바일에 한하여, 카드사들이 이러한 카드 인증 정보를 저장하고 있는 앱을 만들어 매번 유효성 검증이 필요 없이
                    결제를 할 수 있도록함?

            ㅡ app to app 결제
                ㄴ
        </pre>

	</pre>
	<br>기타 지식<button>더보기</button>
	<pre>
		XPath<button>more</button>
		<pre>
			ㅡ XML Path Language
			ㅡ XML문서의 '노드'들에 대한 쿼리 언어이다.
			ㅡ 파일 경로 같은 '경로식'을 이용하여 노드들을 찾는다.
			ㅡ 축약형 문법과 확장형 문법이 있다.
			ㅡ 문법 )
				ㄴ ex) child::A/descendant-or-self::node()/child::B/child::node()[position()=1]
				ㄴ 축(axis), node test, predicate 로 구성된다.
				ㄴ 축)
					ㄴ 탐색을 어느 방향으로 갈지 결정하는 부분.
					ㄴ 위 예에서 'child', 'descendant-or-self'드으이 부분이 이에 해당.
					<img src="image/XPath_axis.png" height="472"/>
					ㄴ 종류 )
						self :	현재 노드를 선택함.
						attribute : 	현재 노드의 속성 노드를 모두 선택함.
						namespace :	현재 노드의 네임스페이스 노드를 모두 선택함.
						child :	현재 노드의 자식 노드를 모두 선택함.
						descendant :	현재 노드의 자손 노드를 모두 선택함.
						descendant-or-self :	현재 노드와 현재 노드의 자손 노드를 모두 선택함.
						following :	XML 문서에서 현재 노드의 종료 태그 이후에 등장하는 모든 노드를 선택함.
						following-sibling :	현재 노드 이후에 위치하는 형제 노드를 모두 선택함.
						parent :	현재 노드의 부모 노드를 선택함.
						ancestor :	현재 노드의 조상 노드를 모두 선택함.
						ancestor-or-self :	현재 노드와 현재 노드의 조상 노드를 모두 선택함.
						preceding : XML 문서에서 현재 노드 이전에 등장하는 모든 노드를 선택함.
 									(조상 노드, 속성 노드, 네임스페이스 노드는 제외함)
						preceding-sibling :	현재 노드 이전에 위치하는 형제 노드를 모두 선택함.
				ㄴ node test )
					ㄴ 표현식에서 특정 노드를 선택하는 부분.
					ㄴ 위의 예에서 '::A', '::node()'등의 부분에 해당.
				ㄴ predicate )
					ㄴ 선택된 노드들을 특정 조건으로 필터링하는데 쓰이는 부분
					ㄴ 위의 예에서 '[position()=1]'에 해당한다.
					ㄴ []안에 조건들이 들어감.
		</pre>

		xml<button>더보기</button>
		<pre>
			* 마크업 언어  : 태그 등을 이용해 문서나 데이터 구조를 명기하는 언어의 일종 (ex) html, xml)
			* 메타 언어 : 대상을 직접 서술하는 언어 그 자체를 언급하는 언어
			* SGML : 문서용 마크업 언어를 정의하기 위한 메타언어. html등을 만들었다.
			* DTD(Document Type Definition) : 해당 문서가 어떤 규칙을 따르는지 나타내는것, 따르는 규칙. '유효성 검사'란것에 쓰임.
			* xml(Extensible Markup Language) : SGML의 확장형으로 다른 언어를 만드는데 쓰려고 만든 다목적 마크업 언어이자 메타언어.

			ㅇ xml이란?
				ㅡ 데이터를 저장하고 전달하기 위한목적으로 만들어졌다. 근데 현재 아주 다양하게 쓰이고 있어 그 목적을 특정하기는 의미가 없는듯하다.
				ㅡ 특징)
					ㄴ 다른 마크업 언어를 만드는데 사용되는 다목적 마크업언어(메타언어)
			       	ㄴ 다른 시스템끼리의 데이터 교환을 쉽게
			       	ㄴ 사용자 저으이 태그가 가능하여 확장성이 좋다
					ㄴ 데이터를 보여주는 거이 아닌 전달하는ㄷ데에 쓰인다
					ㄴ 텍스트 데이터 형식의 파일로, 모든내용은 유니코드로 이루어져잇다

			ㅇ 문법)
				<img src="image/xml구조.png" style="height:400px; width:auto;">
				ㄴ 그림과같은 전체적 구조를 가진다.
				ㄴ 문서 맨처음에 < xml>을 통해 xml문서임을 선언해주어야한다.
					ㄴ속성)
						version : xml문서의 버전을말함
						encoding : 문서의 문자셋을 명시
						standalone : 문서가 외부 DTD와 같은 외부 소스데이터에 의존하고있는지 xml파서에게 알려주는 부분. (기본값은 no)
				ㄴ 모든 태그에는 종료태그가 포함되어야 한다.(홀로쓰이는 태그면 끝에 '/'를
				    	붙여주면 된다.
				ㄴ 대소문자를 구분한다.
				ㄴ 태그를 여닫는 순서가 반드시 지켜져야한다
				ㄴ 띄어쓰기를 인식하므로 주의한다
				ㄴ '<', '>'등등 문서에서특별한 기능으로 사용하는 기호를 예약되어있는 기호라고하며, 이들을 문서상에서 표현하기위해 따로 정해둔 문자셋이있고 이를 '엔터티'라고함
					ㄴ < :  & l t ;
					ㄴ > :  & g t ;
					ㄴ & :  & a m p ;
					ㄴ " :  & q u o t ;
					ㄴ ' :  & a p o s ;
				ㄴ  주석은 < !--- ---- >으로 표현하며, 하이픈(-)의 개수는 상관없다. 단, 주석 내용부분에 두개의 연속한 하이픈은 오류가생긴다.
				ㄴ 문서 선언부다음에 맨처음나오는 태그를 루트요소라고하며 루트요소는 단하나이며, 모든 요소는 이 루트요소안에 포함되어야한다.
				ㄴ 요소의 이름은 영문자,숫자,하이픈(-), 언서스코어(_),점(.)으로만이루어져야하며, 영문자나 언더스코어로 시작하여야한다. 예약어인 xml,XML,Xml은 사용x.
				ㄴ 속성은  <-태그이름- -속성이름-="-속성값-" ...> 형태로 온다.
				ㄴ 네임스페이스)
					ㄴ <(*요소이름*) xmlns="-URI-"> 또는 <(*요소이름*) xmlns:(*ns이름*)="-URI-">.
					ㄴ ns이름을 넣지않는경우 해당요소의 자식요소들은 모두 해당 ns에 속하게 된다. ns이름을 넣을경우
				        <(*ns이름*):(*요소이름*)>이런식으로 요소이름앞에 ns이름을써주고 :을 써준다.
					ㄴ URI는 그냥 URL처럼 웹자원을 나타내는 식별자. 여기선 ns를 구분하기위한 용도로 사용한다.

			ㅇ xml 문서의 구분
				ㅡ위 문법을 모두 만족하는 XML문서를  well-formed XML문서 라고한다.
				ㅡwell-formed xml이면서 DTD를 만족하는 xml문서를 valid XML문서 라고 한다.

			ㅇ xml 파서
				ㅡ응용 프로그램이 xml문서를 읽을수 있도록도와주는것.
				ㅡxml문서의 문법을 검토하기도함.
				ㅡhttp://tcpschool.com/lectures/img_xml_parser.png : 파서의 역할

		</pre>

		db<button>더보기</button>
		<pre>
			ㅡ ~~~~~
			ㅡ db일반<button>더보기</button>
			<pre>
				ㅇ db의 데이터 저장
					ㅡ 다른 메모장, 한글 등의 파일과 마찬가지로 db역시 파일 형태로 보조기억장치(HDD, SSD 등)에 저장된다.
					ㅡ
				ㅇ 인덱스<button>more</button>
				<pre>
					ㅡ 개요 )
						ㄴ 간단히 말해 db에서 검색 성능을 올려주는 어떤 자료구조라고 보면된다.
					ㅡ 종류 )
						ㄴ 단일단계 인덱스 )
							ㄴ 테이블에서 임의의 하나의 컬럼의 값과 그 행의 데이터가 저장되어있는 물리적 주소를 연결해서 테이블로 만든다.
							ㄴ 그 컬럼값을 기준으로 정렬이 되어있어서, 이 컬럼값으로 테이블에서 데이터를 찾고 거기의 물리적 주소를 읽어와 데이터를 찾는식.
							ㄴ 그냥 쌩으로 테이블을 다 뒤지는것보다 빨리 찾을 수 있다.
							ㄴ 그걸 또 이진탐색 등을 이용하여 서치하기때문에 빠르다.
						ㄴ primary index )
							ㄴ primary key를 가지고 인덱스를 만들면 primayr index라고한다.
							ㄴ 희소인덱스
								ㄴ 반대말은 '밀집 인덱스'
							ㄴ primary index는 희소인덱스를 유지할수있다.
						ㄴ 클러스터링 인덱스
							ㄴ db record 순서와 일치되는 인덱스.
								ㄴ 테이블에 record가 저장되는 순서를 결정하는 인덱스.
							ㄴ primary index라고도 한다.
							ㄴ 테이블 당 단 하나만 존재.
							ㄴ 보통 pk지정시, pk가 자동으로 clustered index가 된다.
								ㄴ pk가 아닌 다른 컬럼일 수도 있다.
						ㄴ non-clustered index
							ㄴ clustered가 아닌, 그냥 일반적인 인덱스를 의미.
							ㄴ secondary index라고도 한다.
					ㅡ 테이블에 대해, 특정 컬럼의 값과 record의 위치를 나타내는 포인터값으로 데이터 묶음을 만드는 것.
						이 데이터 묶음을 컬럼 값에 대해 정렬을 하여, 이 컬럼 값으로 record를 찾을 때 이진 탐색이 가능하게 하여
						탐색 속도를 올려준다.
					ㅡ 위에 말했듯이, 컬럼 값과 record의 포인터 값 저장을 위해 추가적인 저장 공간 사용.
				</pre>

				ㅇ 트랜잭션<button>more</button>
				<pre>
					ㅡ 다음 조건을 따르는 일련의 연산들 묶음을 한 단위로서 지칭하는 개념적인 단어.
						ㄴ ACID 조건 )
							ㄴ atomic (원자성)
								ㄴ 트랜잭션을 구성하는 연산들을 한 묶음으로 보고, 이 연산들 중 하나라도 실패할 경우, 묶음 전체가
									모두 실패처리되고. 이 연산들 모두가 성공해야 묶음 전체가 성공처리 되는 것.
								ㄴ 트랜잭션이 부분적으로 적용되는 것을 방지.
									ㄴ ex ) 송금 트랜잭션에서, 돈 빠져나가는 부분만 적용되고 받는 부분은 적용 안 되는 경우.
							ㄴ consistency(correctness) (일관성)
								ㄴ 다른 트랜잭션에게 영향을 받은 게 아니라면, 한 트랜잭션의 완료 후에도 db가 일관된 상태를 유지해야 한다.
								ㄴ 일관된 상태란, db스키마의 제약 조건들이나 db의 다른 조건들을 만족시키고 있는 상태..???
							ㄴ isolation
								ㄴ 여러 트랜잭션이 들어왔다면, 한번에 한 트랜잭션만 수행될 수 있다. 즉, 나머지 트랜잭션은
					ㅡ 무제 ) <button>more</button>
					<pre>
						ㄴ DBMS는 동시에 시스템을 사용할 수 있는 유저의 숫자를 기준으로 분류될 수 있다.
							ㄴ 한번에 한 명의 유저만 사용할 수 있으면 single-user, 여러명이면 multiuser.
							ㄴ 물론, 대부분의 시스템은 multiuser.
						ㄴ
							ㄴ Interleaved processing에서는 한 프로세스가 돌다가 잠깐 멈추고 다른 프로세스가 돌다가 또 잠깐 멈추는 식으로
								여러 프로세스를 처리할 수 있다.
							ㄴ paralled processing에서는 여러개의 cpu가 있어 여러 프로세스를 동시에 돌릴 수 있다.
							ㄴ db에서 병렬처리에 대한 대부분의 이론들은 interleaved 방식에 관점에서 만들어졌다.
						ㄴ 이런 조건을 갖추게 트랜잭션을 구현을 한다고?

					</pre>
				</pre>

				ㅇ 정규화<button>more</button>
				<pre>
					ㅡ 데이터의 중복을 없애고 무결성을 보장하기 위해, 소위 '정규화 형태'라고 불리는 형식에 따라 관계형 데이터 베이스의 구조를
                        결정하는 방식을 말한다.
                    ㅡ 다음의 문제를 개선 )
                        ㄴ 업데이트 오류 )
                            ㄴ 같은 데이터가 여러 곳에 존재할 시, 일부만 업데이트 되어 데이터의 논리적 일치성이 훼손될 수 있음.
                        ㄴ 삽입 오류 )
                            ㄴ 특정 데이터를 새로 삽입하고자 할때, 이 데이터를 적절히 나타내는 테이블이 없을 시, 데이터를 삽입할 수 없는 이슈
                            ㄴ ex )
                                ???
                        ㄴ 삭제 오류 )
                            ㄴ 특정 데이터의 삭제가 필연적으로 다른 데이터의 삭제를 동반해야 하는 경우
                            ㄴ ex )
                                ???
                    ㅡ 정규화 목록 )<button>more</button>
                    <pre>
                        ㄴ 제 1정규화 )
                            ㄴ 컬럼의 값들이 '원자성'을 가져야 함.
                                ㄴ 원자성이란 더 이상 나누어지지 않는 성질.
                                ㄴ 즉, 한 컬럼에 여러 가지 데이터가 들어가선 안됨.
                            ㄴ ex )
                        ㄴ 제 2정규화 )
                            ㄴ 후보키가 아닌 컬럼들은 후보키인 컬럼 일부가 아닌 전체에 의존적이어야 한다.
                            ㄴ ex )
                                'Book' 이란 테이블에서,
                                'title', 'format', 'author', 'author_nation', 'price' 컬럼으로 이루어져있고,
                                title, format이 후보키라했을 때,
                                후보키가 아닌 author, author_nation, price 중 author는 title에는 의존적이지만 foramt에는
                                의존적이지 않다. 따라서 제 2정규화를 만족하지 않는다.
                        ㄴ 제 3정규화 )
                            ㄴ 후보키가 아닌 컬럼들은 다른 후보키가 아닌 컬럼들에 대해 의존성을 가져서는 안된다.
                        ㄴ BCNF 정규화 )
                            ㄴ 제 3정규화를 강화한 것으로 3.5정규화라고도함.
                            ㄴ ~~~
                        ㄴ 제 4정규화 )
                            ㄴ ~~~
                        ㄴ 제 5정규화 )
                            ㄴ ~~~

                    </pre>
                    ㅡ 성능과 반정규화 )
                        ㄴ 정규화를 통하여 db에서의 무결성과 중복을 개선할 수 있음.
                            허나, 많은 조인으로 인해 성능상의 trade off를 가지는 경향 있음.
                        ㄴ 이러한 성능상의 이슈 해결을 위해 정규화된 db 구조를 다시 합치는 것을 '반정규화'라고함.
				</pre>

				ㅇ db 설계<button>more</button>
				<pre>
					ㅡ ~~~~~
					ㅡ 설계 프로세스<button>more</button>
					<pre>
						ㄴ 설계 프로세스의 중요성
							ㄴ ????? db의 규모와 유형에 상관없이 설계 프로세스는 처음부터 끝까지 모두 수행되어야 한다고 한다.
							ㄴ 그렇지 못 할수록 구조의 복잡성, 데이터 무결성 문제 등 db에서 문제가 발생할 확률이 높아진다고 한다.
						ㄴ 임무 명세 및 임무 목표 정의
							ㄴ 인터뷰 진행
							ㄴ 임무 명세 정의
								ㄴ ??? 간결하고 명확하게 DB의 목적을 정의?

							ㄴ 임무 목표 정의
								ㄴ ??? 데이터로 하게될 각각의 기능, 작업을 표현하는 문장?
									ㄴ 느낌상, 프로그램 설계에서 구현해야 할 요구사항과 유사하다.
								ㄴ 이를 어떻게 달성할지는 어플리케이션 단에서 다룰 내용이고,
									이 단계에선 이런 목표들을 참고하여 db를 더 잘 설계하는 것에 관심을 둔다.
								ㄴ 여러 내용이 중복되면 나눌 필요가 있다.
								ㄴ ~~~
						ㄴ 기존 db 분석 )
							ㄴ 기존 db가 존재시, 이에 대한 분석 필요. (db든 종이로된 문서db든)
							ㄴ ~~~
						ㄴ 데이터 구조 생성 )
							ㄴ 테이블, 필드, 키, 필드 명세 정의.
							ㄴ
						ㄴ 테이블 관계 연결 및 결정 )
							ㄴ
						ㄴ 업무 규칙 정의 및 결정 )
							ㄴ ???
						ㄴ 뷰의 정의 및 결정 )
							ㄴ 사용자, 관리자와 인터뷰를 다시 진행하여 그들이 데이터로 작업을 수행하는 방식을 확인하고 이를 토대로 필요한
								뷰를 정의.
						ㄴ 데이터 무결성 재확인 )
							ㄴ

						ㄴ 무제 )
							ㄴ 설계 단계 )
								ㄴ 1. db의 목표와 명세 작성
									ㄴ 임무 명세 )
										ㄴ 일반 언어로 db의 목적을 정의.
										ㄴ ????? 간결하게 목적을 표현해야 한다
									ㄴ 임무 목표 )
										ㄴ db의 데이터가 지원하는 작업들을 표현하는 문장.
								ㄴ 2. 기존의 db가 있는 경우, 이의 분석.
								ㄴ 3. 테이블 구조 생성.
									ㄴ 테이블, 필드 정의, 키 설정, 필드 명세 작성.
									ㄴ
									ㄴ 유형
										ㄴ 데이터 테이블
										ㄴ 연결 테이블
										ㄴ 부분 집합 테이블
										ㄴ 검증 테이블
									ㄴ 테이블 명세서
										ㄴ 정확하게 테이블을 정의하는 문장 포함.
										ㄴ 테이블이 필요한 이유를 설명
										ㄴ 명확하고 간결하게.
										ㄴ db구현과 관련된 내용을 담지 않는다.
										ㄴ 다른 테이블 명세서에 의존적인 명세서를 작성하지 않는다.
											ㄴ '테이블 A의 명세서 참고' 등.
										ㄴ 예제를 넣지 말아라.
									ㄴ 테이블 명
										ㄴ 중복되어서는 안된다.
										ㄴ 테이블이 나타내는 대상을 정확하고 명확하게 나타내는 이름을 만든다.
										ㄴ 가능한 최소 개의의 단어를 사용하라
										ㄴ 물리적 특성을 표현하는 단어는 포함시키지 마라.
											ㄴ file, table등
										ㄴ 머리글자, 약어를 사용하지 마라.
											ㄴ 의미 전달이 어렵다.
										ㄴ 테이블에 들어갈 데이터를 모두 포함할 수 있는 이름이어야 한다.
										ㄴ 둘 이상의 의미를 가지는 이름을 사용하지 마라.
										ㄴ 복수형 이름을 사용한다.
									ㄴ 필드 명
										ㄴ 서술적인 고유한 이름
										ㄴ 필드의 특성을 정확,명확하게 나타내는 이름
										ㄴ 최소 단어 개수 사용
										ㄴ 약어 사용 신중
										ㄴ 불분명한 의미 자제.
										ㄴ 여러 의미를 나타내는 이름 사용 않기
										ㄴ 단수형 사용

					</pre>

					ㅡ 무제 )
						ㄴ 정규화 )
							ㄴ 제 1정규화
							ㄴ 제 2정규화
								ㄴ 조건 ) '키'가 아닌 컬럼들은 모든 '키'인 컬럼들 조합에 의해 결정되어야 함.
								ㄴ 모든 '키' 중 일부에 의해 결정된다면 조건을 만족하지 않은 것.
									키를 변경하거나, 일부에 의해 결정되는 컬럼을 분리해야함.
								ㄴ 키 중 일부만에 의해 결정되는 컬럼이 중복이 되므로.
									불필요하게 같은 내용이 여러번 들어가고, 이 중 일부만 업데이트되는 오류 발생.
							ㄴ 제 3정규화
								ㄴ 후보키가 아닌 컬럼들이 후보키가 아닌 컬럼들에 대해 의존성을 가지는 경우,
									즉, 후보키에 대해서만 의존성을 가져야함.
							ㄴ BCNF (3.5 정규화)
								ㄴ ???
                        ㄴ 테이블 개수는 중요한게 아닌가? 구조가 오류가 없고 잘 정규화 되어있어야?

				</pre>

				ㅇ 성능 튜닝(최적화)<button>more</button>
                <pre>
                    ㅡ 성능 측정 기준 )
                        ㄴ ??? 실질적으로 block I/O를 줄이는 정도가 판가름?
					ㅡ ~~~
                    ㅡ 방법 ) <button>more</button>
                    <pre>
                        ㄴ db 설계 )
                            ㄴ ??? 파티션
                            ㄴ ??? 클러스터링
                            ㄴ 정규화/반정규화
                            ㄴ 인덱스
                            ㄴ 적절한 데이터 타입 설정

                        ㄴ DBMS 관련 )
                            ㄴ ??? DBMS의 설정값 변경을 통한 성능 최적화.

                        ㄴ SQL 관련 )
                            ㄴ 적절한 조인 방식 사용
                            ㄴ 인덱스를 활용한 쿼리
                            ㄴ sql hint 사용


                    </pre>
					ㅡ db 설정값 수정.
					ㅡ 인덱스
					ㅡ 파티션
                        ㄴ 크기가 큰 테이블에 대해, 이 테이블에 접근시 전체를 다 훑는게 아니라,
                            특정 기준으로 데이터를 나누어 저장하여 그 기준값에 따라 해당 파티션에 접근시켜 속도를 개선하는 방식.
					ㅡ 데이터 구조 변경
						ㄴ 실행중인 프로그램에 대해 데이터 모델을 변경하는 것은 많은 수정을 필요로 하지만, 필요한 경우 어쩔 수 없다.
					ㅡ 쿼리 튜닝
						ㄴ hint 사용 : 쿼리 옵티마이저가 항상 최적의 튜닝을 하는것은 아니므로 hint를 사용하여 임의 설정이 필요한 경우가 있음.
						ㄴ sql 재작성
							ㄴ 절차적으로 작성된 쿼리는 집합적으로 재작성 필요.
                </pre>


			</pre>

			ㅡ NoSQL<button>more</button>
			<pre>
				ㄴ ~~~~~
				ㄴ 분류 <button>more</button>
				<pre>
					ㄴ 모호하기는 하지만 대략 다음과 같이 분류하고 있다고 한다.
					ㄴ wide column store
					ㄴ document-oriented db<button>more</button>
					<pre>
						ㄴ document 형태의 데이터를 저장하고 관리하는 프로그램.
						ㄴ XML db도 이것의 일종
						ㄴ key-value db의 서브클래스와 같다고 볼 수 있다.
							ㄴ key-value db는 실제 들은 데이터가 db에게는 보이지 않는 반면, document-oriented db에서는 document의 내부 구조에
								의존한다.
						ㄴ RDB와 완전히 대칭점에 있다.
							ㄴ ????? RDB는 개발자가 정의한 테이블에 데이터들을 분리하여 저장하고 하나의 객체는 여러 테이블에 분산되어 있을 수 있지만
							ㄴ ????? document db는 주어진 객체의 모든 정보를 하나의 db인스턴스???에 저장하고 모든 저장된 객체는 다른 모든 객체와 다를 수 있다.
								ㄴ 때문에 ORM이 필요 없다 한다.
						ㄴ 각 document-oriented db에 따라 구체적인 내용은 조금씩 달라도, 공통적으로
							document가 XML, YAML, JSON등과 같은 형식으로 데이터를 인코딩하고 캡슐화 하고 있다고 가정한다.
						ㄴ document-oriented db에서 'document'는 프로그래밍에서 '객체'의 개념과 거의 유사하다.
							ㄴ 각 'document'들은 특정 형식을 준수할 필요가 없다.
							ㄴ 한 store안에 'document'들의 타입이 같은 필요가 없고 내부의 필드들이 있어도 되고 없어도 된다. 서로 다른 형식으로 인코딩 되어 있을 수도 있다.
						ㄴ db 종류<button>more</button>
						<pre>
							ㄴ MongoDB<button>more</button>
							<pre>
								ㄴ
									ㄴ 각 record를 'document'라 부른다.
									ㄴ 'document'는 필드와 그 값 쌍으로 구성되어있는 data structure이다. json 객체와 유사하다고 보면 된다.
									ㄴ 키-값 쌍에서 값은 다른 'document'나 배열 등을 포함할 수 있다.
									ㄴ 장점 )
										ㄴ 'document'의 구성은 프로그래밍 언어의 '객체'와 매우 유사하다.
										ㄴ 값으로 'document'나 다른 배열을 담을 수 있는 것은 join작업의 필요성을 줄여준다.
										ㄴ record의 형태가 자유롭다.

								ㄴ Driver<button>more</button>
								<pre>
									ㄴ ~~~~
									ㄴ Python Driver<button>more</button>
									<pre>
										ㄴ 참조 ) https://docs.mongodb.com/drivers/pymongo/
										ㄴ ex)
											import pymongo

											client = pymongo.MongoClient('localhost', 27017)
											db = client.(*db명*)
											collection = db.(*컬렉션명*)

											collection.insert_one( (*파이션 dict형 데이터*) ) #db에 데이터가 삽입됨.
									</pre>
								</pre>

								ㄴ 무제 )<button>more</button>
								<pre>
									ㄴ 데이터를 JSON형태와 같이 저장한다.
										ㄴ 해서, 안의 필드들의 데이터 타입에 구애받지 않고, 어떤 필드들이 있는지 없는지에 관해서도 규약이 없다.
									ㄴ 데이터들에 대해 인덱싱, 집계, 쿼리가 가능하다.
									ㄴ db의 record를 'document'라 부른다.
									ㄴ 'document'를 'collection'안에 저장한다. 'collection'은 RDB의 테이블과 유사하다고 생각하면 된다.
									ㄴ 읽기만 가능한 'View'와 'On-Demand Materialized View'?????를 제공한다.
									ㄴ 장점 )
										ㄴ 성능
											ㄴ embedded data model 기능이 db시스템의 I/O작업을 줄여준다?????
											ㄴ 인덱스가 쿼리를 빠르게하고, embedded document나 배열의 키를 포함할 수 있다?????
										ㄴ 풍부한 쿼리언어
											ㄴ CRUD작업을 위한 쿼리언어 지원
											ㄴ 집계기능, 문자 검색, 'Geospatial query'?????
										ㄴ ????? High availability
										ㄴ ????? 수평 확장성
										ㄴ ????? multiple storage engine
									ㄴ mongodb shell에서..
										ㄴ 명령어 )
											ㄴ db : 현재 참조하고 있는 db이름 출력
											ㄴ use (*db명*) : 참조할 db변경
												ㄴ 없는 db명이면, 해당 db에 데이터를 처음 집어넣을 때 새로 생성.
										ㄴ collection
											ㄴ 컬렉션이 존재하지 않으면 처음 데이터 넣을 때, 자동으로 생성해 준다.
									ㄴ db는 하나 이상의 'collection'을 저장한다.
									ㄴ insertOne(), insertMany() 'collection'에 'document'를 넣는 메소드.
									ㄴ db와 'collection'이름에는 지켜야 하는 규칙이 있다.
									ㄴ db.createCollection()을 통해 명시적으로 'collection'을 생성할 수 있다.
										ㄴ 다양한 옵션들로 'collection'의 설정 정보를 정할 수 있다.
										ㄴ 이러한 'collection'의 설정정보들을 수정하려면 'collMod'를 이용하라.
									ㄴ 'collection'내의 'document'들은 내부의 데이터 타입이나 필드들이 같을 필요가 없다.
										ㄴ 같게 하고 싶다면 'document validation'을 사용하라.
									ㄴ 'document'의 구조를 바꿀 수도 있다. (필드 수정이나 타입변경 등)
									ㄴ 'collection'은 불변인 'UUID'를 할당받는다.
										ㄴ ????? 이 UUID는 replica와 shard들 간에 공유된다.
										ㄴ UUID확인하려면 listCollections명령어나 db.getCollectionInfos()메소드 호출.
									ㄴ 'View'
										ㄴ 다른 'collection'이나 'View'의 'aggregation pipeline'에 의해 내용물들이 결정되는
											쿼리 가능한 객체.
										ㄴ disk상에 저장되지 않으며, 클라이언트에서 view를 대상으로 쿼리할 때만 계산된다.
										ㄴ 'view'에대해 클라이언트가 쿼리하는 것에 대한 권한 설정이 가능하다
										ㄴ 'view에 대한 쓰기 작업은 불가하다. 읽기만 가능하다.
										ㄴ ????? 클ㄹ라이언트가 'view'에 대해 쿼리하면, mongodb는 'pipeline'??에 그 쿼리를 이어붙여 이를 반환한다.
										ㄴ ????? db.createCollection(), create명령어나 db.createView()를 통하여 'view'생성 가능.
										ㄴ source가 되는 'collection'과 같은 db에서 생성하여야 한다.
										ㄴ 다음 메소드 사용 가능
											ㄴ db.collections.find(), db.collections.findOne(), db.collections.aggregate(),
												db.collections.countDocuments(), db.collections.estimatedDocumentCount(),
												db.collections.count(), db.collections.distinct()
										ㄴ index, sort
											ㄴ 소스 'collection'의 인덱스를 사용한다.
											ㄴ ?????
										ㄴ projection 규약?????
										ㄴ 'view'이름을 수정할 수 없다.
										ㄴ view 생성?????
											ㄴ ?????
										ㄴ ????? sharded view
										ㄴ ????? collation
										ㄴ ????? public view definition
										ㄴ db.collection.drop()을 통해 뷰 제거 가능.
										ㄴ 사용가능한 메소드들
											ㄴ ~~~~~
									ㄴ ????? 'On-Demand Materialized View'
										ㄴ aggergate pipeline으로 부터 나온 'stage'???들을 'collection'에 쌓아오리ㅓㅣ
									ㄴ Document
										ㄴ mongodb는 record를 'BSON'으로 저장한다.
										ㄴ 키값 쌍의 데이터이고
										ㄴ 값으로는 BSON의 어떤 데이터 타입도 올 수 있다.
									ㄴ ~~~~~
									ㄴ 데이터 모델링
										ㄴ 다른 db들에 비해 유연하다. 정해진 스키마가 고정되지 않아도 된다.
											ㄴ 이를 통해 '객체'나 '엔터티'를 매핑하는게 수월하다.
										ㄴ embedded 'document'
										ㄴ reference
											ㄴ document는 필드로 또 다른 document를 참조 할 수 있다.
										ㄴ mongodb에서, 쓰기 작업은 하나의 document에 대해서 원자성을 보장한다.
											ㄴ embedded document를 수정할 때에도.
											ㄴ embedded 형태의 'denormalized data'는 쓰기작업에서 원자성을 보장하기 수월하게 해준다.
											ㄴ 쓰기 작업이 여러 document들을 수정할 때는, 각 document들에 대해서는 원자성을 보장하지만, 전체에 대해서는 아니다.
												ㄴ 이 경우에도 원자성을 보장하는 방법이 있다함. (문서의 'transactions'항목)
										ㄴ 디자인
											ㄴ embedded 모델
												ㄴ embedded되는 'document'를 포함하는 경우 사용
												ㄴ document는 최대 BSON 데이터 크기 제한을 가지고 있다.
											ㄴ reference 이용
												ㄴ embedded document의 이용이 데이터의 중복을 발생시키면서, embedded를 이점인 읽기 작업의 성능이
													충분히 발휘되지 않을 때
												ㄴ 다대다 관계 연결이 필요한 경우
												ㄴ ????? 규모가 큰 계층형 데이터를 모델링할때???
											ㄴ ~~~~~
										ㄴ 예시, 패턴 )
											ㄴ 일대일 )
												ㄴ 포함하고 있는 데이터일 경우, embedded 형태를 사용한다. ex) 사람 컬렉션 안에 embedded document로 포함된 주소 컬렉션
												ㄴ 너무 포함된 데이터가 많은 경우, reference로 빼낸다. 이를 'subset pattern'이라 함.
													ㄴ 너무 embedded된 데이터가 많은 경우, 불필요한 load를 가져오게 되므로.
													ㄴ 당연히 이렇게 나누게 되면 나뉘어진 데이터를 가져올 때 비용이 더 들고, 이런 데이터들을 추적하기 어려워지므로
														적절하게 사용하여야 한다.
											ㄴ embedded를 이용한 일대다 관계
												ㄴ '사람'엔터티와 매핑되는 여러개의 '주소'엔터티가 있는 경우, reference를 이용하려면
													'주소'에서 '사람'에 대한 참조를 가지고 있어야 한다. 이런 경우, '사람'의 이름으로 '주소'를 찾으려면
													여러개의 쿼리가 나가야 '주소'를 찾을 수 있다.
												ㄴ 이런 경우는, 'reference'보다는 embedded를 이용하여 '사람'엔터티가 여러개의 '주소'엔터티를
													포함하고 있는 게 적절하다.
												ㄴ 이러한 경우에 embedded를 사용하는 경우에도 'subset pattern'을 사용하여 너무 embedded되는 데이터가
													많을 경우 적절하게 나눌 수 있다.
											ㄴ reference를 이용한 일대다 관계 )
												ㄴ embedded와 유사. '퍼블리셔', '책'의 예를 들면, '퍼블리셔'당 '책'의 수가 적고 제한적이면
													'퍼블리셔'안에 '책'에 대한 참조를 넣으면 되고, '퍼블리셔'당 '책'의 수가 많고 제한 없이 증가하면
													'책'에서'퍼블리셔'에 대한 참조를 가지고 있는 것이 적절할 수도 있다.
												ㄴ 컬렉션의 필드로 다른 컬렉션의 키값을 가지는 배열을 가지고 있으면
											ㄴ 트리 구조 )
												ㄴ
									ㄴ ~~~~~
									ㄴ Sharding )
										ㄴ mongodb에서 여러 기계에 db를 분배하는 방법을 말함.
										ㄴ 쉬운 수평적 확장과 큰 규모의 데이터 set과 높은 연산 성능의 이점이 있다.

								</pre>
							</pre>
						</pre>
					</pre>
					ㄴ key-value db<button>more</button>
					<pre>
						ㄴ Map, dictionary, hash 등과 같은 '연관 배열'의 저장, 검색, 관리를 위한 db 패러다임.
						ㄴ ~~~~~
					</pre>
					ㄴ graph db
				</pre>

			</pre>

			MySQL<button>더보기</button>
			<pre>
				ㅇ MYSQL
					ㅡ 참조 : https://dev.mysql.com/doc/refman/8.0/en/preface.html
					ㅡ 디비란 그냥 정보를 저장한 것?
					ㅡ dbms ( database management system)이란 말그대로 사용자가 db를 관리하게 해주는 소프트웨어.
						ㄴ 디비를 defining, constructing, manipulating, sharing을 쉽게 하게해줌.
							ㄴ defining : 디비의 데이터 타입, 구조, 제약조건 등을 명시하는것
							ㄴ constructing : 디비에 데이터를 저장하는것.
							ㄴ manipulating : 특정 데이터 추출을 위한 쿼리나 업데이트, 기록 출력 등의 함수를 실행하는것.
							ㄴ sharing : 여러 사용자가 디비에 동시에 접근하게 해주는것.
						ㄴ 추가적으로 디비 protecting, maintaining의 기능도 한다.
							ㄴ protecting : 보안상의 공격이나 기능상의 문제로부터 디비를 보호하는것
							ㄴ maintain : 디비시스템을 업데이트해주는것
					ㅡ 어플리케이션 프로그램은 '쿼리'를 보냄으로서 디비에 접근한다.

					ㅡ 결국 디비프로그램은 그냥 파일에 데이터 저장하는 것을 좀더 체계적으로 저장하고 이를 편리하게 조작할 수 있게 해주는 등의 기능을 제공하는 프로그램의 일종?
						ㄴ image폴더의 dbms 구조 예.png
					ㅡ 기타 알아두어야 할것 )
						ㄴ 디비명과 테이블명은 case-sensitive이다. (unix에서만. window는 해당안된다함. 그래도 헷갈리니까 걍 다이렇게알고잇자)

					ㅡ 더 알아봐야하나?
						ㄴ 파일에 데이터를 저장하고, 읽어오고 이런게 기반기술??이고 이건 내가 아는 부분과 맞닿아있기때문인가?
						ㄴ 그 외에 나머지부분들(내부적으로 이를 기반으로 돌아가는 알고리즘? 같은거)은 정확하게 모르긴해도 굳이 지금 공부할 이유는 없는 부분이라 안궁금한건가? 일단 전체적인 윤곽은 잡았으니 나중에 필요하면 그때 와서 공부하면 되니까.
							ㄴ 늘 말하듯이 모든걸 다 공부할 수 는 없으니 윤곽만이라도 파악해두고 나중에 필요할 때 와서 공부하는 방식이 괜찮다고 생각하기때문?

				ㅇ db 권한
					ㅡ 모든 디비접근은 해당 디비에 대한 권한이 있어야 가능.
						ㄴ GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host'; 와 같은 명령문을 관리자계정에서 실행하는것을 통해
							권한 부여가 가능하다.

				ㅇ 디비 명령어
					ㅡ 처음 연결 )
						ㄴ 'mysql' 명령어를 사용한다.
						ㄴ mysql -h (*host명*) -u (*유저명*) -p 입력후, 나오는 비번입력해주면 접속.
					ㅡ 데이터 베이스 조회 )
						ㄴ show databases : 존재하는 db목록을 보여준다.
							ㄴ 권한이 없는 db는 보여주지 않는다.
					ㅡ db 선택 )
						ㄴ use (*db명*) : 해당 디비로 접근한다.
					ㅡ db 생성 )
						ㄴ create database (*디비명*) : 디비생성
					ㅡ 테이블 목록 조회 )
						ㄴ show tables : 디비의 모든 테이블 출력.
					ㅡ 테이블 생성 )
						ㄴ CREATE TABLE (*테이블명*) (name VARCHAR(20), owner VARCHAR(20),
							species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
					ㅡ 특정 테이블 조회 )
						ㄴ describe (*테이블명*) : 해당 테이블 구조 출력.
					ㅡ 테이블 입력 )
						ㄴ 텍스트 파일을 이용한 입력 )
							ㄴ LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet; : 텍스트파일을 통해 테이블에 값입력.
							ㄴ 텍스트 파일 예
								Whistler        Gwen    bird    \N      1997-12-09      \N
								ㄴ 한줄에 테이블의 한 row를 입력하며 tab키로 컬럼을 구분, 비워둘 컬럼은 \N(null)을 이용해 채움.
								ㄴ local data에대한 사용가능 문제로 안될 수 도 있다.
						ㄴ 명령어를 통한 입력 )
							ㄴINSERT INTO pet VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
							ㄴ 테이블의 칼럼순으로 데이터를 입력한다.
					ㅡ 데이터 검색 )
						ㄴ SELECT (*컬럼들 또는 * *) FROM (*테이블*) WHERE (*조건*) ;
						ㄴ 조건 목록 )
							ㄴ order by )
								ㄴ 데이터들을 정렬하여 받을 수 있다.
								ㄴ ex) select * from aaa order by (*컬럼명*) =>컬럼명을 기준으로 오름차순 순서로 정렬하여 검색한다.
								ㄴ 디폴트는 오름차순이며 내림차순으로 정렬하려면 (*컬럼명*)뒤에 DESC 키워드를 붙여주면된다.
								ㄴ 여러 컬럼을 기준으로 정렬도 가능하다.
									ㄴ ex) select (*컬럼*) from (*테이블*) order by (*컬럼1*), (*컬럼2*) DESC ; 	=>컬럼 1을 기준으로 오름차순 정렬후, 컬럼2를 기준으로 내림차순 정렬하여 검색.
						ㄴ 쿼리문에 date calculation 함수를 사용 할 수 있다.
							ㄴ ex) 	SELECT name, birth, MONTH(birth) FROM pet;
								SELECT name, birth, CURDATE(), TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age FROM pet ORDER BY age;
						ㄴ ??? NULL
						ㄴ pattern matching 기능 )
							ㄴ 검색문에서 특정 패턴을 조건으로 검색할 수 있다.
							ㄴ 'LIKE', 'NOT LIKE' 키워드 뒤에 원하는 패턴을 주어 검색하며, 패턴에는 '%'와 '_'을 사용한다.
								ㄴ % : 임의의 수의 문자들을 나타냄. (임의의 수에는 0도 포함이다)
								ㄴ _ : 단 하나의 문자를 나타냄.
							ㄴ ex)	SELECT * FROM pet WHERE name LIKE 'b%';	=>name의 값으로 'b' 이후에 임의의 문자들이 오는 경우를 검색. buffy, bower 등이 검색된다.
								SELECT * FROM pet WHERE name LIKE '%w%';	=> 임의의 문자들 다음 'w'가 오고 다시 임의의 문자들이 오는 패턴 검색. claws, bower, whistler 등이 검색된다.
								SELECT * FROM pet WHERE name LIKE '_____';	=> _가 다섯개가 있으므로 name의 값이 정확히 다섯개가 되는 패턴이 검색. claws, buffy 등이 검색된다.
							ㄴ 그 이외의 패턴을 사용하고자 한다면, mysql에선 extended regular expressions을 제공한다.
								ㄴ regexp_like()함수를 사용하여 추가적인 패턴 검색을 할 수 있다.
								ㄴ 참조 https://dev.mysql.com/doc/refman/8.0/en/pattern-matching.html
						ㄴ counting row 기능 )
							ㄴ 검색 결과에 대해 합계, 평균, 카운팅 등의 작업을 수행할 수는 기능이 있다.
							ㄴ 참조 https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html
						ㄴ 여러 테이블 묶어서 검색하기 )
							ㄴ inner join과 on 키워드를 통하여 여러 테이블로부터 검색을 수행 할 수 있다.
							ㄴ ex)	SELECT pet.name,
								TIMESTAMPDIFF(YEAR,birth,date) AS age,
								remark
								FROM pet INNER JOIN event		=>pet 테이블과 event 테이블을 묶었다.
								ON pet.name = event.name		=>on 키워드를 통하여 pet테이블의 name과 event테이블의 name을 검색쿼리상에서 같은것으로 취급하고 있다.
								WHERE event.type = 'litter';		=>두 테이블을 묶었기 때문에 컬럼을 사용할때 어떤 테이블의 컬럼인지를 도트(.)를 이용해 명시해주어야한ㄴ다.
						ㄴ 예시들 )
							ㄴ SELECT MAX(article) AS article FROM shop;
							ㄴ SELECT * FROM pet WHERE birth >= '1998-1-1';
							ㄴ SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
							ㄴ SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
				     				  OR (species = 'dog' AND sex = 'f');
							ㄴ SELECT name, birth FROM pet;
							ㄴ SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
					ㅡ??? batch mode에서 사용하기 )
						ㄴ 참조 https://dev.mysql.com/doc/refman/8.0/en/batch-mode.html


					ㅡ 테이블 변경 )
						ㄴ alter 명령어 )
							ㄴ alter table (*table이름*) add column (*컬럼이름*) (*컬럼형식*) (*옵션*) : 테이블에 컬럼추가
							ㄴ alter table (*table명*) modify column (*컬럼이름*) (*컬럼형식*) (*옵션*) : 테이블의 컬럼 변경
						ㄴ UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser'; : 업데이트 명령어.
					ㅡ auto_increment )
						ㄴ 컬럼 설정할때 뒤에 옵션에 'auto_increment'라고 설정하면된다
						ㄴ aaa int auto_increment
					ㅡ primary key )
						ㄴ 컬럼 설정할때 뒤에 옵션에 'primary key'라고 설정하면된다.
						ㄴ 보통 not null옵션과 같이쓰는듯하다.
					ㅡ 컬럼 디폴트값 설정 )
						ㄴ 컬럼 설정할때 뒤에 옵션에 'default'키워드를 쓰고 다음에 디폴트로 설정할 값을 써주면된다
						ㄴ ex) aaa int default 1
					ㅡ 시간 컬럼 설정하기 )
						ㄴ 컬럼 설정할때 컬럼 형식으로 datetime을 사용하고 디폴트값으로 'current_timestamp'를 설정하면 데이터가 삽이되는 시간이 디폴트값으로 설정된다.
						ㄴ aaa int default current_timestamp
					ㅡ 삭제 )
						ㄴ delete from (*테이블명*) where ~~
					ㅡ null값 검색 )
						ㄴ where (*컬럼명*) = null 이런식으로하면 안되고, where (*컬럼명*) is null 으로 해야 된다.

				ㅡ 일단 아주 기초적인것들은 알았으니 여기까지만하고, 더 필요하면 reference참고해서 공부하도록하자.
					ㄴ 데이터 타입, mysql 프로그램, 서버쪽 클라이언트쪽, statement가 어떻게돌아가는지, 함수들... 공부할게 너무 많다. 일단 다른것부터 하자.

				ㅇ java에서 mysql사용하기
					ㅡ jdbc라는 툴을 사용하여 커뮤니케이션한다.

				ㅡ ResultSet 관련)
					ㄴ 쓸만한 메소드들)
						ㄴ https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html  오라클 jdbc api참조
						ㄴ boolean absolut ( int row ) : 해당 row번호로 커서를 이동.
						ㄴ boolean first() : 커서를 맨처음으로 이동. 1번의미.
						ㄴ (*데이터형*) get(*데이터형*) () : 데이터 받는 메소드. 데이터형태 무수히 많음.
						ㄴ ResultSetMetaData getMetaData() : resultset의 컬럼에 대한 정보를 알려주는 객체 반환. 컬럼의 개수 타입 속성등을 알수있다.
						ㄴ int getRow() : 현재 row의 번호를 반환.
						ㄴ boolean isLast() : 커서가 현재 마지막row인지 판별.
						ㄴ boolean last() : 커서를 마지막위치로 이동.
						ㄴ boolean next() : 커서를 다음row로 이동
						ㄴ boolean previous() : 커서를 한줄 위로 이동.
						ㄴ boolean relative ( int row ) : 커서를 상대위치로 이동. row의 값이 양수면 다음으로 음수면 이전으로 이동.
						ㄴ void beforeFrist() : 커서를 첫번째 바로 이전 위치로 이동시킨다. 0번의미.
						ㄴ 등등..
					ㄴ ResultSet 객체받고 맨처음 next()하기 전에는 커서가 0을 가리키고잇으며 이는 row를 가리키는게 아니다. 쿼리결과의 첫번째 row는 1번부터이다.

			</pre>

            Postgresql<button>more</button>
            <pre>
                ㅡ ~~~
                ㅡ 외부 접속 허용
                    ㄴ
                ㅡ 유저 검색
                    ㄴ select * from PG_USER;
                    ㄴ \du
                ㅡ 유저 생성
                    ㄴ create user (*user명*) (*옵션들*)
                    ㄴ ex ) create user bbdlab SUPERUSER;
                    ㄴ 옵션 )
                        ㄴ ~~~
                ㅡ db 생성
                    ㄴ create database (*db명*) (*옵션들*);
                    ㄴ ex ) create database bbdlab OWNER bbdlab;
                    ㄴ 옵션 )
                        ㄴ OWNER : db의 소유자 지정. 해당 db에 대해 여러 권한을 가짐.
                ㅡ db 삭제
                    ㄴ drop database (*db명*);
                ㅡ talbe 목록
                    ㄴ
                ㅡ table 생성
                    ㄴ create table (*table명*) (
                            (*컬럼명1*) (*타입*) (*설정들*),
                            (*컬럼명2*) (*타입*) (*설정들*),
                            ~~~
                        );

                ㅡ dump <button>more</button>
                <pre>
                    ㄴ dump
                        ㄴ pg_dump -U (*db소유자*) (*db명*) > (*dump파일명*)
                            ㄴ ex ) pg_dump -U test postgres > postgres_DB_NAME_bak.sql
                            ㄴ 옵션 )
                                ㄴ -O : ??? db owner 설정을 무시?
                        ㄴ 특정 테이블 dump
                            ㄴ -t (*테이블명*)  옵션 추가
                            ㄴ ex ) pg_dump -U test postgres -t userTable > postgres_DB_NAME_bak.sql
                        ㄴ 압축 형식 )
                            ㄴ pg_dump (*db명*) | gzip > (*결과 내보낼 파일명*)
                            ㄴ ex ) pg_dump openmetric | gzip > openmetric_bak.gz
                            ㄴ ??? 복원시 ) ex ) gunzip -c (*dump결과 파일*) | psql (*db명*)
                        ㄴ pg_dump와 postgre의 버전 다르다는 오류 발생시
                            ㄴ pg_dump 파일 찾기
                                find / -name pg_dump -type f 2>/dev/null
                            ㄴ 결과 ex )
                                /usr/pgsql-9.3/bin/pg_dump
                                /usr/bin/pg_dump
                            ㄴ symlink 생성
                                sudo ln -s /usr/pgsql-9.3/bin/pg_dump /usr/bin/pg_dump --force
                    ㄴ 복원
                        ㄴ pg_restore
                            ㄴ
                        ㄴ psql
                            ㄴ dump한 파일이 sql이면 pg_restore사용이 오류 뜸? (dump file이 text라고) psql 사용 필요.
                            ㄴ psql -U (*db소유자*) (*db명*) < (*dump한 sql파일명*)
                                ㄴ ex ) psql -U 소유주 DB_NAME < postgres_DB_NAME_bak.sql
                                ㄴ 옵션 )
                                    ㄴ --set ON_ERROR_STOP=1 : sql입력시, 오류 발생하면 멈춤.
                                    ㄴ --single-transaction : 오류 없이 완료 되었을 때 한번에 db에 적용.
                            ㄴ 특정 테이블만 복원
                                ㄴ ex ) psql -U user -f db_bak.sql postgres
                </pre>

            </pre>

            ㄴ Redis
                ㄴ key-value 쌍의 데이터 저장.
                    ㄴ 별다른 테이블 없음.
                    ㄴ 그냥 dict 저장하듯이, key-value쌍을 끝없이 저장.
                ㄴ 인메모리 dbms
                    ㄴ 디스크에 데이터를 저장하는게 아닌 메모리에 데이터를 저장하는 dbms
                    ㄴ 디스크 접근 시간이 없으므로 상대적으로 빠름.
                ㄴ 컴퓨터에 설치하여 메모리를 잡고 여기에 데이터를 저장하여 요청오면 저장 또는 반환하는 식.
                ㄴ 인메모리이므로 컴퓨터 종료시 데이터 날아감.
                ㄴ ~~~

		</pre>

		깃<button>더보기</button>
		<pre>
			ㅇ  버전관리 시스템( VCS, Version Control System )
				ㅡ 로컬 버전관리 : 말그대로 로컬컴퓨터 내에서 버전을 데이터베이스로서 관리하고 원하는 버전에 checkout하는 방식.
				ㅡ 중앙 집중식 버전관리(CVCS) : 중앙 서버에 버전db를 올려놓고 여러컴퓨터가 그걸받아서checkout하는 방식. 중앙서버에 문제가
												생기면 문제가 크다.
				ㅡ 분산 버전 관리시스템(DVCS) : 마지막 버전정보를 checkout하는게 아니라 지금까지의 버전정보인 히스토리와 저장소 전체를
												복제한다. 따라서 서버가 다운되더라도 클라이언트가 복제한 정보 아무거나로 복원이 가능하다.

			ㅇ 깃 개요
				ㅡ 깃은 다른 버전관리시스템과 달리 데이터를 파일시스템의 스냅샷의 연속으로 취급한다. 파일이 달라지지않으면 저장하지않고
					링크만걸어둔다.때문에 크기가 작다.
			ㅇ 특징
				ㅡ깃은 대부분의 명령과 기능이 로컬에서 이루어지기대문에 네트워크의 영향을 별로 받지 않는다.
				ㅡ 깃은 체크섬이라는 무결성체크용 기술을 사용한다고함.(뭔진 잘모름)
				ㅡ 깃에선 데이터를 삭제하거나 되돌리는건 없다. '추가'만 할뿐.

			ㅇ 깃의 구조
				ㅡhttps://git-scm.com/book/en/v2/images/areas.png
					ㄴ working directory : 로컬에서 작업하는 해당 폴더를 의미하는 듯하다.
					ㄴ staging area : .git안에서 추상적?으로 존재하는 영역? 이폴더안에 깃의 규칙에 맞게 내용이 저장된다.
										working directory를 git init으로 설정하면 생기는 숨겨진 폴더 .git이 생성된다.
					ㄴ .git directory : 마찬가지로 .git폴더 안에서 저장되는 듯하다.
				ㅡ 깃에서 파일은 몇가지 상태로 존재한다.
					ㄴ committed : 데이터가 로컬db에 저장됨.
					ㄴ modified : 수정된파일이 아직 커밋되지않음.
					ㄴ staged : 수정된파일이 곧 커밋될것이라고 표현한 상태.
					ㄴ tracked : 스냅샷에 포함되었던 파일.
					ㄴ tracked는 unmodified, modified, staged로 나뉠수있다. 그 외에는 모두 untracked.
					ㄴ 파일의 상태확인은 git status 명령사용. -s또는 --short옵션을 붙일수 있다.
				ㅡ working directory에서 수정하면 modified상태. 이를 stage하여 staging area에 올려 커밋할 스냅샷을만들면 그게
					staged. 이를 커밋하여 영구적인 스냅샷을 git directory에 만들면 그게 commited상태.
				ㅡ git status : 폴더 안의 파일들의 상태를 나타난다.

			ㅇ 깃 최초설정하기
				ㅡ git config
					ㅡ git config --global user.name (*이름*)
					ㅡ git config --global user.email (*이메일*)
					ㅡ 깃을 저장할대 누가 해당내용을 업데이트했는지를 나타내주는 정보이다. 컴퓨터에서 한번만 설정한다하고
						이렇게 설정하고 원격저장소에 저장하면 이 user정보로 기록이 뜨는듯하다.
				ㅡ.....

			ㅇ 깃 저장소
				ㅡ 깃저장소란
					ㄴ 말그대로 저장소인데, 파일을 변경이력별로 구분하여 저장함.
					ㄴ 로컬저장소와 원격저장소로 나뉨. 전자는 내pc에서만 저장되는 개인용, 후자는 서버에서 모두와 공유하는 저장소.
				ㅡ 로컬 저장소 만들기
					1. 기존 디렉토리를 깃 저장소로 만들기
						ㅡ 해당 폴더 위치로 이동하여 'git init'명령을 실행한다.
						ㅡ 해당폴더는 깃저장소가 되며, 이곳에서 stage, commit등을 할수 있다.
					2. 기존 저장소 clone하기
						ㅡ git clone (*url*) (*폴더이름*) 을 하게되면 url에 있는 저장소의 내용을 히스토리까지 포함해서 전부 복사해
							가져오며, 폴더이름을 쓰지않을수도있다.
				ㅡ 원격 저장소 명령어
					ㄴgit remote : 현재 프로젝트에 지정된 리모트저장소를 확인
					ㄴgit remote add (*원격저장소단축이름*) (*url*) : 현재 프로젝트에 url에 해당하느 ㄴ원격 저장소를 추가한다.
					ㄴgit remote -v : 현재프로젝트에 원격저장소의 단축이름과 url을 볼 수있다.
					ㄴgit clone을 하면 다운을받은 해당 url이 원격저장소 'origin'으로 자동등록이된다. (origin은 그냥처음에 자동으로
						기본적으로부여되는 원격저장소를 가리키는 자동지정이름)
					ㄴgit remote show (*저장소이름*) : 원격저장소 정보확인.
					ㄴgit remote reaname (*현재원격저장소이름*) (*바꿀이름*):이름바꾸기
					ㄴgit remote remove 또는 git remote rm : 삭제
			ㅇ 인덱스
				ㅡ 작업트리 : 흔히말하는 폴더를 말함.
				ㅡ 인덱스 : 작업트리에서 저장소에 저장하기 전, 사이에잇는 공간을말함.
				ㅡ 원격저장소 부분을 HEAD라고한다.
				ㅡ 저장소에 등록하기위해서는 먼저 인덱스에 등록을 해야하며, 이과정을 '스테이징(stage)'이라함. 이를통해 저장소에 올릴것들을 선택할수있음.
				ㅡ 방법) git add (*파일*)명령어로 인덱스에 추가.

			ㅇ 파일 수정 삭제
				ㅡ git diff : staged가 아닌 파일에서 수정된것이있으면 비교해볼수있다.
				ㅡ git rm : 워킹디렉토리의 파일을 삭제하고 이내용을 staging해줒는 것까지 실행하는 명령. 이후 커밋을 해야
								삭제내역이 적용되어 영구적으로 untracked, 지워진다. rm명령을쓰지않고 윈도우상에서 파일삭제만하면
								staing은 따로해야한다.
				ㅡ git mv (*파일이름*) (*바꿀 파일이름*) : 파일이름변경.

			ㅇ 커밋
				ㅡ 어떤순간의 작업공간의 상태를 저장하는것. 작업공간 안에 있는 모든 파일	과 파일의 데이터를 사진 찍듯이 복사해서 저장소에 보존합니다. 즉 커
					밋은 작	업공간의 어떤 시점의 스냅샷이라고 할 수 있습니다.
					(동사) '커밋한다'는 말은 커밋을 추가한다는 뜻입니다. 즉 현재 작업공간의 상태를 커밋으로 만들어서 저장소에 저장한다는 의미입니다.
				ㅡ커밋의 대략적 구조
					커밋이란 git commit 명령어로 저장소에 올리는 작업공간의 하나의 변경된 상태입니다. 하나의 커밋이 더해질 때는 이전 커밋에서 변경된 사항만 추가하면 될
					것입니다. 이 때문에 커밋은 서로 연결된 체인 구조를 형성합니다. 이 구조에서는 예컨대 이전 커밋이 훼손되면 그 이후 커밋도 망가집니다.
				ㅡ 커밋은 이력을남기는 중요한작업이기때문에 커밋버튼을누를때는 커밋메세지를 필수로입력해야함.
				ㅡ커밋메세지는 명료하고이해하기쉽게적어 다른이들에게도 쉽게하여야함. 권장형식이있음.
					1번째 줄 : 커밋 내의 변경 내용을 요약
					2번째 줄 : 빈 칸
					3번째 줄 : 변경한 이유
				ㅡ 커밋되는건 항상 add로 추가된 staged 파일들이라는것 명심.
				ㅡ 명령어)
					ㄴ git commit
					ㄴ 옵션
						ㄴ -a : staging area에 넣지않아도 tracked파일들이 커밋된다.


			ㅇ 히스토리보기
				ㅡ git log 명령어를 통해 커밋 히스토리를 볼수있다.(맨위가 가장최근)
				ㅡ옵션들)
					ㄴ -p 	: 각 커밋의 diff결과출력
					ㄴ -(*숫자*) : 보여줄 커밋개수를 정함.
					ㄴ --stat 	: 통계를 보여줌. 어떤파일이, 얼마나많이변경됐는지,얼마나 많은줄을 추가했는지 등. 요약정보는 맨
								아래에보여줌.
					ㄴ --pretty: 출력결과를 보여줄때 기본형식이외에 다양한 형식으로 결과를 보여주는 기능
					ㄴ -S	: 코드에서 추가되거나 제거된내용중 특정텍스트가 포함되어있는지를 검색. 옵션뒤에 그냥 검색할 텍스트를
							추가하면된다.
					ㄴ git log -- (*url*) : url에 해당하는 파일의 로그를 볼수있다.

			ㅇ되돌리기
				ㅡgit commit --amend : 마지막 커밋을 현재staging area내용으로 대체한다. 가장최근의 커밋을 덮어씌우는것.
				ㅡgit reset HEAD (*파일*) : add된 파일을 staging area에서 꺼낸다.
				ㅡgit checkout -- (*파일*) : modified된파일을 되돌린다.

			ㅇ 태그
				ㅡ커밋 버전에 말그대로 태그를 붙이는것.
				ㅡ태그에는 두종류가있다. 일반태그와 주석태그. 주석태그에는 만든사람이름, 이메일, 태그만든날짜, 태그메세지를 저장.
				ㅡ 태그 등록하기
					ㄴgit tag (*태그이름*) : 현재 HEAD의 커밋에 태그를 등록.
					ㄴgit tag -a (*태그이름*) : 주석달린 태그를 현재HEAD부분의 커밋에 등록.
					ㄴgit tag나 git tag -a 명령어 끝에 현재HEAD 커밋이 아닌 과거 커밋의 체크섬값을 추가해주면 해당 커밋에 대하여
						태그를 등록할수 있다.
				ㅡgit tag : 태그목록보기
				ㅡgit push명령은 태그를 원격서버에 올리지않는다. 따로 push해주어야한다. git push (*원격이름*) (*태그이름*)을
					통해 push할수있다. git push --tags를 하면 원격서버에 없는 태그를 모두 push할수있다.

			*체크섬
				ㅡ깃에서 사용하는 일종의 키값으로. SHA-1이라는 해쉬데이터이다.
				ㅡ깃은 모든 데이터를 이 체크섬값으로 식별한다.
				ㅡ체크섬값은 거의 온세상에서 유일한값이라하며 데이터의 고유값으로 쓰인다.
				ㅡex) 8a8363d93e61185f6df18ed61321626be514c7f4 =>보통 이렇게 생긴 40자짜리 문자열값들이다.
				ㅡ명령어상에서 이 체크섬값을 사용할때는 앞의 7자리만 사용하여도 된다. ex) git show 8a8363d
				ㅡ??태그를 체크아웃할수도 있으며 이럴경우 detached HEAD상태가 되어 문제가생길수도있으니 주의(detached HEAD는
					나중에알아봐)

			ㅇ 복제(clone)
				ㅡ 원격저장소의 내ㅛㅇㅇ을 그대로 다운로드하여 저장

			ㅇ 푸쉬(push)
				ㅡ 로컬저장소의 변경이력을 원격저장소에 올리는것.
				ㅡ 원격저장소의내용이 로컬저장소와 같아지게됨.
				ㅡ 원격서버의 주소를 설정해주어야한다.
					git remote add origin (*원격서버주소*)
				ㅡgit push (*원격이름*) (*브랜치이름*) : push명령어
				ㅡ원격저장소에 쓰기권한이 있어야하며,
				ㅡ원격저장소에 push하였을때 충돌내용이 없어야한다. 예를들면, 내가 원격저장소를 clone을 하고 다른사람이
					그 원격에push하고 나중에  내가 push를 하려고했을때 다른사람이 이미원격에 push해놓은 내용과 내가
					push하려는 내용에서 겹치거나 달라서 충돌이생기면 push할수없다.

			ㅇ fetch
				ㅡ 원격저장소로부터 로컬저장소와 다른 변경이력들을 다운받는다.
				ㅡ로컬에 이름없는 브랜치를 만들어 이곳으로 내용을 가져오며, FETCH_HEAD라는 이름으로 checkout가능하다.
				ㅡmerge는 따로 진행하여 내용을 합쳐야한다.

			ㅇ 풀(pull)
				ㅡ 원격저장소의 내용을 내 로컬저장소에 업데이트하는것.
				ㅡ fetch와 다르게 원격으로부터 내용을 받아와 merge까지 자동으로 진행한다.
				ㅡ 하지만 충돌의 문제때문에 보통 fetch후, 수동으로 merge하는것이 권장된다고한다.

			ㅇ branch
				ㅡ 여러가지 독립된 작업을 수행하기위해 버전의 가지를 만드는것.
				ㅡ 후에 병합된다.
				ㅡ 가장 중심이되는 가지를 master가지라고 하며, 특정가시로 checkout하여 이동하지않는한, 모든작업은 이 master가지에서 진행된다.
				ㅡ 브랜치 종류)
					ㄴ 통합브랜치 : 언제든 배포가능한 상태인 버전을 말한다. 안정성이 중요하며 보통 master브랜치를 통합브랜치로서 사용한다.
					ㄴ 토픽 브랜치 : 기능추가나 버그수정같은 작업을 위한 브랜치로 작업을 완료하면 통합브랜치로 병합된다.
				ㅡ 브랜치 전환)
					ㄴ checkout 명령어를 사용하며, 전환되면 해당브랜치의 마지막 커밋내용이 출력된다.
					ㄴ stash???????????????
				*HEAD)
					ㅡ 현재 브랜치의 선두(가장 최신부분)부분을 의미하며, 기본적으로 master의 선두부분의미.
					ㅡ HEAD를 이동하면 브랜치를 변경할수있음.
					ㅡ HEAD ~3 => HEAD로부터 3세대 앞의 커밋을 가리킴

			ㅇ 병합(merge)
				ㅡ 내가 pull을 한뒤 다른사람에 의해 원격저장소가 업데이트되면, 이후 내가 하는 push는 거부된다. 원격저장소에서 다른변경점이 생겼기때문.
				이럴때 원격저장소의 내용을 내 로컬저장소에 갱신하는데 이를 병합이라함.

			ㅇ 충돌
				ㅡ 위의 병합의 경우를 예를들면, 갱신을 해줄때 같은부분에 변경점이있어 어느것으로 업데이트를해야할지 충돌이일어나는 상황을말함.
				ㅡ 이 충돌의 경우, 직접 그부분을 수정해주어야함.

			ㅇ git의 객체
				ㅡ 깃은 저장하는 데이터를 객체의 형식으로 저장하고관리한다.
				ㅡ 객체의 종류는 blob, tree, commit, tag이다.
				ㅡ blob(binary large object) 객체)
					ㄴ저장하는 파일에대한 객체로, 내용자체'만' 저장된다. 파일 이름이나 형식등은 저장되지않는다.
					ㄴ텍스트, 이미지,음악, 단순 이진파일등 다양한형식의 파일이 저장될수있다.
					ㄴ체크섬에서 앞두자리를뺀 38자리가 blob의 이름에 해당한다. 앞두자리는 blob파일이 속한 디렉토리의 이름이다.
				ㅡ tree객체)
					ㄴ 디렉토리를 담당하는 객체로, 현재디렉토리에 있는 blob객체, 하위 디렉토리의 tree객체를 담고있다.
					ㄴ
				ㅡcommit객체)
					ㄴ커밋 히스토리를 저장하는 객체이다.
					ㄴ현재 프로젝트의 최상위 tree객체, 이전 커밋객체, 누가언제 커밋하였는지에 대한 정보, 커밋메세지 등을 저장한다.
				ㅡtag 객체)
					ㄴ커밋에 태그를 달면 생성되는 태그정보에 관한 객체.
					ㄴ 일반태그는 커밋에대한 포인터로 동작하고, 주석태그는 작성자,이메일, 날짜, 메세지를 저장할수있다.

			ㅡ모든 객체는 객체 헤더와 내용으로 이루어져있다. 헤더는 객체의 종류와 크기르 나타내는 문자열, 내용은 각 객체타입별로
				담는 내용들.
			ㅡgit Alias라고 사용자정의 명령문 만들기같은게 ㅇ있다.
			...

			ㅇ도움말 보기
			ㅡ git help (*명령어*) : 해당 명령어에대한 도움말이 나옴.
			ㅡ git (*명령어*) -h : 해당 명령어에 줄수있는 옵션에대한 정보나옴.
			ㅡ git (*명령어*) --help : 위하고똑같은데 인터넷상으로 더 자세하게

			ㅇ 로그인 토큰 방식
				ㅡ 2020년부터 비밀번호를 사용한 로그인이 제한되고 토큰 방식을 이용해야 한다함.
				ㅡ 깃헙 로그인 후, settings > Developer settings > Personal access tokens 에서
					토큰을 생성해주고 git push등을 할때 원래 비번 입력하는 곳에 토큰을 입력해 주면 된다.
				ㅡ 토큰 생성시 여러 설정이 가능하고, 생성된 토큰을 따로 저장해 두어야 한다.
			ㅇ 기존 리포지토리 history 포함하여 새 리포지토리로 복사
				ㅡ git clone --mirror (*복사하려는 리포지토리 주소*)
				ㅡ 클론한 폴더에 생긴 .git파일명 변경
					mv (*생긴 리포지토리*).git .git
				ㅡ 복사하여 저장할 리포지토리 연결
					git remote set-url origin (*새 리포지토리 주소*)
				ㅡ 새 리포지토리에 push
					git push --mirror

		</pre>

		Ajax<button>더보기</button>
		<pre>
			ㅡ 참조 : https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX
			ㅡ 개요 )
				ㄴ Asynchronous JavaScript And XML
				ㄴ 간단히말해, XMLHttpRequest 객체를 사용하여 서버와 통신하는 것을 말한다.
				ㄴ 가장 두드러지는특징은 '비동기적'으로 통신하여 페이지를 refresh하는것없이 데이터를 서버와 주고받을 수 있다는점.
				ㄴ 개인적 생각 )
					ㄴ 그냥 서버하고 요청 응답 주고받는건데 form같은 일반적인 요청과 다르게 페이지 전체를 요청해서 다시 로드하는게 아닌
						일부 개발자가 원하는것만 따로 요청하는 방식인듯하다.
					ㄴ 페이지 전체를 요청해서 로드하는게 아니라는점에서 빠르고 자원낭비가 없는게 이점이라한다.
			ㅇ js의 XMLHttpRequest을 이용한 Ajax )
				ㅡ js로 Http request를 만들기 위해선 XMLHttpRequest 객체가 필요하며, 이는 원래 인터넷익스플로어의 XMLHttp라 불리는 ActiveX 객체에 의해 수행되던 기능이다. 이후 개발된게 XMLHttpRequest.
				ㅡ 기본 사용법 )
					ㅡ 우선 XMLHttpRequest객체를 생성해준다.
						ㄴ ex) httpRequest = new XMLHttpRequest();
					ㅡ request 이후에 XMLHttpRequest 객체에게 어떤 함수가 response를 받아처리할지 설정해주어야한다.
						ㄴ request객체의 onreadystatechange 프로퍼티에 함수의 참조를 할당함으로서 설정가능하다.
						ex)	httpRequest.onreadystatechange = function(){
							    // Process the server response here.
							};
					ㅡ request객체의 open(), send()를 통해 실제 request를 생성할 수 있다.
						ㄴ open ( (*httpRequest의메소드*), (*url*), (*비동기인지 동기인지*) )
							ㄴ 세번째 인자는 옵션이고 디폴트값은 true로, 비동기임을 나타낸다.
								ex) httpRequest.open('GET', 'http://www.example.org/some.file', true);
									httpRequest.send();
						ㄴ send()
							ㄴ 인자에 서버에 보내고자하는 데이터를 넣으면된다.
							ㄴ 형식에 맞게 데이터를 넘겨야 한다. (name=~~~&~~~, 또는 json, xml 등)
							ㄴ ???POST형식으로 보내고자한다면 send()전에 MIME type을 설정해 주어야한다.
								ㄴex) httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
					ㅡ response를 처리할 함수
						ㄴ??? open()을 '비동기'로 설정했을때만 필요한 단계이다. '동기'일 경우 함수를 명시할 필요가 없다고한다.
						ㄴ 우선 request의 state를 확인해야한다.
							ㄴ request객체의 readyState 프로퍼티에 상태값이 들어있으며
							ㄴ 0(request not initialized), 1(server connection established), 2(request received), 3(processing request), 4(request is finished and response is ready)의 값을 가진다.
							ㄴ 금방 요청이 완료되긴하지만 시간이 걸리긴하므로, 바로 값을 확인하면 0~3이 뜰수도있다.
						ㄴ 이후 response의 state를 확인.
							ㄴ request객체의 status 프로퍼티에 값이들어있으며, http response의 status code와 일치한다(404, 200같은거)
						ㄴ 이후 서버로부터 받은 데이터로 원하는 작업을 할 수 있으며, 데이터를 받는 방식은 두가지이다.
							ㄴ request객체의 responseText : response를 string으로서 받는다.
							ㄴ request객체의 responseXML : response를 XMLDocument로서 받는다. js의 dom 함수로 다룰수있다.
				ㅡ 간단한 예제 <button>펼치기</button>
				<pre>
					< button id="ajaxButton" type="button">Make a request< /button>

					< script>
					(function() {
					  var httpRequest;
					  document.getElementById("ajaxButton").addEventListener('click', makeRequest);

					  function makeRequest() {
					    httpRequest = new XMLHttpRequest();

					    if (!httpRequest) {
					      alert('Giving up :( Cannot create an XMLHTTP instance');
					      return false;
					    }
					    httpRequest.onreadystatechange = alertContents;
					    httpRequest.open('GET', 'test.html');
					    httpRequest.send();
					  }

					  function alertContents() {
					    if (httpRequest.readyState === XMLHttpRequest.DONE) {
					      if (httpRequest.status === 200) {
					        alert(httpRequest.responseText);
					      } else {
					        alert('There was a problem with the request.');
					      }
					    }
					  }
					})();
					< /script>
				</pre>

				ㅡ 예외 처리 ) 서버와의 통신간에 에러발생시 예외는 response를 받기로한 함수에게 전달된다. 해당함수안에 try~catch문 처리를 하는게 좋다.
				ㅡ responseXML로 받기 )
					ㄴ ex) 	var xmldoc = httpRequest.responseXML;
						var root_node = xmldoc.getElementsByTagName('root').item(0);	=>이와같이 DOM 메소드를 이용해 다룰 수있다.
						alert(root_node.firstChild.data);
				ㅡ XMLHttpRequest APIs)
					ㄴ 이 객체로 사용할 수 있는 다양한 api들에 대해 설명한다.
					ㄴ 참조 : https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
					ㄴ ...
			ㅡ Fetch API )
				ㄴ Ajax기술 중 하나이자 최신기술인 fetch api에 대해 배운다.
				ㄴ 참조 : https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
				ㄴ ...
		</pre>

		java<button>더보기</button>
		<pre>
			ㅇ Architecture <button>more</button>
			<pre>
				ㅡ ~~~
				ㅡ java api와 JVM의 조합을 '자바 플랫폼' 또는 '자바 runtime system'이라 부름.
				ㅡ java language
					ㄴ ??? 자바가 네트워크 특화되어 있긴 하지만 범용 언어이기도함.
					ㄴ

				ㅡ


				~~~
				ㅡ 자바 프로그램의 실행
					ㄴ 자바 프로그램은 다른 프로그램들이 os위에서 동작하는 것과 달리 JVM위에서 동작한다.
						ㄴ JVM이란 '자바 가상 머신'으로 os위에서 동작하는 소프트웨어이다. 이 위에서 자바 프로그램이 동작하는 것.
					ㄴ JVM을 사용하는 가장 큰 이유는 'os에 상관없이' 프로그램을 실행시키기 위함이다.
						ㄴ 일반적인 프로그램은 os에 따라서 구현을 달리해야 하기때문.
						ㄴ JVM을 사용하면 자바 프로그램은 똑같고 'os에 맞는 JVM'만 설치해두면 이 JVM위에서 똑같은 자바 프로그램을 실행시킬 수 있는 것.
					ㄴ 자바 컴파일러
						ㄴ 자바 소스코드를 '자바 컴파일러'가 JVM이 이해할 수 있는 '자바 바이트코드'로 변환해준다.
						ㄴ javac.exe 이란 실행파일이 자바 컴파일러이다.
					ㄴ 자바 런쳐
						ㄴ java.exe 라는 실행파일이 '자바 런쳐'이다.
						ㄴ JVM을 구동시키고, 그 위에서 자바 프로그램이 샐행되도록 돕는 프로그램이다.
					ㄴ 자바의 실행속도 )
						ㄴ JVM을 거치기때문에 속도가 느리지 않을까 생각이 되지만,
						ㄴ 오늘날 돌아가는 대부분의 프로그램에서는 이정도속도저하는 문제되지 않는다고 한다.

				ㅡ class loader
					ㄴ jvm의 subsystem
					ㄴ 두 종류 )
						ㄴ bootstrap class loader
							ㄴ jvm 구현체에 포함되는 class loader.
							ㄴ 로컬 디스크로부터 javaAPI 등의 클래스들을 디폴트로 로드해온다.
							ㄴ system class loader, default class loader라고도 불림.
						ㄴ user-defined class loader
							ㄴ 여러 방식으로(네트워크를 통해 클래스파일 다운 등) class들을 로드할 수 있는 class loader.
							ㄴ ??? 런타임시에 프로그램이 설치할 수 있다?
					ㄴ loading, linking, initialization의 기능을 한다함.
						ㄴ Loading )
							ㄴ 자바 컴파일러에 의해 생성된 .class파일을 로드한다.
								ㄴ .class 파일이란, 'java class file' 의미.
									자바 컴파일러에 의해 컴파일되어 JVM이 실행가능한 코드로 변환된 형태.
							ㄴ .class파일을 읽어 이에대한 바이너리 데이터를 만들고 JVM memory의 method area에 이를 저장한다고함.
							ㄴ 각각의 .class파일에 대해서
								ㄴ load된 class의 이름, 부모클래스
								ㄴ class나 인터페이스나 enum과 연관되엉있는지??
								ㄴ Modifier, Variables and Method information etc.
						ㄴ 로딩후, JVM은 이 클래스에 해당하는 Object 클래스를 만든다고함. (모든 클래스의 최상위 클래스라는 그 Object클래스말함)
							ㄴ JVM memory에서 heap 영역에 저장한다함.
							ㄴ 하나의 .class파일당 하나의 Object 클래스 생성.
						ㄴ Linking )
							ㄴ verification, preparation, 그리고 선택적으로 resolution을 수행하는단계
							ㄴ verification
								ㄴ .class파일이 적절하게 포메팅되었는지, 유효한 컴파일러에 의해 생긴파일인지 등을 확인
								ㄴ 문제가있을시, java.lang.VerifyError을 발생시킴.
							ㄴ Preparation : 클래스변수에 대한 메모리할당 및 초기화 과정
							ㄴ Resolution : ???
						ㄴ Initialization )
							ㄴ 스태틱 변수들  값 할당.
					ㄴ 자바에는 클래스로더라는게 잇어서 자바프로그램실행할때 모든 클래스들을 한꺼번에 로드해둘 필요가
						없다고한다. 필요할때 JRE가 클래스로더를 부르면 얘가 동적으로 JVM에 (더 정확히는 JVM메모리에) 로드해주는 방식.
					ㄴ 모든 클래스가 하나의 클래스로더에 의해 로드되는건 아니고 클래스 타입과 경로에따라 결정된다고한다.
						ㄴ getClassLoader()를 통해 해당클래스로더를 확인할 수있다.
					ㄴ 클래스 로더 종류 )
						ㄴ BootStrap ClassLoader : 가장 기본적인 클래스들을 로드하는 클래스로더. 자바 객체가 아닌
							기계어로 되어있고, 부모 클래스로더가없다.
							ㄴ /jre/lib/rt.jar에 있는 jvm실행을 위한 핵심클래스들을 로딩.
						ㄴ Extension ClassLoader : Bootstrap ClassLoader의 자식 클래스로더러, JDK extention 라이브러리
							클래스들을 로드한다.
						ㄴ System ClassLoader : Application ClassLoader라고도 한다. Extention ClassLoader의 자식 클래스
							로더이고, application class path에 있는 클래스를 로드한다.
					ㄴ Delegation - Hierarchy
						ㄴ JVM은 클래스를 로드할 때, 위임 상속 원칙을 따른다고함.
						ㄴ 맨 아래의 application 클래스로더가 로드 요청을 받으면 이를 상위에있는 extension 클래스 로더한테 요청을 전달하는 방식.
						ㄴ 이렇게 맨꼭대기의bootstrap클래스 로더까지 올라간 뒤, 요청을 처리하기 시작한다.
						ㄴ 그리고 bootstrap클래스로더에서 클래스를 찾으면 이 클래스로더가 로드를 하고
						ㄴ 못찾으면 아래로 내려가면서 찾는다.
				ㅡ JVM memory
					ㄴ method area, heap, stack, PC Register, native method stack으로 이루어져 있다.
				ㅡ 실행 엔진
					ㄴ JIT 컴파일러
				ㅡ 가비지 컬렉터
			</pre>

			ㅇ 변수<button>more</button>
			<pre>
				ㄴ '변수'를 '선언'하면 메모리에 공간이 '할당'된다.
				ㄴ 변수에 값을 '저장'하면 메모리에 그 값이 '저장'된다.
				ㄴ 원시 타입. primitive data type )
					ㄴ 자바 언어에서 사전 정의되어 잇으며, 해당하는 특별한 키워드가 예약되어 있다.
					ㄴ boolean
						ㄴ 1바이트. true 또는 false만 가짐.
						ㄴ 디폴트 false.
					ㄴ char : 2바이트. 모든 유니코드 문자.
						ㄴ 16진수로 된 유니코드가 저장된다.
						ㄴ 디폴트 "0"
					ㄴ byte
						ㄴ 1바이트(8비트). -128~127 (-2^7~2^7-1)
						ㄴ ??? 메모리의 저장이 중요한 경우, 큰 크기의 배열을 저장할 때 유용하거나,
							명시적인 값 범위의 제한을 보여줄 수 있어 int의 대용으로 사용된다.
						ㄴ 디폴트 0
					ㄴ short
						ㄴ 2바이트. -32768 ~ 32767 (-2^15 ~ 2^15-1)
						ㄴ byte와 유사한 경우에 유용하다.
						ㄴ 디폴트 0
					ㄴ int
						ㄴ 4바이트. -2^31 ~ 2^31-1
						ㄴ unsigned로 0 ~ 2^32-1 까지 표현 가능.
							ㄴ ??? 근데 이거 쓸거면 Integer class 사용하라함. ?
						ㄴ 디폴트 0
					ㄴ long
						ㄴ 8바이트. -2^63 ~ 2^63-1
						ㄴ int와 마찬가지 unsigned 사용 가능. 기능 동일.
						ㄴ 디폴트 0L
					ㄴ float
						ㄴ 4바이트.
						ㄴ 정확성을 요하는 데이터에 사용하지 마라. 이런 경우, java.math.BigDecimal을 사용하라.
						ㄴ 디폴트 0.0f
					ㄴ double
						ㄴ 8바이트.
						ㄴ 디폴트 0.0d
				ㄴ String
					ㄴ 문자열을 나타내는 기본 객체.
					ㄴ immutable.
						ㄴ 한번 초기화되면 값이 바뀌지 않음.
					ㄴ 디폴트 null.
				ㄴ 변수의 디폴트값
					ㄴ 선언만 하고 초기화하지 않을 경우, 컴파일러가 자동으로 디폴트값을 넣어주기는 한다.
					ㄴ 지역변수인 원시 타입의 경우, 컴파일러가 자동으로 초기화하지 않음.
				ㄴ 상수, literal )
					ㄴ ex ) 123, "c", true
					ㄴ 그냥 소스코드상에 표현되는 고정된 값을 의미.
					ㄴ 변수의 값과 마찬가지로 똑같이 자료형을 기반으로 메모리에 저장이 된다.
					ㄴ 단, 이름이 없으므로 이 저장된 값, 즉, '상수'에 접근할 수 없다. 따라서 변경도 불가하다.
					ㄴ 자바의 상수의 디폴트 자료형 )
						ㄴ 자바의 경우, 상수들의 디폴트 자료형이 미리 정해져있다. 상수값의 크기나 형태에 따라 자동으로 맞는 자료형을 설정해주지 않는다.
						ㄴ 따라서, 상수를 디폴트 자료형이 아닌 특정한 원하는 자료형으로 사용하고싶으면 '접미사'를 이용하여 명시적으로 선언해주어야 한다.
							ㄴ long num = 10000000000000; 	//'정수' 상수의 디폴트 자료형은 int이므로, 상수 10000000000000는 int형 자료형에
																 저장된다. 근데 보다시피 int형의 범위를 넘어서므로 오류가 발생한다.
						ㄴ 상수의 디폴트 자료형 )
							ㄴ 정수 : int형
							ㄴ 실수 : double형
						ㄴ 접미사 )
							ㄴ F : float형	ex) 12.23F
							ㄴ L : long형	ex)  100000000000000L
						ㄴ 예외 )
							ㄴ byte, short형에 대해서는 상수 자료형을 명시하는 접미사가 없다. 디폴트가 int이기때문에 굳이 더 작은크기의 상수 자료형을
								사용할 일이 없기때문에. 거기다가 byte, short형에 대해서는 int형 상수를 이용한 초기화도 가능하게 해두었다.
					ㄴ 정수 상수
						ㄴ 디폴트는 int. long형 상수를 위해선 숫자 위에 'L' 또는 'l'을 붙여야함. ex ) 100000000000000L
						ㄴ 숫자체계 십진법, 16진법, 2진법을 표현 가능.
							ㄴ 16진법 : 앞에 '0x' 붙여 표현. ex ) int a = 0x1a;
							ㄴ 2진법 : 앞에 '0b' 붙여 표현. ex ) int a = 0b110;
					ㄴ floating point 상수
						ㄴ 숫자 뒤에 'F', 'f'를 붙여 float 상수, 'D', 'd'를 붙여 double 상수 사용 가능.
					ㄴ 문자, 문자열 상수
						ㄴ
					ㄴ null literal
						ㄴ 어떠한 참조 타입에 할당 가능한 상수값. 원시타입에는 안됨.
					ㄴ class literal
						ㄴ 타입명 + ".class"
						ㄴ ex ) String.class
						ㄴ
				ㄴ 배열 )
					ㄴ 자바에서 배열도 인스턴스이고 참조변수를 통해 접근된다.
					ㄴ length라는 변수를 가지고있다.
					ㄴ 생성과 초기화
						int[] arrr = new int[3];
						arr[0] = 1;
						arr[1] = 2;
						arr[2] = 3;

						int[] arr = new int[] {1,2,3};

						int[] arr = {1,2,3};
					ㄴ for-each문 )
						ㄴ for ( (*각 요소를 나타낼 변수*) : (*반복의대상*) ){ ~~~ }	//(*각 요소를 나타낼 변수*)는 (*반복대상*)안의요소와 자료형이
																				일치해야 한다.
							ㄴ ex)	for( int e : arr ){System.out.println( e );}	//arr의 모든 요소에 대해 반복, 각 반복마다 요소는 e로 접근가능.
					ㄴ 복사
						ㄴ System class의 다음 메소드 사용.
							public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
						ㄴ 또는 java.util.Arrays의 copyOfRange()
				* 이진수, 십진수 소수점 변환 방법
					ㅡ 십진수 -> 이진수 소수점 변환 )
						ㄴ 소수점 부분을 *2를 한다. 그리고 그 결과값의 '소수점 부분'을 다시 *2를 한다. 이를 반복한다.
						ㄴ 결과값이 1.0이 나오거나 맨 처음 *2했을때의 값이 똑같이나오면 멈추고 여태까지의 결과값들의 소수점이 아닌부분을 순서대로 써주면
							그게 이진수 소수변환된것.
						ㄴ ex)
							8.25에서 0.25를 이진수 소수점 변환한다하면,
							0.25 * 2 = 0.5	=>1.0이 아니므로 결과값의 소수점부분*2.
							0.5 * 2 = 1.0	=>1.0이므로 반복멈추고 결과값들의 소수점이 아닌부분들을 나열. '01'이고, 그러면 8.25의 이진수 변환은
												 1000.01
							ㄴ *2한 결과값이 1.0이 나와도 저렇게 멈추지만 '맨처음 *2했을때의 결과값' 즉, 0.5가 다시한번 나와도 반복을 멈춘다.
					ㅡ 이진수-> 십진수 소수점 변환 )
						ㄴ 소수점 부분을 '2의 역' 즉 2^(-n)을 대입해주면된다.
						ㄴ ex)
							1000.01을 십진수 소수점 변환한다하면,
							0.01부분에서 소수점 첫번째자리는 2^(-1), 소수점 두번째자리는 2^(-2) ..... 이렇게 계산해주면된다.
							따라서, 0*2^(-1) + 1*2^(-2) = 0.25
			</pre>

			ㅇ 연산자 <button>more</button>
			<pre>
				ㅡ 우선순위
					ㄴ x++, x--
					ㄴ ++x, --x, +x, -x, ~, !
					ㄴ *, /, %
					ㄴ + -
					ㄴ << >> >>>
					ㄴ < > <= >= instanceof
					ㄴ == !=
					ㄴ &
					ㄴ ^
					ㄴ |
					ㄴ &&
					ㄴ ||
					ㄴ ? :
					ㄴ = += -= *= /= %= &= ^= |= <<= >>= >>>=
				ㅡ ~~~
				ㅡ SCE(short-circuit evaluation) 방식.
					ㄴ ex ) (1 < 0) && (1 > 0)
					ㄴ 위와 같은 표현식에 대한 참거짓 판단시 앞부분이 false이면 뒷부분 평가하지 않고 결과를 false로 결정하는 방식.
						당연히 성능 더 빠름.
				ㅡ instanceof
					ㄴ ex )
						Parent parent = new Parent();
						Child child = new Child();

						child instanceof Parent
					ㄴ 특정 객체가 어떤 클래스(타입)의 객체인지, 어떤 클래스의 하위 클래스의 객체인지, 어떤 인스턴스를 구현하는 객체인지 확인하여
						bool값 반환.
				ㅡ 형변환 연산 )
					ㄴ 값 앞에 '명시적 형 변환'을 통해 값의 자료형을 변환할 수 있다.
					ㄴ ex) int num=(int)3.14	//double형 실수상수 3.14가 '명시적 형 변환'에 의해 int로 변경되었다.
					ㄴ 실수형에서 정수형 변환시 소수점이 잘려나간다.
					ㄴ 정수형끼리 큰 자료형에서 작은 자료형으로 변환을 하면 상위 바이트가 잘려나간다.
					ㄴ '변환대상 값'을 '변경'하는게 아니라 '변환대상 값'을 형변환한 결과값을 '반환'한다.
				ㅡ Bitwise and Bit Shift 연산
					ㄴ & : 비트단위로 AND연산
					ㄴ | : 비트단위로 OR연산
					ㄴ ^ : 비트단위로 XOR연산 (두 비트값이 다르면 1, 다르면 0)
					ㄴ ~ : 모든 비트 반전.
					ㄴ << : 비트열 왼쪽으로 이동. 생기는 빈공간은 0으로 채움. 2배수 곱셈하는셈.
					ㄴ >> : 비트열 오른쪽으로 이동. 생기는 빈공간은 음수의 경우1, 양수의 경우0으로 채움. 2배수 나눗셈하는 셈.
					ㄴ >>> : 비트열 오른쪽으로 이동. 생기는 빈공간은 0으로 채움
			</pre>

			ㅇ classpath, 패키지
				ㄴ package
					ㄴ 관련있는 type(class, interface, annotaion, enumeration 등)끼리 묶은 것.
					ㄴ 이름 충돌, 탐색 및 사용의 편의, 접근 제어 등의 목적.
					ㄴ java.lang, java.io 등의 java platform의 기본적 패키지 존재.
					ㄴ 사용자가 임의로 만들 수 있음.
					ㄴ package 선언
						ㄴ ex ) package com.example.deepq
						ㄴ 한 소스파일당 단 하나의 package 선언 가능.
						ㄴ 소스파일 맨 위에 선언.
						ㄴ 한 소스 파일에는 단 하나의 public인 type만 존재할 수 있으며, 이 type은 소스파일명과 동일해야 한다.
							ㄴ ex ) NoName.java에는 public class NoName 또는 public interface Noname 등만 올 수 있음.
							ㄴ 즉, 소스파일명과 동일한 이름의 public 선언된 type이 반드시 하나 있어야함.
							ㄴ 이 public type이 외부에서 접근 가능해짐.
					ㄴ 패키지 내의 public 멤버 사용하려면 다음 중 하나 수행.
						ㄴ fully qualified name과 함께 패키지 멤버 명시
							ㄴ ex ) graphics.Rectangle r = new graphics.Rectangle();
						ㄴ 패키지 멤버 import
							ㄴ ex ) import graphics.Rectangle;
						ㄴ 패키지 전체 import
							ㄴ ex ) import graphics.*;
					ㄴ 패기지 계층
						ㄴ 상위 패키지명이 같다고 하위 패키지들이 그 상위패키지 안에 모두 포함되는게 아니다.
							패키지간 관계를 명확히하기 위해서 이름을 그렇게 붙였을 뿐.
					ㄴ 다른 패키지에 속한 같은 이름의 type을 모두 import하여 사용시, qualified name을 사용해야한다.
					ㄴ 'import static ~~~' 와 같이 static import를 하여 패키지의 static 멤버들만 import해와 클래스명 없이 사용할 수 있다.
						ㄴ ex ) import static java.lang.Math.PI;
					ㄴ .java파일을 컴파일한 .class파일들도 .java파일과 마찬가지로 패키지 구조대로 디렉토리 구조를 가져야한다.
						컴파일러나 jvm이 classpath에서 클래스파일을 찾을때 이 패키지 구조대로 찾는다.

			ㅇ 표현식(expressions), 문장(statements), 블록(blocks)
				ㅡ 표현식
					ㄴ 하나의 값을 평가하는, 문법에 따라 작성된 변수, 연산자, 메소드 호출로 구성된 구성 일부.
					ㄴ ex )
						int cadence = 0;  // cadence = 0
						anArray[0] = 100;  // anArray[0] = 100
						System.out.println("Element 1 at index 0: " + anArray[0]);  // "Element 1 at index 0: " + anArray[0]

						int result = 1 + 2; // result is now 3
						if (value1 == value2)  // value1 == value2
							System.out.println("value1 == value2");
				ㅡ 문장
					ㄴ 그냥 코드에서 한 줄의 문장을 말함.
					ㄴ
				ㅡ 블럭

			ㅇ 클래스 <button>펼치기</button>
			<pre>
				ㅡ 클래스 )
					ㄴ 클래스형 변수는 '참조변수'이다.
				ㅡ 접근 제어 지시자 )
					ㄴ 디폴트 선언 )
						ㄴ 접근제어 지시자를 선언하지 않는 경우에 해당하며, 동일 패키지 내에서의 접근을 허용한다.
				ㅡ 캡슐화 )
					ㄴ 여러 기능이 모여 '하나의 목적'을 달성하는 것. 캡슐화가 되어있다 라고 한다.
					ㄴ 관련있는 데이터나 함수를 묶어주는 것, 높은 응집도, 낮은 결합도, 모듈화.
					ㄴ 정답이 없으며 잘정의해야 한다.
				ㅡ static 변수, static 메소드 )
					ㄴ static 변수 )
						ㄴ 변수가 선언된 클래스의 '모든 인스턴스'가 공유하는 변수. '클래스 변수'라고도 한다.
						ㄴ '접근제어지시자'만 적절하다면, 인스턴스뿐만 아니라 클래스 이름을 통해서도 접근이 가능하다.
							ㄴ ex) (*클래스 이름*).(*static변수이름*)
						ㄴ JVM에 의해 클래스가 '클래스로더'에 의해 '초기화'되고 나면 인스턴스의 생성과 관계없이 사용할 수 있다.
						ㄴ 상속된 하위클래스들 사이에서도 공유된다.
					* class가 초기화 되는 시점
						ㅡ 해당 클래스의 인스턴스가 생성될때,
						ㅡ 해당 클래스의 static 메소드가 호출될때
						ㅡ 해당 클래스의 static 변수에 값이 할당될때
						ㅡ 해당클래스의 constant가 아닌 static변수가 사용될때
					ㄴ static 메소드 )
						ㄴ static변수와 마찬가지로, 인스턴스 생성없이도 static 메소드를 호출 할 수 있다. '클래스 메소드'라고도 한다.
						ㄴ 기능상 당연히 '인스턴스 변수'에 접근이 불가능하다.
					ㄴ 인스턴스 메소드처럼 런타임시에 다형성에 의해 동적으로 결정되는 것이 아니라, 컴파일시에 클래스에 기반하여 결정되기 때문에
						'static'(정적인) 이라 부른다.
				ㅡ 메소드 오버로딩 )
					ㄴ overload : 너무 많이주다, 과적하다. / 같은 이름의 메소드를 너무 많이 정의한다는 의미로 기억하자.
					ㄴ 자바에서 '동일한 이름'의 메소드를 여러개 정의할 수 있게해주는 기능.
					ㄴ 이름과 반환형을 동일하게 두고, '매개변수'의 개수, 자료형, 순서를 다르게 함으로써 이름은 같으나 매개변수에 따라 그에맞는 메소드가 호출되게 할 수 있다.
						ㄴ 반환형은 호출문으로 구분이 안되므로 오버로딩 조건에 포함안됨.
				ㅡ 생성자 )
					ㄴ ~~~
					ㄴ 기본적으론 명시적 호출 불가.
						생성자 내에선, 다른 생성자 명시적 호출 가능. (물론, 'this'키워드 사용)
				ㅡ 값에 의한 참조, 참조에 의한 참조
					ㄴ 전자는 값이 넘어오는 것.
					ㄴ 후자는 참조값이 넘어오는 것.
						ㄴ 참조값이 넘어오는 것이지 변수 자체가 넘어오는 것이 아니다. 매개변수에 참조값이 들어있을 뿐.
							매개변수에 다른 값을 할당해도 매개변수 안에 들은 참조값이 바뀔뿐이지 호출한 곳에서 참조값이 바뀌지 않는다.
				ㅡ String )
					ㄴ 자바에서 문자열을 나타내는 클래스.
					ㄴ 큰 따옴표 (" ")만으로 인스턴스의 생성이 가능하다. ex) "hello"	=>hello라는 문자열을 가진 String 인스턴스가 생성됨.
					ㄴ 한번 문자열이 저장되어 인스턴스화가 되면 문자열의 내용은 절대 변경이 불가능하다.
					ㄴ 문자열의 '내용'이 같으면 새로운 String인스턴스를 생성하지 않고 기존에 있던 인스턴스를 사용한다.
						ㄴ ex)	String str1="hello";
							String str2="hello"; 	//str1, str2는 같은 String인스턴스를 참조한다.
						ㄴ 이유는 인스턴스의 생성은 연산상 시스템에 부담이 되는 작업이기때문에 이를 최소화하기 위해서라고 한다.
						ㄴ 또한 이렇게 같은 인스턴스를 참조하게 하면, 인스턴스의 내용이 변경되었을때 같은걸 참조하는 참조변수들의 내용도 바뀌기때문에
							이를 방지하기위하여 String은 한번 정해진 문자열 내용을 변경할 수 없게 해두었다고함.
						ㄴ new String() 생성자를 통해 String인스턴스를 생성할 경우, 내용이 같더라도 새로운 인스턴스를 생성 할 수 있다.
							ㄴ ex)	String str1="hello";
								String str2="hello";
								String str3=new String("hello");	//str1, str2와는 다른 참조값을 가진다.
					ㄴ 유용한 메소드들 )
						ㄴ int length() : 문자열 길이 반환
						ㄴ String concat(String str) : str을 뒤에 이어붙여 새로운 String반환
						ㄴ int compareTo(String str) : 두 문자열 비교. 동일하면 0반환, 아니면 ~~~~~~~~~~~
						ㄴ public static String valueOf( (*다른 자료형의 값*) ) : 인자로 int, float, boolean 등의 다른 자료형이 넘어오면
							해당 값을 문자열로 변환하여 반환.

				ㅡ 상속 )
					ㄴ 부모 클래스의 멤버변수와 멤버메소드를 자식클래스도 가지도록하는 기능.
					ㄴ 코드의 재사용성과 다형성을 지원한다.
						* 다형성이란?
							ㅡ 하나의 형태로 여러가지 기능을 할 수 있는 것을 말한다.
								ㄴ 가령, 인터페이스 A를 구현한 클래스 B,C가 있으면, B,C는 A타입의 변수만을 이용하여 나타낼 수 있다. 이렇게 하나의 타입으로
									여러가지 객체를 나타낼 수 있거나
								ㄴ 메소드 오버로딩, 오버라이딩과 같이 하나의 함수 이름으로 여러가지 기능을 할 수 있는 것도 다형성이라 한다.
							ㅡ 자바와 같은 객체지향 언어의 특징 중 하나이다.
							ㅡ 장점 )
								ㄴ 하나의 형태로 여러가지 기능을 할수 있기때문에 유지보수에 좋다.
								ㄴ 확장성이 좋은 코드를 작성하는데 좋다.
								ㄴ 결합도를 낮춘다.
					ㄴ 'IS - A'관계가 성립되어야 상속을 사용하는것이 적절하다.
						ㄴ 'HAS - A'관계도 가능이야 하겠지만 다른방식으로 표현하는게 더 효율적이다. (멤버변수로 인스턴스를 가지게 한다든지)
					ㄴ 상위클래스의 생성자 호출 )
						ㄴ super()를 사용. 하위클래스에서 super()이 곧 상위클래스의 생성자를 호출하는 키워드이다.
						ㄴ 반드시 하위클래스의 생성자 안에서 상위클래스의 생성자를 호출해 주어야 하며, 명시적으로 호출하지 않을경우, 자동적으로 상위클래스의 디폴트 생성자
							 호출을 위해 super()가 삽입된다.
					ㄴ 컴파일러의 참조변수 인식 )
						ㄴ 컴파일러는 인스턴스가 들은 참조변수를 볼때, 그 안에들은 '인스턴스'를 기준으로 보는 것이 아니라 참조변수의 '자료형'만을 기준으로 바라본다.
						ㄴ ex)
							class Parrent{

							}
							class Child extends Parrent{
								void aaa(){~~~}
							}
							일때,
							Parrent p = new Child();
							p.aaa(); 	//컴파일 오류가 발생한다. p는 Parrent형이고, 컴파일러는 참조변수에 실제 들어있는 인스턴스 Child가 아니라
								자료형Parrent를 기준으로 참조변수를 인식하고 Parrent에는 aaa()가 정의되어있지 않기때문에 없는 메소드를 호출하였다하여 오류발생.
						ㄴ 단, '오바라이딩'된 메소드를 호출하는 경우는 참조변수의 자료형에 상관없이 가장 마지막으로 '오버라이딩'된 메소드만 호출한다.
					ㄴ 메소드 오버라이딩 )
						ㄴ override : 우선하다, 기각하다 / 상위클래스의 메소드를 무시하고 하위클래스의 메소드를 우선한다는 의미로 기억하자.
						ㄴ 상위 클래스의 메소드와 이름, 반환형, 매개변수형태가 동일한 '완전히 똑같은 메소드'를 하위클래스에서 정의하면, 해당 메소드 호출시
							상위클래스 메소드가 무시되고 하위클래스의 메소드가 호출되는것을 말함. 이를 메소드 '오버라이딩'되었다고 한다.
						ㄴ 오버라이딩한 하위클래스 메소드에서 'super()'를 사용하여 상위클래스의 오버라이딩된 메소드를 호출 할 수 있다.
						ㄴ 참조변수의 자료형과 상관없이 오버라이딩된 메소드는 호출되면 항상 가장 마지막으로 오버라이딩된 메소드가 호출된다.
						ㄴ '접근 제어 지시자'의 범위를 줄이면서는 오버라이딩을 할 수 없다. (가령, protected범위였던 메소드를 오버라이딩하면서 private로 바꾸지는 못함)
						ㄴ final 키워드 )
							ㄴ 메소드앞에 'final'키워드를 붙이면 이 메소드의 오버라이딩을 허용하지 않는다는 의미.
							ㄴ ex) final void aaa(){~~~}
					ㄴ instanceof() : '상속관계'를 바탕으로 '형변환'이 가능한지 묻는 연산자. 가능하면 true, 아니면 false.
						ㄴ ex) box instanceof GoldPaperBox //참조변수 box가 GoldPaperBox형으로 형변환이 가능한지 판별. 가능하면 true,아니면false.
					ㄴ final 키워드 )
						ㄴ 클래스 선언 앞에 'final'키워드를 붙이면, 이 클래스는 상속이 불가하다 라는 의미가된다.
						ㄴ ex)	final class MyClass{~~~}
				ㅡ Object 클래스 )
					ㄴ 자바의 모든 클래스들은 직간접적으로 Object클래스를 상속하게 된다.
						ㄴ 아무런 상위클래스가 없으면 Object를 상속하게 된다.
					ㄴ toString()
						ㄴ Object클래스의 메소드.
						ㄴ 값을 문자열로 변환해 반환하는 메소드이다.
						ㄴ println()안에 인자로 전달되면 인자의 toString()이 자동적으로 호출되면서 이를 출력하게 되므로, toString()을 오버라이딩하여 원하는
							형식으로 객체가 출력되도록하는게 좋다.
					ㄴ public boolean equals( Object obj )
						ㄴ 참조값이 같은지를 확인해주는 메소드.
						ㄴ 허나, 일반적으로는 '오버라이딩'하여 사용한다.
						ㄴ String 같은 표준클래스들에서 이미 이를 오버라이딩한 경우가 있다. (String의 equals()는 문자열을 비교해 같은지 확인함)
					ㄴ protected Object clone() throws CloneNotSupportedException
						ㄴ 현재 인스턴스를 복사하고 그 참조값을 반환한다.
						ㄴ Cloneable 인터페이스를 구현한 클래스만이 사용가능한 메소드이다.
							ㄴ Cloneable 인터페이스 : 아무런 기능없이 텅 빈 인터페이스. 인스턴스의 복사는 경우에따라서 조심해야할 동작이기때문에 이를 구현함으로서
								 '표시'기능을 하는것.
						ㄴ 현재 인스턴스 내부에 있는 '값'들을 복사할 뿐, 그 '값'이 참조하고있는 대상까지 복사하지는 않는다.
							ㄴ 즉, 내부에 인스턴스 변수가 있을 경우, 그 참조값을 그냥 복사할 뿐이지 참조의 대상인 인스턴스까지 복사하지는 않는다. 따라서 복사된
								인스턴스와 원래의 인스턴스가 같은 참조값을 가질 수 있다는 것. 이를 '얕은 복사'라고 한다.
							ㄴ 참조의 대상까지 복사를 하여 인스턴스를 복사하려면(이를 '깊은 복사'라고 한다) clone()을 오버라이딩하여야 한다.
				ㅡ abstract )
					ㄴ abstract 클래스 )
						ㄴ 클래스 앞에 'abstract' 키워드를 붙여서 해당 클래스가 인스턴스 생성을 못하게 설정 할 수 있다. 이를 '추상 클래스'라 한다.
						ㄴ 보통 상속을 위해 직접 인스턴스화할일이 없는 상위클래스에 부여한다.
						ㄴ 인스턴스화가 불가하다는 점을 제외하고는 일반 클래스와 모든점이 같다.
					ㄴ abstract 메소드 )
						ㄴ 메소드의 몸체를 구현하지 않고 앞에 abstract 키워드를 붙이면 '추상 메소드'가 된다.
						ㄴ 추상메소드는 호출될수 없으며, 보통 하위 클래스에서 오버라이딩을 하기위해 미리 선언해두는 용도로 사용한다.
						ㄴ 하위클래스에서는 '추상메소드'를 오버라이딩하지 않으면 여전히 추상메소드를 포함하고있는것이기때문에 추상클래스가 되거나 추상메소드를
							오버라이딩해야한다.
						ㄴ 추상메소드가 존재하는 클래스는 'abstract'키워드를 붙여 '추상 클래스'로 만들어야 한다.
				ㅡ 인터페이스, Interface )
					ㄴ 비유하자면, 모든 메소드가 abstract인 추상 클래스와 유사하다고 보면된다.
						ㄴ 인터페이스를 구현하는 클래스는 인터페이스의 추상 메소드를 구현하거나 abstract class로 선언되어야 한다.
					ㄴ 일반적으로 구조, 틀, 형식같은것을 미리 정해두고 이에따라 개발을 하고 싶을때 사용한다.
					ㄴ 특징 )
						ㄴ 인터페이스 내에 존재하는 모든 멤버변수가 무조건 public static final로 선언되며
						ㄴ 인터페이스 내에 존재하는 모든 멤버메소드가 무조건 public abstract로 선언된다.
						ㄴ 근데 보통 명시적으로 써준다함.
					ㄴ 인터페이스도 참조변수의 '자료형'으로 사용이 가능하다.
					ㄴ 인터페이스 내의 메소드 호출시, 해당 메소드의 '오버라이딩' 내용이 적용된다.
					ㄴ 일반적으로 인터페이스는 public으로 선언하여 사용한다.
				ㅡ abstract 클래스 vs interface )
					ㄴ 유사해 보이지만, 추상클래스는 클래스이므로 상속 개념 안에서 쓰이고
						인터페이스는 단순히 특정 기능의 구현을 강제하기 위하여 쓰인다.
				ㅡ Inner 클래스 )
					ㄴ 클래스 안에 정의한 클래스를 말한다.
						ㄴ ex)
								class AAA{
									~~~
									class BBB{ ~~~ }
								}
					ㄴ 바깥쪽 클래스를 'outer class', 안쪽 클래스를 'inner class'라고 부른다.
					ㄴ inner class는 outer class의 멤버이기 때문에 outer class의 멤버들에 모두 접근 가능(접근제어자가 무엇이든)
					ㄴ inner class 자체에 접근하려면 outer class의 멤버이므로 outer class 객체를 하나 만들고 이 객체를 통하여 접근해야함.
						ㄴ ex )
							Outer outer = new Outer();
							Outer.Inner inner = outer.new Inner();
					ㄴ inner class에도 접근제어자 설정 가능.
						ㄴ 위 예시처럼 inner class 직접 사용이나 inner class 객체의 멤버들에 대한 접근에 적용되는 듯.
						ㄴ ex )
							class Outer{
								private Inner{
									public String name = "inner";
								}
								public Inner inner;
								Outer(){this.inner = new Inner();}
							}
							~~~
							Outer outer = new Outer();
							Outer.Inner inner = outer.new Inner();  // 좌변 'Outer.Inner'과 우변 new Inner()부분에 컴파일 에러.
							System.out.println(outer.inner);  // outer 객체 안에 들은 inner객체 사용. inner멤버변수는 public이라 문제없음.
							// outer객체 안에 들은 inner객체의 멤버에 접근시 오류. Inner class가 private라서.
							System.out.println(outer.inner.name);
					ㄴ inner class가 static 클래스로 선언되었을 경우 이를 'Nested class'라고 부른다.
					ㄴ 이점 )
						ㄴ 클래스들을 논리적으로 묶을 수 있다.
						ㄴ 따라서 가독성이 좋아지고
						ㄴ 캡슐화에 용이하다.
					ㄴ static nested class
						ㄴ static으로 선언된 inner class를 'static nested class'라 부름.
						ㄴ static 변수처럼, static nested class는 인스턴스 멤버에 접근 불가.
				ㅡ Local 클래스 )
					ㄴ 메소드 내에서 정의가 되고, 그 메소드 내에서만 '인스턴스의 생성'과 '참조변수의 선언'이 가능하다.
					ㄴ 일반적인 쓰임 )
						ㄴ 보통 인터페이스를 하나만들고 local class가 이 인터페이스를 구현하게 하고 local class를 생성하여 메소드에서 반환함으로서
							외부에서 local class를 참조할 수 있게한다.
						ㄴ ex)
							// 반환형을 인터페이스A로 하여 local class가 메소드에서 반환되면 이를 참조할 수 있게한다.
							public (*인터페이스A*) create~~~(){
								class LocalClass extends (*인터페이스A*) {	//local class가 인터페이스A를 구현하게한다.
									~~~
								}
								return new LocalClass();
							}
					ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~
				ㅡ 익명 클래스 )
					ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~
				ㅡ 예외 처리 )
					ㄴ try~catch문을 사용한다.
					ㄴ ex)
						try{
							~~~
						}
						catch(~~~){	//우선 확인할 예외.
							~~~
						}
						catch(~~~){	//위에 catch에 해당이 안되면 다음 catch.
							~~~
						}
						...
						finally{	//예외발생 여부와 상관없이 항상 마지막에 실행되는 영역.
							~~~
						}
					ㄴ throw 명령어 : 예외를 발생시키는 명령어. 해당 예외를 던진다.
						ㄴ ex)	throw (*예외객체*);
					ㄴ throws )
						ㄴ 메소드 선언 뒤에 적는 키워드.
						ㄴ 해당 메소드에서 특정 예외가 발생하면 이를 해당 메소드를 호출한 영역으로 던질것임을 나타낸다.
						ㄴ public static int readAge() throws AgeInputException { ~~~ }
					ㄴ 예외상황이 현재 예외가 발생한 메소드 내에서 처리되지 않으면 메소드를 호출한 영역으로 예외의 처리가 넘어감.
					ㄴ main메소드까지 예외가 넘어가고 main에서도 예외를 넘기면 main()을 호출한 JVM이 예외를 넘겨받게된다.
						ㄴ JVM은 다음의 과정으로 예외를 처리한다.
							1.예외의 getMessage()를 호출하고, 2.예외상황이 발생하여 전달되는 모든 과정을 출력하고, 3.프로그램을 종료한다.
					ㄴ Throwable클래스의 pringStackTrace() )
						ㄴ JVM처럼 예외의 getMessage()를 호출하여 출력해주고 예외상황이 발생하여 전달되는 모든 과정을 출력해준다.
					ㄴ 예외 클래스들 )
						ㄴ 예외 클래스의 계층 구조 )
							Throwable
								ㄴ Exception
									ㄴ 우리가 사용하는 대부분의 예외가 여기에 속한다.
									ㄴ ex) IOException, RuntimeException 등등..
								ㄴ Error
									ㄴ 심각한 오류상황을 표현하기위해 쓰이는 클래스.
									ㄴ 개발자가 정의하는것이 아니다.
				ㅡ JVM의 메모리 )
					ㄴ JVM은 os로부터 할당받은 메인메모리를 다음과 같이 분류하여 사용한다.
						ㄴ 메소드 영역
							ㄴ 메소드의 바이트코드, static변수
							ㄴ 클래스가 메모리에 올라갈때 이것들이 메소드영역에 저장이 된다.
						ㄴ 스택 영역
							ㄴ 지역변수, 매개변수
							ㄴ 알다시피 메소드 내에서만 유효한 변수들이며, 이들이 저장되는 공간이다.
						ㄴ 힙 영역
							ㄴ 인스턴스
							ㄴ 가비지 컬렉션, Garbage Collection )
								ㄴ 참조되지 않는 인스턴스는 소멸의 대상이되며 JVM에 의해 소멸되는데 이 기능을 말한다.
								ㄴ
					ㄴ finalize() : 인스턴스가 소멸될때, 소멸 직전에 자동으로 호출되는 메소드.
				ㅡ Wrapper 클래스 )
					ㄴ 기본 원시 자료형들을 '인스턴스' 형태로 표현하고자 할때 Wrapper클래스를 사용 할 수 있다.
						ㄴ Integer intInst = new Integer(3);	//int형 데이터 3을 Wrapper클래스 Integer를 통해 인스턴스형태로 표현하였다.
					ㄴ 종류 )
						ㄴ 모든 기본 자료형에 해당하는 Wrapper 클래스들이 존재한다.
							ㄴ Boolean, Character, Byte, Short, Integer, Long, Float, Double
						ㄴ 생성자로 String형을 받을 수 있어서, String으로 해당 자료형 Wrapper클래스를 생성할 수 있다.
					ㄴ 기본 자료형을 Wrapper클래스로 만드는것을 'Boxing', 그 반대를 'Unboxing' 이라한다.
						ㄴ auto Boxing, auto Unboxing : 자바에서 Wrapper클래스와 그에맞는 자료형들을 필요에따라서 자동으로 boxing, unboxing해주는 기능.
							ㄴ Wrapper클래스에 원시자료형을 넣거나, 그반대이거나, Wrapper클래스를 대상으로 연산을 하거나와 같은 상황에서 쓰인다.
							ㄴ ex)	Integer iValue=10;
								int num1 = iValue;
								iValue++;
				ㅡ Math 클래스 )
					ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				ㅡ Generic )
					ㄴ 클래스, 인터페이스에서 사용되는 자료형을 나중에 정의할 수 있게 해주는 기능.
						ㄴ 자료형을 파라미터처럼 설정할 수 있게해줌.
						ㄴ 하여, 같은 코드를 다른 타입에 대해 사용할 수있다.
					ㄴ ex)
						class FruitBox < T, U, ... > {	//이렇게 < T, U>로 선언해놓고 이후 인스턴스 생성시 T와 U부분을 정해주면
															클래스 내부의 T와 U부분이 그 자료형으로 정해진다.
							T item;
							public void store( T item ){~~~ }
							public U adslfkj(){~~~}
						}
						~~~
						FruitBox< Integer> box = new FruitBox< Integer>();
					ㄴ 인자로 받는 타입을 '타입 파라미터'라고 한다.
						ㄴ 그리고 엄밀히 따지면 이 '타입 파라미터'에 받아지는 타입을 '타입 argument'라 한다.
							ㄴ ex ) class FruitBox< T> 에서 T는 '타입 parameter',
									FruitBox< Integer> box 에서 Integer은 '타입 argument'
						ㄴ 명명 관례는 하나의 대문자. ex ) T, V
					ㄴ 'FruitBox< Integer>'와 같이 제네릭 타입이 지정된 것을 'parameterized type'이라 한다.
					ㄴ 당연히 T, U부분은 모든 자료형에 대해서 실행하는데 오류가 없도록 구현되어야 한다.
					ㄴ 제네릭 부분에 원시타입은 올 수 없다. class, interface, array, 또 다른 타입 변수만 가능하다.
						ㄴ 또 다른 'parameterized type'도 가능하다.
							ㄴ ex ) FruitBox< Integer, Box< Integer> > box = ~~~
					ㄴ Type Inference
						ㄴ 제네릭 클래스의 생성자 호출시 넘기는 타입 argument를 비워둠으로서 ( ex) new FruitBox<>(); )
							제네릭 타입 지정을 미룰 수 있다.
						ㄴ ~~~
					ㄴ ~~~ https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html 부터 참조.

					ㄴ 제네릭 메소드 )
						ㄴ 특정 메소드에만 제네릭을 적용할 수 잇다.
						ㄴ ex)	public < T> void showInstType( T inst ) {~~~}//이처럼 접근제어지시자 뒤에 제네릭타입을 선언하여
																				'제네릭 메소드'를 만들 수 있다.
							~~~
							< Integer>showInstType(123);
					ㄴ 제네릭 자료형에 대한 제한 )
						ㄴ T 뒤에다가 'extends (*클래스*)' 를 붙이면 해당 클래스를 상속하는 클래스만 T부분에 올수 있도록 제한하게 된다.
						ㄴ 'super'를 붙이면 해당 클래스의 조상 클래스만 올 수 있다.
						ㄴ ex)
							class Child < T extends Parent > { ~~~ }
							class Child < T super Child >{~~~ }
					ㄴ 제네릭 형태의 배열을 사용하려면 T[] 형식으로 표기하면 된다. ex)	public < T> void aaa( T[] arr ){~~~}
					ㄴ 와일드 카드 '?' )
						ㄴ 제네릭을 정의하는게 아닌 사용하는 부분에서 T부분에 입력하는 자료형에 제한을 두는 방법.
						ㄴ 와일드카드 '?'를 쓰고, 위에서 제네릭 자료형 제한한것과 똑같이 'extends'나 'super'를 붙여 제한한다.
						ㄴ ex)	Child< ? extends Parents > x = new Child< (*Parrents를 상속하는 자료형*) > () ;
					ㄴ 인터페이스도 제네릭을 사용 할 수 있다.
					ㄴ 기본 자료형들은 제네릭에 사용될 수 없다.
				ㅡ 컬렉션 프레임워크 )<button>펼치기</button>
				<pre>
					ㄴ 기본
						ㄴ 데이터의 저장, 그리고 이와 관련있는 알고리즘을 미리 만들어놓은 것.
						ㄴ java_전체컬렉션.jpg 참조
						<img src="image/java_전체컬렉션.jpg"/>
					ㄴ 컬렉션들
						ㄴ Collection< E >
							ㄴ '인스턴스'만이 저장의 대상이다.
							ㄴ List < E >
								ㄴ 자료구조 '리스트'를 생각하면 될듯하다.
								ㄴ ArrayList < E > : '배열'을 이용한 '리스트'형식
									ㄴ 특징 )
										ㄴ 저장 용량을 늘리는 과정이 오래걸림.
										ㄴ 삭제 연산이 오래걸림
										ㄴ 데이터의 참조가 빠름.
								ㄴ LinkedList < E > : 흔히 알고있는 LinkedList를 말한다. 노드안에 값과 다음노드를 가리키는 프로퍼티를 가지고
													이 녿들이 쭉 연결된 형태.
									ㄴ 특징 )
										ㄴ 저장소 용량 늘리는 과정이 빠름.
										ㄴ 삭제연산이 빠름.
										ㄴ 데이터의 참조가 느림.
								* Iterator < E>
									ㅡ Collection < E> 인터페이스에 제공되는 인터페이스.
									ㅡ 컬렉션 내의 요소들에 대해 반복을 할때 쓰인다.
									ㅡ 사용법 )
										ㄴ 컬렉션 인스턴스에서 iterator()를 호출하면 해당 컬렉션 인스턴스에 대한 Iterator가 반환된다.
										ㄴ 이 Iterator객체를 가지고 여기에 들은 메소드들을 사용해 반복을 하면된다.
									ㅡ 메소드들 )
										ㄴ boolean hasNext() : 남아있는 요소가 있는지 확인한다.
										ㄴ E next() : 다음 차례의 요소를 반환한다.
										ㄴ void remove() : 바로 직전에 next()로 반환된 요소를 삭제.
							* sort() )
								ㅡ List< E>나 Arrays 클래스에 대해 내부 요소들을 정렬하는 sort()를 호출 할 수 있다.
									ㄴ Collections 인터페이스, List< E> 인터페이스, Arrays 클래스 안에 sort()메소드가 여러 형태로 정의되어있다.
									ㄴ Arrays 클래스의 public static void sort ( Object[] a ),
										public static < T> void sort ( T[] a, Comparator< ? super T> c)
									ㄴ Collections 인터페이스의 'public static < T extends Comparable< ? super T>> void sort​(List< T> list)',
										public static < T> void sort​(List< T> list, Comparator< ? super T> c)
									ㄴ List< E>의 default void sort​(Comparator< ? super E> c)
									* Collections 인터페이스 : 자바 컬렉션을 반환하거나 이와 관련된 연산을 해주는 static 메소드들이 정의되어있는 인터페이스.
								ㅡ natural ordering : 정렬되는 기준, 순서를 말하는 듯 하다.
								ㅡ Comparable < T>, Comparator < T> )
									ㄴ sort()호출시, 내부적으로 어떤 기준으로 정렬이 될지 설정을 해주는 인터페이스들이다.
									ㄴ Comparable < T> )
										ㄴ '정렬의 대상'이 되는 객체에 구현하여 'public int compareTo( T obj)'를 구현하여 정렬기준을 설정한다.
										ㄴ public int compareTo ( T obj ) )
											ㄴ obj가 더 크다면 음수, 작다면 양수, 같다면 0을 반환함으로서 기준 설정.
											ㄴ 작다고 판단된것이 앞에오는 식으로 정렬이 된다.
										ㄴ 대부분의 기본 Wrapper 클래스들은 이미 구현이 되어있다. (Integer, Byte, Boolean, ..., File, String, Date, CollationKey 등)
										ㄴ 이게 구현되어있지 않은 객체에 대해 sort()호출시 ClassCastException 이 발생한다.
										ㄴ 사용법 )
											ㄴ Arrays 클래스의 public static void sort ( Object[] a )
											ㄴ Collections 인터페이스의 public static < T extends Comparable< ? super T>> void sort​(List< T> list)
											ㄴ ??????????????????? List< E>의 default void sort​(Comparator< ? super E> c)
												ㄴ 인자로 Comparator를 받기는 하는데 null일경우 Comparable< T>를 사용하여 정렬한다는데 실습안해봐서 정확치않음.
									ㄴ Comparator < T> )
										ㄴ Comparable < T>를 구현하지 않는 객체를 정렬하거나, 이미 natural ordering이 정의된 객체를 다른 방식으로 정렬하고자 할때 사용할수 있는 인터페이스이다.
										ㄴ 사용법 )
											ㄴ Comparator < T>를 구현하는 객체를 만든뒤, int compare( T obj1, T obj2 )를 구현.
											ㄴ sort()호출시 정렬하려는 컬렉션과 함께 인자로 넘기면, Comparator< T>에 정의된 방법에 따라 정렬이 된다.
										ㄴ 메소드 )
											ㄴ int compare( T obj1, T obj2 ) : 두 객체간 크기비교를하는 메소드. obj1이 더 작으면 음수, 같으면 0, 아니면 양수 반환.
												ㄴ 작다고 판단된것이 앞에오는 식으로 정렬이 된다.
											ㄴ boolean equals( Object obj ) : ~~~~~~~~~~~
							ㄴ Set < E >
								ㄴ '집합'과 유사한 컬렉션. List < E>와 달리, '중복'을 허용하지 않고 '저장 순서'를 유지하지 않는 컬렉션이다.
								ㄴ 값을 저장할때 컬렉션을 탐색하여 중복을 체크한다음 저장한다.
								ㄴ HashSet < E >
									ㄴ 중복체크 )
										ㄴ 1차적으로 Object클래스의 hashCode()를 이용해 해쉬값을 확인
										ㄴ 해당 해쉬값에 속하는 요소들 중에서 Object클래스의 equals()를 이용해 중복이 있는지를 확인
									ㄴ 중복체크가 제대로 이루어지도록 하려면 Object클래스의 hashCode()와 equals()를 적절하게 오버라이딩해야한다.
								ㄴ TreeSet < E >
									ㄴ 기본 개념
										ㄴ 자료구조 '트리'를 기반으로하는 컬렉션.
										ㄴ 데이터를 '정렬'된 상태로 저장한다.
										ㄴ 저장하려는 인스턴스가 Comparable < T> 인터페이스를 구현하여 정렬의 기준이 정의되어 있어야 한다.
									ㄴ 정렬 방식정의 방법1
										ㄴ 위에 설명한대로 저장 대상인 클래스가 Comparable < T>인터페이스를 구현하게하여 정렬의 기준을 설정하는 방법이 있다.
									ㄴ 정렬 방식정의 방법2
										ㄴ 'Comparator 인터페이스'를 구현하는 클래스를 만들고 이 안에 int compare( T obj1, T obj2 )를 구현하여
											이 클래스를 TreeSet 생성자의 인자로 넘기는 방법.
							ㄴ Queue < E> 인터페이스 )
								ㄴ 자료구조 '큐'를 나타내는 인터페이스.
								ㄴ 주요 메소드 )
									ㄴ 삽입, 삭제, 탐색 기능의 메소드가 각각 두가지 형태로 존재한다.
										ㄴ 하나는 실패시 '예외'를 던지는 형태, 또하나는 실패시 정해진 값을 반환하는 형태(null이나 false등)
									ㄴ 예외 던지는 형태의 메소드 )
										ㄴ add (e) : FIFO 규칙대로 큐에 값을 넣는다. 큐의 capacity를 초과하면 실패. 실패시 예외 발생
										ㄴ remove() : 큐의 head를 반환하고 삭제한다. 큐가 비어있으면 예외발생.
										ㄴ element() : 큐의 head를 반환하기만 한다. 큐가 비어있으면 예외발생.
									ㄴ 정해진 값을 반환하는 형태 )
										ㄴ offer (e) : add()와 동일실패시 false 반환.
										ㄴ poll() : 큐가 비었을경우를 제외하면 remove()와 똑같이 동작한다. 큐가 비어있으면 null반환.
										ㄴ peek() : 큐가 비었을경우를 제외하면 element()와 똑같이 동작한다. 큐가 비어있으면 null반환.
								ㄴ Deque < E> )
									ㄴ 'deck'이라고도 알려진 'double-ended-queue'.
									ㄴ 양쪽 끝지점에서 삽입과 삭제가 모두 가능한 큐.
									ㄴ 따라서 스택으로도, 큐로도 사용 할 수 있다.
									ㄴ 메소드 )
										ㄴ addFirst(), offerFirst() : Deque의 head부분에 삽입을 한다.
										ㄴ addLast(), offerLast() : Deque의 tail부분에 삽입을 한다.
										ㄴ removeFirst(), pollFirst() : Deque의 head부분의 요소를 반환하고 삭제한다.
										ㄴ removeLast(), pollLast() : Deque의 tail부분의 요소를 반환하고 삭제한다.
										ㄴ getFirst(), peekFirst() : Deque의 head부분의 요소를 반환한다.
										ㄴ getLast(), peekLast() : Deque의 tail부분의 요소를 반환만한다.
										ㄴ 앞쪽에 적은 add**, remove**, get** 식의 이름을가진 메소드는 실패시 예외를 던지고 아닌것들은 실패시 정해진값을 반환한다. 										ㄴ ~~~~~
								ㄴ PriorityQueue < E> )
									ㄴ 우선순위 '힙'을 기반으로한 queue.
									ㄴ 요소들의 'natural ordering'에 따라서 요소들이 정렬이 되거나, PriorityQueeu생성자 인자로 전달된 Comparator < E>에 의해 정렬이 된다.
										ㄴ 'natural ordering'에 의해 정렬되는 PriorityQueue는 Comparable< E>를 구현하지 않는 객체를 요소로 받아들이지 않는다.
										ㄴ ???????우선순위가 동일하다면 알파벳순으로 정렬된다한다.
									ㄴ null요소를 허용하지 않는다.
									ㄴ '동기화'되지 않았다.
									ㄴ 메소드 )
										ㄴ add(E e)
										ㄴ offer ( E e)
										ㄴ peek()
										ㄴ poll()
										ㄴ remove( Object o )
						ㄴ Map< K, V >
							ㄴ key와 value형태로 데이터를 저장하는 컬렉션.
							ㄴ HashMap < K, V>
								ㄴ 특징 )
									ㄴ value에 상관없이 중복된 key의 저장은 불가능하다. 즉, key가 다르면 value는 같을 수 있다.
									ㄴ HashSet< E>과 마찬가지로 '해쉬' 기반으로 만들어져 빠른 검색속도를 가진다.
							ㄴ TreeMap < K, V>
								ㄴ TreeSet< E>과 마찬가지로 자료구조 'tree'를 기반으로 만들어져 데이터가 '정렬'된 상태로 저장된다.
									ㄴ 정렬은 'key'에 대한 정렬이다.
								ㄴ navigableKeySet()을 통해 Collection< E>의 Iterator< E>와 비슷한 반복 기능을 하는 NavigableSet< E>인터페이스를 얻을 수 있따.
					ㄴ 기본 제공 알고리즘 )
						ㄴ https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html 참조
						ㄴ 자바에서 기본적으로 제공하고 있는 알고리즘에 대해 배운다.
						ㄴ Sorting, Shuffling, Routine Data Manipulation, Searching, Composition, Finding Extreme Values가 잇으며,
							모두 Collections 인터페이스에 메소드로 제공되고 있다.
						ㄴ Sorting, 정렬 )
							ㄴ Collections.sort() 메소드를 이용한다.
							ㄴ List 인터페이스를 대상으로 동작한다. (근데 Arrays 클래스를 통해 배열에서도 가능하다)
							ㄴ 내부적으로 '합병 정렬'을 사용한다.
								ㄴ  O(n) = n * log (n)
							ㄴ 위에 Collection< E> 항목의 *sort()에서 다룬 내용과 일치한다.
						ㄴ Shuffling )
							ㄴ Collection.shuffle() 메소드를 이용한다.
							ㄴ sorting과 정반대의 기능. 'List'의 정렬을 흐트러뜨린다.
							ㄴ ~~~~~~~~
						ㄴ Routine Data Manipulation )
						ㄴ Searching )
							ㄴ Collections.binarySearch() 메소드 이용
								ㄴ public static < T> int binarySearch(List< ? extends Comparable< ? super T>> list, T key)
									ㄴ List가 요소의 'natural ordering'에 따라 정렬되어ㅣㅇㅆ다고 가정하고 탐색한다.
								ㄴ public static < T> int binarySearch(List< ? extends T> list, T key,  Comparator< ? super T> c)
									ㄴ List가 인자로 넘어간 Comparator에 따라 정렬되어있다고 가정하고 탐색한다.
							ㄴ 정렬된 List에 대하여 '이진 탐색'을 실행한다.
						ㄴ Composition )
						ㄴ Finding Extreme Values )
				</pre>
			</pre>

			ㅇ 가비지 컬렉션, Garbage collector
				ㅡ 자바 실행환경이 객체에 대한 메모리 관리를 자동으로 해줌.
					ㄴ 더이상 참조되지 않는 객체인 경우, (즉, 특정 객체에 대한 참조값이 아무 변수에 할당되지 않는 상태이면)
						'가비지 컬렉터'가 해당 객체를 삭제하여 차지하고 있던 메모리를 비운다.

			ㅇ 쓰레드와 동기화 <button>펼치기</button>
			<pre>
				ㄴ 쓰레드 기초
					* 프로세스  : os로부터 메모리를 할당받아 실행중에 있는 프로그램.
					ㄴ 쓰레드란 ?
						ㄴ 하나의 프로세스 내에 있는 '프로그램의 흐름'
						ㄴ 하나 이상이 존재 할 수 있다.
					ㄴ 사용법 )
						ㄴ Thread 클래스 상속 )
							ㄴ 'Thread' 클래스를 상속하고 public void run()을 구현하고 이 상속클래스에서 start()를 호출함으로서 새로운 스레드를 실행시킬 수 있다.
								ㄴ public void run()은 Thread에게 main메소드와 같다. 이 메소드의 바디를 구현하여 스레드가 어떤 작업을 할지 결정할 수 있다.
							* Thread 클래스
								ㅡ ~~~
								ㅡ 필드 )
									ㄴ MAX_PRIORITY : 가질 수 있는 최대 우선순위
									ㄴ MIN_PRIORITY : 가질 수 있는 최소 우선순위
									ㄴ NORM_PRIORITY : 디폴트 우선순위.
								ㅡ 메소드 )
									ㄴ ~~~
									ㄴ void join() : 현재 스레드(join()을 호출하는 스레드)가 끝날때까지 (이명령을 실행하는 스레드를) wait시키는 명령어.
									ㄴ int getPriority() : 스레드의 우선순위를 반환
									ㄴ void setPriority( int priority ) : 스레드의 우선순위를 변경
						ㄴ 'Runnable' 인터페이스 구현 )
							* Runnable 인터페이스
								ㅡ 스레드에 의해 실행될 인스턴스가 구현하는 인터페이스이다.
								ㅡ run()을 구현해야 한다.
								ㅡ Thread 클래스가 구현하고있는 인터페이스이다.
								ㅡ 이를 이용하면 Thread클래스를 상속하지 않고도 구현하는 인스턴스를 스레드로 실행시킬 수 있다.
									ㄴ 인터페이스를 구현하고 run()을 구현하고 인스턴스를 Thread 클래스 생성자의 인자로 넘긴다음 Thread 인스턴스의 start()를 호출하면 Runnable을 구현한 클래스의 run()부분이 새로운 스레드에 의해 실행된다.

				ㄴ 스레드 특징
					ㄴ 우선순위와 스케줄링
						ㄴ 여러 스레드가 동시에 실행될 수 있기때문에 JVM은 스레드의 실행을 '스케줄링'해야 한다.
						ㄴ 스케줄링 원칙 )
							ㄴ 우선순위가 높은 스레드의 실행을 우선한다. 우선순위가 높은게 끝나야 다음우선순위가 실행 될 수 있다.
							ㄴ 우선순위가 동일하면 CPU의 할당시간을 분배하여 실행한다. (조금씩 번갈아가면서 실행되는 식이다)
						ㄴ Thread 클래스의 getPriority(), setPriority() 등을 통해 우선순위를 다룰 수 있다.
						ㄴ 주의 )
							ㄴ 자바차원에서 스레드 스케줄링을 조금 다룰 수 있게 되어있으나, 스레드는 실질적으로 os에 상당히 의존적이므로 결과에 변수가 있다고 한다.
							ㄴ 또한 스레드가 CPU를 필요로 하지 않는 입출력 연산 등을 할때, 자신의 우선순위가 높더라도 CPU를 양보해 낮은순위가 먼저 실행될 수도 있다.
					ㄴ 라이프 사이클
						ㄴ 스레드의 상태 )
							ㄴ New 상태 )
								ㄴ 스레드 클래스가 new를 통해 인스턴스화된 상태를 말한다.
								ㄴ JVM에 의해 관리되고 있는 상태는 아니다.
								ㄴ os상으로는 스레드라고 볼 수 없으나 자바상에선 이 시점부터 스레드라고 부른다.
							ㄴ Runnable 상태 )
								ㄴ 스레드 인스턴스에서 start()가 호출되면 들어가는 상태.
								ㄴ 이 상태에 들어가면 스케줄러에 의해 선택을 기다리게되며, 선택되면 run()을 실행한다.
							ㄴ Blocked 상태 )
								ㄴ 스레드에서 sleep(), join()을 호출하거나 입출력 연산등을 하여 CPU가 필요없어지면 CPU를 다른스레드에게 양보하고 본인은 'blocked'상태가 된다.
								ㄴ 이 상태에서는 스케줄러에 의해 선택받을 수 없다.
								ㄴ Blocked상태가 된 원인이 해결되면 다시 Runnable상태로 돌아간다.
							ㄴ Dead 상태 )
								ㄴ run()의 실행이 완료되어 run()을 빠져나오게 되면 'Dead'상태가 된다.
								ㄴ 스레드에 할당받았던 메모리나 각종 스레드 관련 정보가 삭제된다.
								ㄴ 다시 다른 상태가 될 수 없으면 그냥 스레드가 완전히 끝난다.
					ㄴ 메모리 구성
						ㄴ 스레드는 별도의 흐름을 만드는 것이기때문에 별도의 메모리가 필요하다.
						ㄴ 메모리 영역 중, '스택'영역만 별도로 할당되고, '메소드 영역', '힙 영역'은 main스레드와 공유된다.
							ㄴ 따라서 힙 영역의데이터를 이용해 스레드간에 데이터 교환이 가능하다.
				ㄴ 동기화
					ㄴ 동시접근 방지
						ㄴ 동기화의 필요성
							ㄴ 스레드 간에 메모리에서 '힙 영역'을 공유하기때문에 하나의 힙 영역 데이터에 둘 이상의 스레드가 동시에 접근하는 문제가 발생한다. 이를 해결하기 위해 '동기화'가 필요하다.
							ㄴ 동기화란? ) 한 스레드가 특정 데이터에 접근하는 동안 다른 스레드가 그 데이터에 접근하지 못하게 하는 것.
							* Thread - safe : 동기화 처리가 되어있다는 의미.
						ㄴ 동기화 방법1 : 동기화 메소드 )
							ㄴ 메소드에 'synchronized' 키워드를 붙여서 동기화.
							ㄴ 'synchronized'키워드가 붙은 메소드들 전체에 'lock'이 걸린다. 따라서 한 스레드가 'synchronized'가 붙은 메소드들중 하나를 호출하면 나머지 'synchronized'가붙은 메소드들이 전부 호출이 불가하게 된다.
							ㄴ lock의 범위가 매우 크기때문에 실행시간이 많이 늘어난다.
							ㄴ ex) public synchronized int add(int num){ ~~~ }
						ㄴ 동기화 방법2 : 동기화 블럭 )
							ㄴ 'synchronized()'블록을 씌워 해당 블록에 대해 lock을 건다.
							ㄴ ex)	public int add(int num){
									synchronized( (*key로서 사용할 아무 인스턴스의 참조값*) ){
										~~thread-safe해야하는 작업~~
									}
								}
							ㄴ 같은 'key'를 사용하고있는 '동기화 블록'끼리 묶여서 lock이 걸린다.
						ㄴ 동기화 방법3 : ReentrantLock 클래스 )
							ㄴ ReentrantLock 클래스의 lock(), unlock() 메소드를 통해 lock을 걸 수 있게해주는 클래스이다.
								ㄴ lock()이 호출된 부분부터 unlock()이 호출되는 부분까지 lock이 걸린다.
							ㄴ ex) 	private final ReentrantLock aaa = new ReentrantLock();
								~~~
								aaa.lock();
								~~~		//lock()부터 unlock()사이인 이부분을 실행할때 다른 스레드가 접근하지 못한다.
								aaa.unlock();

					ㄴ 순서 보장
						ㄴ 필요성
							ㄴ 스레드의 실행순서는 소스코드상의 순서와 같지 않다. 어떤 순서대로 실행될지 확실하게 알 수 있는 방법이 없다.
							ㄴ 따라서 여러가지 방법으로 실행순서를 보장해야 한다.
						ㄴ 방법1 : wait, notify, notifyAll )
							ㄴ 아래의 메소드들을 사용하여 실행순서를 보장한다.
							ㄴ 메소드들 )
								ㄴ public final void wait() throws InterruptedException : 스레드를 잠시 정지시킨다.
								ㄴ public fianl void nofity() : 하나의 스레드를 깨움.
								ㄴ publi final void notifyAll() : 모든 스레드를 깨움.
							ㄴ Object의 메소드들이다.
							ㄴ 위 세 메소드들은 동시에 실행되지 않도록 동기화처리 해야한다.
							ㄴ wait()는 동기화 처리가 되어있어도 스레드가 잠드는 순간 lock을 푼다.
						ㄴ 방법2 : await, signal, siganlAll )
							ㄴ ReentrantLock 인스턴스의 newCondition()호출시 Condition 인터페이스형 인스턴스가 반환되고 이것의 다음 메소드들을 통하여 실행순서를 보장할 수 있다.
							ㄴ 메소드들 )
								ㄴ await : 스레드를 잠시 정지시킨다.
								ㄴ signal : 하나의 스레드를 깨운다.
								ㄴ signalAll : 모든 스레드를 깨운다.
							ㄴ 나머지는 방법1과 같다.
			</pre>
			ㅇ 파일과 I/O 스트림 <button>펼치기</button>
			<pre>
				ㄴ 여기서 설명하는 주요 클래스들은 java.io 패키지에 들어있다.
				ㄴ 자바에서는 입출력 대상에 상관없이 입출력의 '기본적인 방식'이 동일하도록 별도의 'I/O 모델'이 마련되어잇다.
					ㄴ '기본적인 방식'이 동일할 뿐, 입출력 대상에 따라 사용하는 클래스나 메소드들은 다르다.
					* 자바에서 네트워크와 관련된 I/O 클래스들이 특히 훌륭하다고 한다.
				ㄴ 스트림의 이해와 입출력 스트림 )
					ㄴ 스트림 이란? ) 데이터의 흐름, 데이터의 흐름을 형성하는 통로를 의미한다.
					ㄴ 스트림의 종류 )
						ㄴ 입력 스트림 : 외부에서부터 프로그램으로 데이터를 읽어들이는 스트림
						ㄴ 출력 스트림 : 프로그램에서 외부로 데이터를 내보내는 스트림.
					ㄴ 아주 간단한 사용법 )
						ㄴ 관련 인스턴스의 생성을 통해 스트림을 형성할 수 있다.
						ㄴ 입력 스트림 )
							ㄴ ex)	InputStream in = new FileInputStream("run.exe");	//스트림 클래스인 FileInputStream을 생성하여 입력스트림을 생성하였다.
							ㄴ 파일 run.exe에 저장되어있는 데이터를 읽어들이는 스트림이 형성된것.
							ㄴ FileInputStream클래스의 메소드들로 데이터를 읽어들이면 된다.
							ㄴ 스트림을 사용하고 나면 생성했던 스트림을 소멸시켜야 한다.
							* InputStream 추상 클래스
								ㅡ 모든 입력 스트림 클래스들이 상속하는 최상위 클래스이다.
								ㅡ 바이트 단위로 데이터를 읽어들인다.
								ㅡ 대표적 메소드 )
									ㄴ public abstract int read() throws IOException )
										ㄴ 1바이트의 데이터를 읽어서 반환하는 메소드.
										ㄴ 입출력 대상에 따라 데이터를 읽어들이는 방식이 같을수가 없기때문에, 각 입출력 대상에 해당하는 입출력 클래스들에서 구현하도록하기위해 추상메소드이다.
										ㄴ 더이상 읽어들일 데이터가 존재하지 않으면 -1을 반환.
									ㄴ public int read ( byte[] b, int offset, int len ) throws IOException )
										ㄴ 내부적으로 read()를 반복호출하여 입출력 대상으로부터 len만큼의 바이트를 읽어들여 b의 offset위치에서부터 저장한다.
										ㄴ b는 한꺼번에 여러바이트의 데이터를 읽어오기위한 '버퍼'의 역할을 한다.
									ㄴ public void close() throws IOException )
										ㄴ 해당 스트림을 소멸시킨다.
						ㄴ 출력 스트림 )
							ㄴ 입력 스트림과유사하다.
							ㄴ ex) OutputStream out = new FileOutputStream("home.bin");
							* OutputStream 추상클래스
								ㅡ InputStream 클래스와 유사.
								ㅡ 주요 메소드 )
									ㄴ public abstract void write(int b) throws IOException )
										ㄴ InputStream의 read()와 유사하다.
										ㄴ 인자로 전달된 데이터의 '1바이트'를 출력스트림을 통해 내보낸다.
											ㄴ 1바이트 이상의 크기의 데이터가 인자로 넘어오면 하위 비트에서 1바이트만큼을 끊어서 내보낸다.
									ㄴ public void close() throws IOException )
				ㄴ 필터 스트림
					ㄴ 필터 스트림이란 ? )
						ㄴ 스트림을 통해 읽힌 데이터의 형태를 다양하게 조작하게 해주는 '스트림'의 일종.
						ㄴ 그 자체로 입출력 대상으로부터 데이터를 직접 읽어오는 기능은 없다.
						ㄴ 필터 스트림들은 FilterInputStream, FilterOutputStream을 상속한다.
					ㄴ Data 스트림 )
						ㄴ 데이터의 기본 자료형에 대한 변환을 도와주는 '필터 스트림'
						ㄴ 클래스 ) DataInputStream, DataOutputStream
						ㄴ 사용 )
							ㄴ ex) 	OutputStream out = new FileOutputStream("data.bin");
								DataOutputStream filterOut = new DataOutputStream(out);	//이렇게 필터스트림의 생성자로 입출력 스트림 인스턴스를 넘겨주어 해당 입출력 스트림에 대한 필터를 장착한다.
								filterOut.writeInt(275);	//정수형 자료형을 write하면 필터 스트림에 의해 자동으로 정수형 데이터가 바이트형으로 변환되어 넘어간다.
								filterOut.writeDouble(2.23);
					ㄴ Buffered 스트림 )
						ㄴ '버퍼'기능을 제공해주는 '필터 스트림'
						ㄴ 동작 방식 )
							ㄴ 내부적으로 '버퍼'(byte형 배열)를 가지고 있다.
							ㄴ read()의 호출과 상관없이  입출력 대상으로부터 데이터를 읽어와 항상 '버퍼'를 채워놓는다. 이후 read()호출시 버퍼로부터 데이터를 준다.
							ㄴ 출력 버퍼 스트림 사용시, 버퍼에 프로그램으로부터 write()한 데이터가 가득 차기전까지는 write작업을 하지 않다가 다 차면 한꺼번에 보낸다.
						ㄴ 클래스 ) BufferedInputStream, BufferedOutputStream
						* flush()
							ㅡ OutputStream을 버퍼와같이 사용하는 경우, 컴퓨터의 오류 등으로 인해 버퍼에 있는 데이터가 write되지 못하고 프로그램이 갑자기 종료되거나 하면 그 데이터는 그냥 날아가게된다. 이를 방지하기 위한 OutputStream과 관련된 클래스들의 메소드이다.
							ㅡ 호출시 버퍼에 남아있는 데이터를 바로 write한다.
					ㄴ 필터의 조합 )
						ㄴ 여러가지 필터를 다 붙여서 사용할 수 있으나 순서에 주의해야 한다.
						ㄴ ex)	OutputStream out = new FileOutputStream("data.bin");
							BufferedOutputStream bufFilterOut = new BufferedOutputStream(out);
							DataOutputStream dataFilterOut = new DataOutputStream(bufFilterOut);
							ㄴ 이경우, Program -> (Data 필터 스트림) -> (버퍼 필터 스트림) -> (파일 스트림) -> (입출력 대상) 의 순서이다.
							ㄴ 기본자료형으로 프로그램에서 넘겨주면 데이터 필터가 바이트형식으로 바꾸고 이를 버퍼 필터가 받아서 write하면 되는 아무ㅜ 문제없는 상황이다.
							ㄴ 근데 만약 데이터필터와 버퍼 필터의순서가 바뀐다면, Program -> (버퍼 필터 스트림) -> (Data 필터 스트림) -> (파일 스트림) -> (입출력 대상) 이된다.
							ㄴ 프로그램으로부터 기본자료형이 넘어오면 이걸 그냥 바이트로 취급하여 버퍼 필터가 데이터 필터에게 전해주고 데이터 필터는 기본자료형이 아닌 바이트 데이터를 받게된다.
					ㄴ 가장 마지막에 연결된 필터 스트림을 종료하면 연결된 모든 스트림들이 종료된다.
				ㄴ 문자 스트림 )
					ㄴ 문자스트림의 이해 )
						ㄴ os의 인코딩 방식에 맞게 자동으로 문자를 인코딩하여 read, write해주는 스트림.
							ㄴ 프로그램상에서 'A'를 '문자스트림'을 통해 write하면 문자 'A'를 os의 인코딩방식에 맞게 인코딩하여 파일에 write해주는 식. (자바에서 'A'는 char형 2바이트이지만 window os상에선 'A'는 1바이트를 차지한다. 따라서 window os상의 인코딩방식대로 1바이트가 저장된다)
							ㄴ read는 그 반대.
						ㄴ 클래스 ) Reader, Writer 추상클래스.
							ㄴ InputStream, OutputStream과 상속관계가 없는 클래스이다.
							ㄴ Reader는 InputStream에 대응하고 Writer는 OutputStream에 대응한다.
							ㄴ 문자 스트림에서 파일을 대상으로 하는 입출력 스트림은 FileReader, FileWriter이다.
								ㄴ 이런식으로 InputStream과 OutputStream과 거의 유사.
							ㄴ 주요메소드도 다 비슷하다 )
								ㄴ Reader의 주요메소드 )
									ㄴ public int read() throws IOException : 문자 하나를 읽어들여 반환.
									ㄴ public abstract int read ( char[] cbuf, int offset, int len ) throws IOException : len만큼의 문자를 읽어들여 cbuf의 offset부분부터 저장.
								ㄴ Writer의 주요메소드 )
									ㄴ public void write( int c ) throws IOException )
										ㄴ 문자 하나를 write.
										ㄴ 자바에선 문자하나가 2바이트이므로 int형 인자에서 뒤에 2바이트만 잘라서 write한다.
									ㄴ public abstract void write ( char[] cbuf, int offset, int len ) throws IOException : ~~~~~~~
					ㄴ 사용법 ) InputStream, OutputStream과 유사하다.
					ㄴ Buffered 문자 스트림 )
						ㄴ BufferedReader, BufferedWriter
							ㄴ BufferedInputStream, BufferedOutputStream에 대응한다.
						ㄴ 주요 메소드 )
							ㄴ BufferedReader의 public String readLine() throws IOException )
								ㄴ '개행'을 기준으로  '개행'이 나오기 전가지의 문자열 데이터를 읽어들인다.
									ㄴ '개행' 데이터는 읽어오지 않는다.
								ㄴ 더이상 없으면 null반환.
							ㄴ BufferedWriter의 public void write(String str) throws IOException
							ㄴ BufferedWriter의 newLine() )
								ㄴ '개행정보'를 write한다.
								ㄴ os마다 '개행'을 표현하는 방식이 다르기때문에 따로 만들어졌다고함.
					ㄴ PrintWriter )
						ㄴ '문자 스트림' Writer의 하위 클래스. 문자 출력 스트림 기능을 한다.
						ㄴ PrintStream과의 관계 )
							ㄴ System.out은 OutputStream을 구현하는 PrintStream 객체이다. (OutputStream은  '바이트 스트림'이다)
							ㄴ '문자 스트림'인 PrintWriter가 있지만 이미 PrintStream이 System.out.println()으로 널리쓰이고있다.
							ㄴ 따라서 System.out을 사용하는것 외에는 이왕이면 PrintWriter를 사용하라고 함.
				ㄴ 오브젝트 스트림 )
					ㄴ 자바의 인스턴스를 통째로 입출력 할 수 있게 해주는 스트림.
					ㄴ 클래스 ) ObjectInputStream, ObjectOutputStream
						ㄴ InputStream, OuputStream을 상속하기에 엄밀히따지면 '바이트 스트림'에 속하지만, 일반적으로는 그냥 '오브젝트 스트림'으로 분류한다고 한다.
						ㄴ 또한 사용방법이 '필터 스트림'과 유사하지만 '필터스트림'은 아니다.
					ㄴ 주요 메소드 )
						ㄴ public final void writeObject ( Object obj ) throws IOException : 인스턴스를 파일에 저장한다.
						ㄴ public final Object readObject() throws IOException, ClassNotFoundException : 파일로부터 인스턴스를 읽어온다.
					ㄴ 입출력의 대상이 되는 인스턴스의 클래스는 java.io.Serializable 인터페이스를 '직, 간접적'으로 구현해야 한다.
						* Serializable 인터페이스
							ㅡ 해당 클래스의 인스턴스가 직렬화를 해도 괜찮다는걸 표시하는 용도의 인터페이스이다.
							ㅡ 단순히 표시기능이기때문에 추가적으로 구현해야할 메소드가 존재하지 않는다.
					ㄴ 직렬화 : 인스턴스가 파일에 저장되는 과정을 말한다. 반대과정은 '역직렬화'라 한다.
						ㄴ 직렬화되는 인스턴스의 멤버변수가 참조하는 인스턴스도 Serializable이 직간접적으로 구현되어있다면 함께 직렬화된다.
							ㄴ 인스턴스를 참조하는 멤버변수 앞에 'transient' 키워드를 붙이면 함께 직렬화되지 않는다.
					ㄴ 간단한 사용법 )
						ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( "Object.ser" ) );
						out.writeObject(new Circle(1,2,3,4));
					ㄴ 주의 )
						ㄴ 직렬화, 역직렬화 과정은 자원소모가 많은 작업이므로 유의해야 한다.
				ㄴ RandomAccessFile 클래스 )
					ㄴ 위에서 계속 나오는 '스트림 클래스'는 아니지만 '파일'에 대하여 입출력을 해주는 클래스이다.
					ㄴ 특징 )
						ㄴ 입력과 출력이 동시에 이루어 질 수 있다.
						ㄴ 입출력의 위치를 조절할 수 있다.
						ㄴ '파일'을 대상으로만 동작한다.
					ㄴ 내부적으로 입출력의 위치를 계속해서 기록한다.
					ㄴ 간단한 사용법 )
						ㄴ 생성자 )
							ㄴ public RandomAccessFile ( String fileName, String mode ) throws FileNotFoundException
							ㄴ fileName이 파일이름, mode는 해당 파일을 어떤 용도로 사용할지를 전달하는 기능이다. 다음 두가지중 하나의 값을 가진다.
								ㄴ "r" : 파일을 읽기용도로 사용할것임
								ㄴ "rw" : 파일을 읽고 쓰는 용도로 사용할 것임.
					ㄴ 주요 메소드 )
						ㄴ 입력 메소드 )
							ㄴ public int read() throws IOException
							ㄴ public int read ( btye[] b, int off, int len ) throws IOException
							ㄴ public final int readInt() throws IOException
							ㄴ public final double readDouble() throws IOException
						ㄴ 출력 메소드 )
							ㄴ public void write( int b ) throws IOException
							ㄴ public void write ( byte[] b, int offset, int len ) throws IOException
							ㄴ public final void writeInt ( int v ) throws IOException
							ㄴ public final void writeDouble ( double v ) throws IOException
						ㄴ 입출력 위치 조절 )
							ㄴ public long getFilePointer() throws IOException : 파일의 현재 입출력 위치를 반환받는다.
							ㄴ public void seek ( long pos ) throws IOException : 입출력 위치를 변경
				ㄴ File 클래스 )
					ㄴ 파일이나 디렉토리와 관련된 동작을 하기위해 만들어진 클래스. (파일이나 디렉토리의 이동, 생성, 이름변경 등등)
					ㄴ pathname에 해당하는 파일이나 디렉토리를 추상적으로 나타내는 클래스이다.
					ㄴ 기본 사용법 )
						ㄴ 그냥 원하는 파일이나 파일경로를 File인스턴스로 만들고 메소드 사용해서 쓰면된다.
						ㄴ 필드 )
							ㄴ public static final String separator : 파일의 경로에서 디렉토리 또는 파일이름의 구분자를 os에 맞게 입력해주는 필드. String으로 표현되었다.
							ㄴ public static final char separatorChar : separator와 같은데 char형으로 표현된것.
							ㄴ public static final String pathSeparator : 여러 파일들을 경로로 입력할때, 각 파일들을 구분해주는 구분자를 os에 맞게 입력해주는 필드. String으로 표현되어ㅣㅆ다.
								ㄴ ex) wnidow에선 ';', unix에선 ';' 같은것.
							ㄴ public static final char pathSeparatorChar : pathSeparator와 같은데 char형으로 표현된것.
						ㄴ 생성자 )
							ㄴ new File ( String pathname );
								ㄴ pathname에 해당하는 File인스턴스를 만든다.
								ㄴ pathname는 파일의 경로를 의미하며, 실제 파일이 있건 없건 생성자 인자로 넘겨줄 수 있다. 실제파일이 없으면 빈 File인스턴스가 생기는것.
							ㄴ new File ( File parent, String filename ) : filename이 실제 파일명이고 parent가 filename이 위치하는 경로정보를 담고있는 File 인스턴스가된다.
						ㄴ 메소드 )
							ㄴ exists() : File인스턴스에 해당 파일이 실제로 존재하는지 확인.
							ㄴ public boolean mkdir() : File 인스턴스의 (*경로 정보*)에 해당하는 디렉토리를 만든다.
							ㄴ public boolean mkdirs() : File인스턴스의 (*경로 정보*)에 해당하는 디렉토리를 만들되, (*경로 정보*)상에는 있으나 실제로는 존재하지 않는 부모 디렉토리가 있을 경우 이것들을 모두 같이 생성해준다.
							ㄴ public boolean renameTo ( File dest ) : 현재 File인스턴스의 파일의 이름을 넘어온 인자의 파일이름으로 변경한다.
								ㄴ 파일의 이름은 File인스턴스 생성시 인자로 전달한 pathname을 말하는 것이고, '경로정보'를 포함한다.
									ㄴ "C:\Users\이관춘\Desktop\aaa.txt"라는 pathname이면 파일이름은 보통 aaa.txt를 생각하지만 그 앞의 C:\Users\이관춘\Desktop 부분도 같이 변경된다.
								ㄴ 파일 경로는 같고 이름만 변경하면 일반적으로 생각하는 파일 이름만 변경하는 것이 된다.
							ㄴ public File[] listFiles() : 디렉터리에 존재하는 파일과 디렉토리들 정보를 반환한다.
					ㄴ 스트림 클래스들의 생성자 인자로 String을 직접입력하기보다 File인스턴스를 사용하면 유용하다.
			</pre>
			ㅇ 자바 정규식 <button>펼치기</button>
			<pre>
				ㅡ java.util.regex.Pattern을 이용하여 패턴을 확인한다.
					ㄴ 사용법 )
						ㄴ public static boolean Pattern.matchs ( (*regex식*), (*검증하려는 문자열*) )
							: 패턴이 일치하면 true반환.
				ㅡ 정규 표현식 )<button>펼치기</button>
				<pre>
					ㄴ 아래의 것들을 이용해 패턴을 나타낸다.
					ㄴ ^ : 문자열 시작
					ㄴ $ : 문자열 종료
					ㄴ . : 임의의 단 한문자를 나타냄. ex) h. => h다음 임의의 문자하나가 오는 패턴을 매칭. "hf", "ha"등. "h"는 안됨.
					ㄴ * : 앞의 문자가 0개 이상. ex) [0-9]* 	=>0~9까지의 숫자가 0개 이상인 패턴을 의미.
					ㄴ + : 앞의 문자가 1개 이상.
					ㄴ ? : 앞의 문자가 1개 이하.
					ㄴ [ ]
						ㄴ 문자의 집합,범위 등을 나타냄.
						ㄴ ex)
							ㄴ [abc] : a,b,c중 하나인 패턴
							ㄴ [a-z] : a부터z까지 중 하나인 패턴
							ㄴ [^abc] : a,b,c를 제외한 다른 문자인 패턴
							ㄴ [a-zA-Z] : a부터z까지거나 A부터 Z까지거나인 패턴
							ㄴ [a-z&&[def]] : &&로 교집합처리가 되어 d,e,f중 하나인 패턴이된다.
					ㄴ { } : 횟수 또는 범위를 의미
						ㄴ ex)	\d{2,3} : 숫자정수 개수가 2~3개인 패턴
							\d{2,} : 2개 이상
							\d{2} : 딱 2개.
					ㄴ \ : 정규표현식에서 특수한 기능을 하는 문자. \(*일반문자*) 이면 특수하게 약속된 문자로 취급하고(\d, \w등), \(*특수문자*) 이면, 특수문자 자체를  의미한다.
						ㄴ \w : 알파벳이나 숫자
						ㄴ \W : 알파벳이나 숫자를 제외한 문자.
						ㄴ \d : 숫자 0~9
						ㄴ \D : 숫자를 제외한 문자.
						ㄴ ~~~~~
					ㄴ 정규식 그룹화 )
						ㄴ ()을 이용. ()안의 문자열은 하나로 묶어서 다룬다.
						ㄴ ex) '카츠동', '규동', '부타동'중에 하나인지 확인하려면, regex = (카츠 | 규 | 부타) (동) 으로 하면된다.
							(카츠 |규|부타)가 하나로 묶이고 (동)이 하나로 묶인다.
					ㄴ Lookahead ??? )
						ㄴ
					ㄴ 자주쓰이는 정규식 패턴 )
						ㄴ 휴대전화번호 : ^01(0|1|[6-9]) - (\d{3,4}) - [0-9]{4}$
						ㄴ 숫자만 : ^[0-9]*$
						ㄴ 영어만 : ^[a-zA-Z]*$
						ㄴ 한글만 : ^[가-힣]*$
						ㄴ 이메일 : \\w+@\\w+\\.\\w+(\\.\\w+)?
						ㄴ 주민번호 : \d{6} \- [1-4]\d{6}
				</pre>
			</pre>
			ㅇ 명령어 'java'
				ㅡ 자바 어플리케이션을 실행하는 명령어이다.
				ㅡ public static void main(String[] args) 메소드가 있어야한다.
				ㅡ 디폴트로, java [ (*옵션*) ] (*클래스명*) [ (*매개변수*) ]형태로 실행한다.
					ㄴ (*클래스명*)은 fully qualified class이다. 패키지가 있으면 이것까지 써야하는거.
					ㄴ -jar 옵션이 붙었으면 (*클래스명*)이 아닌 JAR파일명이온다.
					ㄴ 매개변수는 당연히 main메소드의 인자로 들어간다.
				ㅡ java runtime은 startup class를 찾고 나머지 클래스들은 가져와 사용한다.
					나머지 클래스들을 찾는 위치는 bootstrap class path, installed extension, user class path 세가지이다.

			ㅇ java classpath
				ㅡ CLASSPATH 변수는 프로그램에게 어디에 user classes가 있는지 알려주는 유일한 방법이다.
					ㄴ JRE,JDK의 클래스나 extension들은 bootstrap class path나 extensions directory에 잇다)
				ㅡ -cp 옵션을 통하여 class path를 추가할수도 있다. 해당 어플리케이션에만 적용되기때문에 권장된다한다.
					ㄴ CLASSPATH변수에 설정해두면 다른어플리케이션도 적용이 되므로.
					ㄴ ex) 	java -cp /usr/local/tomcat9~~/lib/~~.jar:/usr/local/~~/classes NoName2
						ㄴ -cp다음에 오는 path가 class path이다. 세미콜론(;)이 아닌 땡땡표시?( : )를 기준으로 여러 경로를 입력할 수 있다.
					ㄴ 여기에 적힌 경로를 참고하여 java명령어를 실행하는 듯하다. 따라서 import한 클래스들을 참고할 수 있는 경로는 물론이고 실행하려는
						class파일에 대한 경로도 있어야 하는 듯 하다.
			ㅇ 기타
				ㅡ immutable object, 불변 객체 )
					ㄴ '힙 영역'에 들어있는 '데이터 자체'가 변경되지 않는 객체를 의미한다.
					ㄴ 가령, 객체 A안에 num이란 필드가 들어있고, setterNum()이 정의되어있어 num값이 변경된다면 A가 들어있는 '힙 영역'안의 데이터가
						변경된것이므로 '불변 객체'가 아닌 '가변 객체'가 된다.
					ㄴ ????????????????????자세하게는 아직 잘 모르겠다.
						ㄴ 인스턴스의 참조변수를 필드로  가진경우, 그 필드의 참조값만 변경이 안되면 불변객체인지, 참조하는 인스턴스또한 변경이 안되어야 불변객체인지..?

			ㅇ JPA<button>more</button>
			<pre>
				ㅡ Java Persistence API
				ㅡ 자바에서 규정한 Persistence API에 대한 '표준'이다. (실구현체가 아닌)
					ㄴ spec, interface으로 따라야 하는 가이드라인을 명시해 둔 것.
					ㄴ 대표적 구현체가 HIbernate.
				ㅡ ~~~~~
				ㅡ Entity<button>more</button>
				<pre>
					ㄴ ~~~~~
					ㄴ 엔터티 관계 종류<button>more</button>
					<pre>
						ㄴ one-to-one )
							ㄴ

					</pre>
					ㄴ cascade 연산 <button>more</button>
					<pre>
						ㄴ 엔터티가 fk와 같이 다른쪽에 의존하고 있는 경우, 한 쪽 엔터티가 삭제되면 이에 의존하고 있는 다른 엔터티를 어떻게
						ㄴ 엔터티가 관계를 가지고 그 관계를 가진 엔터티에 의존성을 가지는 경우, 의존 대상인 엔터티의 처리에 따라
							하위 엔터티를 연달아 처리하는 것을 cascade 연산이라 한다.
						ㄴ 어떤 cascade
					</pre>
				</pre>

				ㅡ Entity 상속<button>more</button>
				<pre>
					ㄴ
				</pre>

				ㅡ Entity 관리<button>more</button>
				<pre>
					ㄴ entity들은 javax.persistence.EntityManager에 의해 관리된다.
					ㄴ 각 entityManager는 한 persistence context에 연결된다.
					ㄴ Persistence context )
						ㄴ 관리 되고 있는 entity들의 집합. ?????
						ㄴ 이 안의 엔터티들이 EntityManager에 의해 관리된다함.
						ㄴ 엔터티들이 store에서 불러와지거나 저장되는 일종의 캐시?
						ㄴ ????? 저장소와 어플 사이에 위치한다.
						ㄴ context는 관리되고 있는 엔터티의 변화를 트랜잭션 중에 추적하고 있다가, 트랜잭션 완료시 저장소로 flush한다.
						ㄴ 일종의 캐시.
							ㄴ 모든 엔터티와 관련한 업데이트, 생성, 삭제 등을 실 db에 대고 하지 않고 일종의 캐시 상에 적용한 다음
								모든 연산이 끝났을 때 한번에 db에 적용하는 방식.
							ㄴ 이 캐시에 대한 관리, 연산을 ENtityManager가 하는 것.
						ㄴ 스코프 )
							ㄴ transaction-scope persistence context )
								ㄴ 트랜잭션에 묶여서, 트랜잭션 완료시 context안의 내용이 바로 저장소에 반영된다.
								ㄴ 디폴트로 사용되는 스코프.
							ㄴ extended-scope persistence context )
					ㄴ EntityManager )
						ㄴ persistence context와 상호작용하게 해주는 interface
						ㄴ 이것의 메소드를 통해 엔터티 인스턴스를 생성, 삭제하거나 찾는 등의 기능 가능.
						ㄴ ????? 두 종류? )
							ㄴ??? container-managed entityManager )
								ㄴ 하나의 JTA 트랜잭션 내의 특정 EntityManager 인스턴스가 있다하면,
									이 인스턴스의 persistence context가 이 인스턴스를 사용하는 어플리케이션의 모든 컴포넌트에게 컨테이너에 의해 자동으로 전파된다???
							ㄴ ??? application-managed entitymanager )
								ㄴ

					ㄴ ????? Container-Managed Entity Manager )
						ㄴ
					ㄴ ????? Application-Managed Entity Manager )
					ㄴ EntityManager를 이용해 Entity 찾기 )
						ㄴ EntityManager.find()는 엔터티의 pk를 이용해 저장소로부터 엔터티를 찾는다.
					ㄴ 엔터티 인스턴스 라이프사이클 )
						ㄴ 상태 )
							ㄴ new : ????? persistence id가 없고 persistence context에 연결되지도 않음.
							ㄴ managed : persistence id를 가지고, persistence context에 연결됨.
							ㄴ detached : ????? id를 가지지만, 현재 persistence context에 연결되지 않음.
							ㄴ remove : id를 가지고 context에도 연결. 곧 저장소에서 제거될 예정.
						ㄴ 새로운 엔터티는 persist()호출 또는 cascade=PERSIST, ALL인 관계된 엔터티의 persist()호출을 통해
							관리되기 시작한다.
							ㄴ persist()르 ㄹ호출한 트랜잭션이 완료시, 이 관리되는 엔터티가 db에 저장됨.
							ㄴ 이미 관리되는 엔터티인 경우 persist()는 무시됨. ????? 관계된 casecade=PERSIST, ALL인 엔터티이어도?
							ㄴ ??? persist() 연산은 cascade=All 또는 PERSIST인 관계를 맺고 있는 모든 엔터티에 전파된다.
						ㄴ 엔터티 인스턴스 제거 )
							ㄴ 관리 중인 엔터티 인스턴스는 remove()호출이나 cascade로 인한 remove연산을 통해 제거된다.
					ㄴ 참고 )<button>more</button>
					<pre>
						ㄴ https://docs.oracle.com/javaee/6/tutorial/doc/bnbqw.html
						ㄴ https://tomee.apache.org/jpa-concepts.html
					</pre>
				</pre>

			</pre>

			ㅇ 라이브러리 정리<button>more</button>
			<pre>
				ㅡ com.drewnoakes 의 'metadata-extractor'
					미디어 파일로부터 메타데이터를 읽어들이는 라이브러리.<button>more</button>
				<pre>
					ㄴ <a href="https://github.com/drewnoakes/metadata-extractor" target="_blank">https://github.com/drewnoakes/metadata-extractor</a>
					ㄴ 설치 )
						ㄴ 메이븐 )
							< dependency>
							  < groupId>com.drewnoakes< /groupId>
							  < artifactId>metadata-extractor< /artifactId>
							  < version>2.16.0< /version>
							< /dependency>
						ㄴ gradle )
							compile group: 'com.drewnoakes', name: 'metadata-extractor', version: '2.9.1'
					ㄴ ex )
						ㄴ 이미지 파일로부터 회전 정보 읽기. (모바일 촬영 이미지들은 찍는 각도에 따라 회전이 된다)
							int orientation2 = 1;
							int width = 0; // 이미지의 가로폭
							int height = 0; // 이미지의 세로높이

							Metadata metadata; // 이미지 메타 데이터 객체
							Directory directory; // 이미지의 Exif 데이터를 읽기 위한 객체
							JpegDirectory jpegDirectory; // JPG 이미지 정보를 읽기 위한 객체

							try {
								metadata = ImageMetadataReader.readMetadata(uploadFile);
								directory = metadata.getFirstDirectoryOfType(ExifIFD0Directory.class);
								jpegDirectory = metadata.getFirstDirectoryOfType(JpegDirectory.class);
								if(directory != null){
									orientation2 = directory.getInt(ExifIFD0Directory.TAG_ORIENTATION); // 회전정보, 1. 0도, 3. 180도, 6. 270도, 8. 90도 회전한 정보
								}
							}catch (Exception e) {
								orientation2=1;
							}
				</pre>

				ㅡ JDBC API<button>more</button>
				<pre>
					ㄴ ~~~
					ㄴ Statement
						ㄴ ~~~
						ㄴ Batch Update
							ㄴ 여러 update query를 하나씩이 아닌 한번에 db로 전송하는 기능.
							ㄴ 성능상의 이점이 있다.
							ㄴ ex )
								Statement stmt = con.createStatement();
								con.setAutoCommit(false);

								stmt.addBatch("INSERT INTO employees VALUES (1000, 'Joe Jones')");
								stmt.addBatch("INSERT INTO departments VALUES (260, 'Shoe')");
								stmt.addBatch("INSERT INTO emp_dept VALUES (1000, '260')");

								int [] updateCounts = stmt.executeBatch();  // insert query 3개가 한번에 나간다.
						ㄴ ~~~
					ㄴ ~~~

				</pre>
			</pre>

			ㅡ 무제 ) <button>more</button>
				ㄴ jar파일 수정하기 )
					ㄴ 기본적으로 그냥 압축 풀고, 수정하고 다시 jar로 압축하면 된다. 압축은 jar명령어로 해도 되고 다른 걸로 해도 되고.
					ㄴ 다시 압축시, 자바 버전에 주의해야 겠다.

		</pre>

		CSAPP<button>더보기</button>
		<pre>
			chapter10. System Level I/O<button>더보기</button>
			<pre>
				ㅡ i/o란 메인메모리의 데이터를 디스크드라이브, 터미널, 네트워크와 같은 외부장치르 복사하는 프로세스를 말한다.
					ㄴ input은 외부 장치로부터 메인메모리로 복사하는것. output은 그 반대.
				ㅡ 모든 언어의 런타임 시스템은 고수준 레벨의 io함수를 제공한다. (printf, scanf같이)
					ㄴ 그리고 이런 고수준 레벨 io함수들은 system 레벨의 Unix I/O함수를 통하여 구현된다. (Unix시스템에선)
				ㅡ Unix I/O를 배워야 하는 이유 )
					ㄴ io를 이해하는것이 다른 시스템이해에  도움이 된다.
						ㄴ i/o는 시스템의 연산과 필수불가결한 관계이다.
						ㄴ 프로세스의 생성과 실행은 io와 상호 의존성을 가진다. 따라서 어느한쪽을 이해하려하면 다른한쪽을 이해해야한다.
					ㄴ unix i/o만 할 수 있는것들이 있다)
						ㄴ 파일 메타데이터에 접근하거나 네트워킹 프로그래밍을 할때에는 이를 사용해야한다.
				ㅇ Unix I/O
					ㅡ 모든 io장치들 (네트워크, 디스크, 터미널 등)은 '파일'로서 설계되었다.
					ㅡ 따라서 모든 input, output은 파일에 대한 read,write로 작동한다.
					ㅡ 이런 바탕으로 인해 unix 커널에선 단순하고 로우레벨의 인터페이스 Unix i/o가 나올수있었다하며, unix io는 모든 input output을
						통일되고 일관된방식으로 수행할수 있게해준다함.
					ㅡ 파일 열기, 읽기, 쓰기 동작 )
						ㄴ 열기 )
							ㄴ 어플리케이션이 커널에게 io장치에 대한 접근을 요청.
							ㄴ 커널은 해당 파일에 대한 디스크립터(음이아닌 정수)를 반환해주며, 이후 연산에서 이 숫자가 해당 파일을 가리키는 값이 된다.
							ㄴ 유닉스에서 모든 프로세스는 stdin, stdout, stderr 이렇게 세가지 파일이 열린상태로 시작된다.
						ㄴ 읽기 쓰기 )
							ㄴ 열린 파일에 대해 커널은 file position(파일의 바이트 커서같은거)을 추적하며, 이는 처음에 0으로 설정.
							ㄴ 어플리케이션은 seek연산을 통해 커서의 위치를 설정할 수 있다.
							ㄴ 읽기 연산은 n 바이트 만큼의 데이터를 파일에서 메모리로 복사하고 file position k를 n만큼 옳겨가며 연산한다.
							ㄴ k가 파일의 크기(m)을 초과하면 (k>m) EOF(end of file)이 발생한다.
							ㄴ 쓰기연산은 마찬가지로 n바이트만큼 메모리에서 파일로 복사를하며, k위치에 추가한다.
						ㄴ 파일 닫기 )
							ㄴ 어플리케이션이 파일에 대한 접근을 마치면 close요청을 커널에게 보낸다.
							ㄴ 커널은 파일이 열릴때 만들었던 data structure을 해제하고 파일 디스크립터를 풀로 돌려놓음으로서 닫기연산을 한다.
							ㄴ 프로세스가 종료되면 커널은 자동으로 모든 열린 파일을 닫는다.



			</pre>
			chapter11. network porgramming<button>더보기</button>
			<pre>
				ㅡ 컴퓨터 장치에서 network adapter가 잇어서 이곳을 통해 네트워크와데이터를 주고받는다고한다.
					ㄴ 이곳의 io버스가 네트워크와의 물리적 인터페이스를 제공한다.
					ㄴ 데이터는 adapter로부터 io버스로, 메모리로 복사된다. 반대도 마찬가지.
				ㅡ LAN (Local Area Network)
					ㄴ 빌딩이나 대학교 같은 범위에서 사용되는 네트워크
					ㄴ 가장 대표적인 기술은 'Ethernet'
					ㄴ Ethernet
						ㄴ 전선과 '허브'로 구성되어있다.
						ㄴ 전선의 한쪽끝은 허브의 포트와 연결되어있고, 나머지는 위에서말한 호스트의 network adapter에 연결.
						ㄴ 허브는 포트로부터 온 데이터들을 복사한다.
						ㄴ 한 이더넷은 'bridge'를 통해 다른 LAN과 연결이 가능하다. 이 방식을 통해 빌딩 전체나 대학교전체를 연결하는것.
				ㅡ 라우터
					ㄴ 이 양립할수없는 LAN들을 '라우터'라는 특별한 컴퓨터를 통해 연결이 가능하고 이를 '인터넷'이라 부름??
					ㄴ 라우터는 각 네트워크마다 이에 해당하는 하나의 포트를 가지고 있다.
					ㄴ WAN (Wide Area Networks) : LAN보다 범위가 지리적으로 크기때문에 이렇게 이름붙었다.
					ㄴ LAN과 WAN들이 모여서 '인터넷'이 된다.
				ㅡ 인터넷의 큰 특징은 서로 다른 기술들으로 이루어진 LAN, WAN들로 구성될 수 있다는 것이다.
					ㄴ 이것이 가능한 이유는 호스트와 라우터에서 동작하는 프로토콜 소프트웨어 계층 덕분이다.
					ㄴ 이 소프트웨어는 호스트와 라우터들이 데이터를 서로 전송하기위해 어떻게 상호작용해야하는지를 관리하는 '프로토콜'을 구현한다.
				ㅡ 프로토콜
					ㄴ 프로토콜은 두가지 기본 요소를 제공해야한다.
					ㄴ Naming scheme : 기술이 다르면 호스트에 주소를 할당하는 방식도 다르기마련인데, 프로토콜에서 이 차이점을 해결하여 유일한 주소를
						할당하여야 한다.
					ㄴ Dilivery mechanism : 기술이 다르면 전선의 전송하려는 비트들을 인코딩하는 방식이 다르기마련. 프로토콜은 이를 '패킷'이라 불리는
						작은 데이터 덩어리로 비트들을 묶도록 하여야한다. 패킷은 'header'와 payload로 이루어져 잇다.
					ㄴ 프로토콜에 따른 데이터 전송과정 : 890~891페이지.
				ㅡ 각각의 호스트들은 프로토콜을 구현하는 소프트웨어를 실행한다.
				ㅡ 현대의 대부분의 컴퓨터 시스템들은 tcp/ip 프로토콜을 구현하는 소프트웨어를 지원한다.
				ㅡ client server는 '소켓 인터페이스'와 unix i/o function을 이용하여 소통한다.
					ㄴ 소켓 인터페이스는 커널단에서 제공하는 시스템콜로서, 내부적으로 여러 커널모드의 함수들을 호출한다.
			</pre>
		</pre>

		network<button>더보기</button>
		<pre>
			ㅇ 데이터 통신 <button>더보기</button>
			<pre>
				ㅡ 데이터 통신이란 : 통신 매채를 사용하여 두 장치간에 데이터를 주고받는 것.
				ㅡ 데이터 통신의 기본 특성
					ㄴ 전달 : 정확한 목적지에 전달
					ㄴ 정확성 : 데이터를 정확하게 전달해야한다. 중간에 변형되어서는 안된다.
					ㄴ 적시성 : 적절한 시간내에 전달
					ㄴ 파형 난조 : 패킷 도착 시간이 조금식차이가나 품질이 일정치않음.
				ㅡ 구성요소
					ㄴ 메세지, 송신지, 수신지, 프로토콜, 전송매체
					ㄴ 프로토콜 : 통신을 하기위한 약속. 어떤식으로 통,수신을 하기로하자는 규약.
					ㄴ 메세지 : 통신 대상이 되는 정보. 그림 소리 문자 등등.
					ㄴ 송, 수신자
					ㄴ 전송매체 : 메세지가 이동하는 물리적 경로.
				ㅡ 데이터 표현 : 전송되는 데이터의 종류, 형태
					ㄴ 문자, 수, 이미지, 음성, 영상
					ㄴ 문자 : 코드, 아스키, 유니코드등 비트의 순차열로 표현
					ㄴ 숫자 : 비트로 표현.
					ㄴ 이미지 : 픽셀, 해상도를 통해 표현.
					ㄴ 음성 : ??? PCM 변환 등을 통해 비트로 전달되나
					ㄴ 동영상 : ???모름.
				ㅡ 데이터 흐름 방향
					ㄴ 단방향 방식 : 말그대로. 한쪽은 수신만, 나머지한쪽은 송신만가능. 방송, 키보드 모니터 등.
					ㄴ 반이중 방식(half-duplex mode) : 통신개체들이 송수신 모두 가능하나, 한번에 한가지 역할만 가능한방식. 무전기같은거.
					ㄴ 전이중 방식(full-duplex mode) : 통신개체들이 송수신 모두 가능하고, 항상 두 역할을 수행할수 있는것. 전화같은거.
			</pre>

			ㅇ 네트워크 <button>더보기</button>
			<pre>
				ㄴ 통신하는개체가 한쌍이 아니라 여러개가 되면 네트워크. 여러 컴퓨터들이 서로 통신가능하게 연결되어 있는것.
				ㄴ 이를 통해 '분산처리'를 할수있다. (분산처리란? 하나의 작업을 여러컴퓨터들이 나누어서 처리하는 것)
				ㄴ 여러 네트워크들이 있고 이것들을 평가하는 기준이 있다.
					ㄴ 네트워크 평가기준)
						ㄴ 성능 : 전달시간, 응답시간, 처리율(단위시간동안 얼마나 많은데이터 통신가능한지), 지연
						ㄴ 신뢰성(reliability) : 네트워크가 얼마나 믿을만한지. 잘작동되고, 고장안나고, 고장나도 금방고쳐지고 등.
						ㄴ 보안
				ㅡ 네트워크의 분류 )
					ㄴ 물리적 구조에 따른 유형분류 )
						ㄴ 연결형태
							ㄴ 점대점( point to point) : 링크 하나에 단 두 기기만 통신.
							ㄴ 다중점 (multipoint) : 링크 하나에 여러 기기 연결.
						ㄴ 접속형태
							ㄴ 그물형 : 네트워크안에있는 모든 노드가 서로다른 모든 노드와 연결되어잇는형태.
								ㄴ 모든 장치는 다른 모든 장치와 점대점 연결이 되고, 안정성, 보안 등의 장점이있으나, 자원이 많이듬.
							ㄴ 스타형 (일명 hub형) : 허브라는 중앙제어장치를 중심으로 노드들이 연결되어있는형태. 허브와 노드들은 점대점 연결.
								노드(장치)간의 직접통신은 안되고 허브를통해서만 가능. 그물형과반대로 자원이 적게들지만 허브고장시 전체가 멈춘자는 단점.
							ㄴ 버스형 : 다중점형태. 선이 있고 그 선 중간중간에 '탭'이 있어 이부분에 컴퓨터가 연결된 방식.
								설치가 쉽고 가장적은 양의 케이블을 사용하여 자원이 가장적게든다. 재구성이 어려움.
							ㄴ 링형 : 버스형태에서 케이블의 끝이 없이 원형으로 되어있는형태. 신호가 한바퀴 돌아감.
								ㄴ 자신의 양쪽에 위치한 장치와 점대점회선
								ㄴ ?? 중계기?
					ㄴ 네티워크 망의 규모에따른 유형분류
						ㄴ Nanoscale network
							ㄴ 생체 시스템 같은 곳에서 사용되는 단위.
						ㄴ Personal area network (PAN)
							ㄴ 한 개인이 사용하는 범위 내에서 서로 다른 컴퓨터나 장치 사이의 네트워크. 약 10미터 이내.
							ㄴ 데스크탑, 프린터, 핸드폰 등.
							ㄴ 블루투스나 적외선, usb이용.
							ㄴ wired 장치일 수도, wireless 장치 일 수도 있다.
						ㄴ Local-area network (LAN), 근거리 통신망
							ㄴ 집, 학교, 건물하나, 인접한 여러 건물 등.
							ㄴ wired인 경우 대부분 '이더넷'기반.
							ㄴ WAN과의 차이는 데이터 전송량, 규모의 크기, '임대 라인'의 사용.
								ㄴ '임대 라인'이란 개인 회선, 사업적으로 임대해 주는 회선?
							ㄴ 링형, 버스형, 스타형 사용.
						ㄴ Home area network (HAN)
							ㄴ 한 가정 안에서의 LAN을 의미. 개인 컴퓨터들이나 모바일 장치, 프린터 등이 연결.
						ㄴ ????? Storage area network (SAN)
							ㄴ ????? consolidated, block-level의 데이터 storage에 대한 접근을 제공하는 목적으로 사용되는 네트워크이다.
							ㄴ ?????
						ㄴ Campus area network (CAN)
							ㄴ 네트워크 장비(스위치, 라우터)와 전송 장비(optical fiber, copper plant 등)을 통해 특정 구역에 한해서
								LAN들이 서로 연결된 네트워크.
							ㄴ 기업, 대학교, 정부 규모에서 이런 형태가 보인다.
						ㄴ Backbone network
							ㄴ 전송량이 큰 장치가 포함된 네트워크?
							ㄴ 여러 LAN들이나 subnet들을 하나로 연결한다.
							ㄴ 큰 회사나 대학교, 빌딩들 단위의 규모.
								ㄴ 이런 큰 규모에서 각각의 지점들의 LAN들을 연결된 네트워크를 말함.
									(이더넷이던, 무선이던 그 LAN들을 연결해주는 네트워크 자체를 의미)
						ㄴ Metapo~~-area network (MAN) : 도시하나정도.
						ㄴ Wid-area network (WAN), 광역통신망
							ㄴ 국가, 대륙, 전세계 범위의 규모.
							ㄴ 거리가 매우멀어 설치어렵
							ㄴ 위성, 해저케이블, 전파망 등사용
							ㄴ 대부분 점대점연결. 또는 교환형이다.
							ㄴ 교환형 (switched) WAN : 설치에 비용이 많이들어 하나깔아놓고 망?을 변경해가면서 사용하는방식?
					* open network, closed network
						ㅡ open network : 여러 그룹들이 표준에 따라 모두 사용하기 위해 만든것.
						ㅡ closed network : 특정 벤더들이 그들만 사용하기 위해 만든것.
			</pre>

			ㅇ 인터넷<button>더보기</button>
			<pre>
				ㅡ internetowrk : 두 개 이상의 네트워크가 연결되어 있는 것을 말함.
				ㅡ 인터넷 역사
					ㄴ 원래는 internetwork를 구현한 최초의 사례가 미국의 '아파넷'이었는데, 널리쓰이다보니 굳이 구분하지않고 그냥 '인터넷'이라고 부르는듯하다.
				ㅡ 표준 )
					ㄴ 인터넷 표준을 제시하고있는 기구들
						ㄴ IEEE, IETF, ITU, ISO, W3C 등
					ㄴ 각 계층마다 표준안을 담당하고있는 단체가 다르다함.
						ㄴ application 계층은 W3C
						ㄴ transport, internet은 IETF
						ㄴ data link는 IEEE
					ㄴ IETF에 의한 표준 )
						ㄴ 처음 '인터넷 초안(draft standard)' 형태로 IETF에 제안된다.
						ㄴ 그다음 검토를 거쳐 '인터넷 표준(internet standard)'가 된다.

			* WWW, World Wide Web(웹)
				ㄴ 웹이란? 인터넷상의 정보를 하이퍼텍스트 방식과 멀티미디어 환경에서 검색할 수 있게 해주는 정보검색 시스템이다.
					ㄴ 웹 브라우저를 통해 웹페이지를 검색하고 이 페이지에서 여러 다른페이지들로 이동하며 정보를 보게해주는것이 웹을 이용하고있는것.
				ㄴ 인터넷 상의 여러 서비스들중 하나. (다른 서비스들로는 메일, ftp등)
			</pre>

			ㅇ 프로토콜 <button>더보기</button>
			<pre>
				ㅡ 통신을 하기위한 약속. 어떤식으로 통,수신을 하기로하자는 규칙.
					ㄴ 프로토콜은 단순히 통신하는데 사용되는 규칙일 뿐이다.
					ㄴ 이 규칙들은 계층에 따라서 소프트웨어나 기계어 또는 하드웨어를 이용해 구현된다. (어플리케이션, 전송계층 등은 소프트웨어, 데이터링크층은 하드웨어 이런식)
					ㄴ https://stackoverflow.com/questions/1942304/how-are-network-protocols-implemented

				* protocol suite
					ㅡ 일반적으로 여러 프로토콜을 같이사용하게 되며 이런걸 묶어서 protocol suite라고도 한다.
					ㅡ ex) TCP/IP Internet protocol suite
				ㅡ 프로토콜 계층
					ㅡ 통신을 여러 계층으로 나누어서 다루는 방식
						ㄴ 커다란 프로그램을 모듈화하듯이 프로토콜역시 여러계층으로 나뉘어 각각의 기능들을 별도의 프로토콜로 구현하여 기능을 수행한다.
					ㅡ 이유 : 각 계층의 모듈화, 독립성.
					ㅡ 계층화 원칙
						ㄴ 각 계층은 한 종류의 상반되는 두가지 작업수행이 가능해야한다. 암호화와 복호화, 보내기와 받기 등
						ㄴ 각 계층의 객체는 동일해야 한다. (전달되는 데이터 말한는듯)
					ㅡ 논리적 연결 : 각 계층끼리 연결된 것을 말함.
					* 인터넷 프로토콜 스위트, Internet Protocol Suite )
						ㅡ 인터넷에서 사용되는 프로토콜들의 모음을 말한다.
					ㅡ TCP/IP 프로토콜 슈트 )
						ㄴ TCP/IP 프로토콜을 중심으로 많이 사용되는 프로토콜의 모음을 말한다.
							ㄴ 가장 널리 쓰이는 방식이다.
						ㄴ TCP/IP 계층 : TCP/IP 프로토콜 슈트에 따라 인터넷 계층을 나눈것을 말한다. 일반적으로 다음과 같다.
						 <img src="image/네트워크_5계층.png" height="300px"/>
						* 기타지식(10)
							ㅡ Switch	가 LAN에서 쓰인거고 라우터가 WAN에서 쓰이는것.
							ㅡ 라우터를 통해 인터넷 상에서 통신하는 것.
						ㄴ 한 어플리케이션에서 다른에플리케이션으로 데이터를 보내려는것.
						ㄴ physical : 실제 구리선같은 물리적 선을통한 통신 계층. 이계층부터 하드웨어. 그 위는 소프트웨어.
						ㄴ 계층들의 논리적 연결 )
							ㄴ data계층, 물리 계층은 라우터까지만 논리적 연결이 되어잇음.
							ㄴ 나머지는 소스와 목적지까지가 연결.
						ㄴ 계층별 객체)
							ㄴ 각 계층마다 전달하는 정보를부르는 이름이 있다.
							ㄴ 어플리케이션단 : 메세지, 전송단 = 데이터그램 또는 세그먼트, 네트워크단 = 데이터그램, 데이터단 = 프레임, 물리단 = 비트
					ㅡ 각 계층 설명 )
						ㅡ 물리층)
							ㄴ 비트들의 묶음인 '프레임'이란 단위.
							ㄴ 이 '프레임'을 다음 목적지로 전달.
							ㄴ 다양한 프로토콜 사용가능
						ㅡ 데이터 링크 층 )
							ㄴ IEEE 표준에 의해 두개의 sub-layer로 나뉜다.
								ㄴ LLC, Logical Link Control )
									ㄴ addressing, demultiplexing기능을 담당.
								ㄴ MAC, Media Access Control )
									ㄴ 공유매체에 어떻게 접근해야하는지를 정한 표준.
							ㄴ MAC 주소 )
								ㄴ 2계층과 관련있는 Ethernet에서 사용하는 주소.
								ㄴ '물리적 주소' 또는 'Ethernet 주소'라고도 불린다.
								ㄴ NIC (network interface card)에 따라 할당된다.
								ㄴ 구성 )
									ㄴ 48bit로 구성. 12자리 십진수로도 표현.
									ㄴ 절반은 NIC를 생성한 벤더 등의 고유주소와 관련된 번호 할당. (이를 OUI라함)
									ㄴ OUI의 맨앞 1바이트는 주소의 종류(unicast인지 multicast인지 ???글로벌인지 로컬인지)를 나타낸다.
									ㄴ 나머지 절반이 NIC의 고유번호.
									* 유니캐스트, 멀티캐스트, 브로드캐스트 주소 )
										ㅡ 주소의 종류를 나타내며, 누구한테 보내는지에 따라 분류.
										ㅡ 유니캐스트 : 네트워크상의 특정 한 컴퓨터에게 보내는 주소
										ㅡ 브로드캐스트 : 네트워크상의 모든 컴퓨터에게 보내는 주소
										ㅡ 멀티캐스트 : 네트워크상의 여러 컴퓨터에게 보내는 주소.
							ㄴ MAC 프로토콜 )
								ㄴ 공유 매체에 노드가 어떻게 접근해야하는지에 대한 규칙을 지정한 2계층의 프로토콜.
								ㄴ ~~~~~~~~~~~~~~~~~~~~~
							ㄴ '프레임' 전달 책임.
							ㄴ 상위 계층으로부터 '데이터그램'을 받아 '프레임'으로 캡슐화
							ㄴ 다양한 링크층 프로토콜에 따라 서로 다른 서비스 제공.
						ㅡ 네트워크 층)
							ㄴ 어플리케이션에 관계없고, 컴퓨터를 대상으로 통신한다.
							ㄴ 흐름제어, 오류제어, 혼잡제어 기능을 제공한다.
							ㄴ 대표적 프로토콜로 IP, Internet protocol.
							ㄴ DHCP : IP주소를 동적으로 할당해주는것. 인터넷쓰려면 기본적으로IP필요.
						ㅡ 전송 층)
							ㄴ '통신 종단'이라고 하는게 있고 그걸대상으로 통신한다.
							ㄴ 응용층으로부터 메세지를 전달받아 '패킷'으로 캡슐화.
							ㄴ 4계층에서의 통신 방식 두가지 )
								ㄴ stream 패러다임
									ㄴ 송수신자가 연결된상태에서 통신
									ㄴ 전화통화와 비슷
									ㄴ 1대1통신
									ㄴ 일련의 바이트들을 전송
									ㄴ 보내는 데이터의 크기도 정해져있지않음.
									ㄴ 대부분의 응용프로그램에서 사용
									ㄴ TCP 프로토콜에서사용
								ㄴ message 패러다임
									ㄴ 송수신자가 연결되지않은상태에서 통신
									ㄴ 엽서와 비슷
									ㄴ 다 대 다 통신
									ㄴ 적절한크기의 메세지를 전송
										ㄴ 세가지 방식으로 전송 : Unicast(1대1), Multicast(1대 다), Broadcast(1대 모두)
									ㄴ 특정한 목정의 응용프로그램에서 사용
									ㄴ UDP프로토콜에서 사용.
									ㄴ 메세지가 lost, duplicated, out-of-order될 수 있다.
							ㄴ 대표적 프로토콜로 TCP, UDP, SCTP
							ㄴ TCP : 연결형. 흐름제어, 오류제어, 혼잡제어 제공.
							ㄴ UDP : 비연결형. 편지같은것. 그냥 전달만해줌. 순서나 중간에없어지는것등을 신경안씀. (제어 서비스 제공 안함)
						ㅡ 응용 층)
							ㄴ 프로세스간 통신
							ㄴ 대표적 프로토콜 : HTTP, SMTP, FTP, DNS, TELNET, SSH, SNMP
					ㅡ 캡슐화 역캡슐화)
						ㄴ 캡슐화 : 상위 계층의 데이터에 통신에 필요한 여러가지 정보가 담긴 '헤더'를 추가로 붙이는 작업.
						ㄴ 역캡슐화 : 캡슐화한것을 푸는 과정.
						ㄴ 상위계층으로부터 받은 데이터를 'payload'라고 한다.
					ㅡ 주소지정)
						ㄴ 정보르 받는 목ㅈ거지가 누군지 알려주기위해 주소사용
						ㄴ 어플리케이션층 = 이름, 전송층 = 포트번호, network계층 = logical address(ip 주소), 데이터 링크 층 = 링크층 주소
					ㅡ 다중화, 역다중화)
						ㄴ 계층마다 사용하는 프로토콜들이 다양하고 여러가지라, 계층 넘어갈때 이를 잘 처리해주어야한다.
						ㄴ 소스쪽에서 이런걸 하는것을 다중화라 하고 목적지쪽에선 역다중화라한다.
				ㅡ 인터넷 프로토콜 스위트, Internet Protocol Suite<button>더보기</button>
				<pre>
					ㄴ 인터넷에서 사용되는 통신규약(프로토콜)의 모음을 말함.
						ㄴ TCP/IP가 가장 많이 사용되기때문에 TCP/IP프로토콜 슈트라고도 불린다.
					ㄴ 종류 )
						ㄴ ~~~~~
						ㄴ HTTP <button>더보기</button>
						<pre>
							ㄴ ~~~~~
							ㄴ 헤더<button>더보기</button>
							<pre>
								ㄴ ~~~~~
								ㄴ Content-Type )
									ㄴ 개요 )content에 들은 내용이 어떤 유형의 데이터인지 알려주는 필드.
									ㄴ 구성 )
										ㄴ media-type )
											ㄴ 리소스 혹은 데이터의 MIME type
											* MIME type )<button>더보기</button>
											<pre>
												ㅡ https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types 참고
												ㅡ 개요 )
													ㄴ  Multipurpose Internet Mail Extensions or MIME type 또는 media type
													ㄴ IANA라는 단체에서 이 MIME type에 대한 정의를 관리한다.
													ㄴ 브라우저는 파일 확장자가 아닌 MIME type을 기준으로 url을 처리한다.
												ㅡ 구조 )
													ㄴ 기본적인형태로, (*type*)/(*subtype*) 형태로, whitespace없이 스트링으로 이루어져있다.
														ㄴex) text/html, text/plain,
													ㄴ (*type*) )
														ㄴ video, text 등 데이터타입이 속한 일반적인 대분류같은것.
														ㄴ 두개의 클래스로 분류된다 : 'discrete', 'multipart'
															ㄴ discrete : text파일하나, 오디오파일 하나 등, 파일이 하나인 타입을 말한다.
																ㄴ 종류 )
																	ㄴ application : 다른 타입으로 정할수없는 모든 종류의 파일이 속한다.
																		어떤 특정 방법으로 해석되거나실행될수있는 파일, 다른 특정 프로그램을
																		필요로하는 이진파일 등.
																		ㄴ ex) application/pdf, application/pkcs8, and application/zip
																	ㄴ audio : audio, music파일. ex) audio/mpeg, audio/vorbis
																	ㄴ example :
																	ㄴ font : 폰트 타입 데이터. ex) font/woff, font/ttf, and font/otf.
																	ㄴ image : 이미지, 그래픽 데이터. bitmap vector, animated image, gif등 포함
																		ㄴ ex) image/jpeg, image/png, and image/svg+xml.
																	ㄴ model : 3D object나 scene. ex) model/3mf and model/vml
																	ㄴ text : 텍스트로만 이루어진 데이터. 사람이 읽는 텍스트건 소스코드건.
																		ㄴ ex) text/plain, text/csv, and text/html.
																	ㄴ video : mp4와 같은 비디오 파일.
															ㄴ multipart : 여러개의 파일, 또는 여러개의 타입들로 이루어진 타입임을 나타낸다.
																ㄴ 종류 )
																	ㄴ message : ?????
																	ㄴ multipart : 여러종류의 MIME type을 가진 여러 컴포넌트들이 들어있는 데이터임을
																		나타내는 타입.
																		ㄴ ex) multipart/form-data (html form데이터에 쓰이는것)
													ㄴ (*subtype*) )
														ㄴ 대분류 아래서 구체적으로 MIME 데이터 타입이 무엇인지 결정하는 항목
													ㄴ 추가적인 parameter )
														ㄴ 기본적인 형태 다음부분에 추가적인 파라미터를 추가할 수있다.
															ㄴ (*type*)/(*subtype*);(*parameter*)=(*value*)
															ㄴ ex) text/plain;charset=UTF-8
												ㅡ 자주쓰이는 MIME type 들 )
													ㄴ application/octet-stream )
														ㄴ 이진파일의 디폴트값. unknown binary file같다고 보면되고 브라우저는 이파일을 실행하지 않는다.
													ㄴ application/x-www-form-urlencoded
														ㄴ get메소드 사용시 파라미터를 쿼리스트링으로 ?(*파라미터명*)=(*값*)&(*파라미터명2*)=(*값2*)와
															같은식으로 설정하는것과 같은 방식으로 =으로 값을 설정하고 &으로 파라미터들을 구분하는 방식으로
															데이터를 보냄을 나타내는 형식.
													ㄴ text/plain
														ㄴ 디폴트 텍스트 파일.
													ㄴ text/css
														ㄴ css파일을 나타내는 타입.
														ㄴ css파일은 반드시 이 타입으로 넘어와야함. 아닐경우 css가 입혀지지않음.
													ㄴ text/html
														ㄴ html을 나타내는 타입. html파일들은 반드시 이 타입으로 넘어와야한다.
													ㄴ text/javascript
														ㄴ javascript를 나타내는타입. javascript파일은 반드시 이 타입으로 넘어와야한다.
													ㄴ image/apng
													ㄴ image/avif
													ㄴ image/gif
													ㄴ image/jpeg
													ㄴ image/png
													ㄴ image/svg+xml
													ㄴ image/webp
													ㄴ 오디오 타입들 ~~~~~
													ㄴ multipart/form-date
														ㄴ 'boundary'로 구분된 여러개의 부분으로 구성되어있으며, 각각의부분들은 각각의 http header와
															Content-Disposition, Content-Type, 각각의 데이터들을 가지고 있다.
													ㄴ multipart/byteranges
														ㄴ ~~~~~
											</pre>
										ㄴ charset : 문자 인코딩
										ㄴ boundary )
											ㄴ 일반 content-tyep이 application/x-www-form-urlencoded인 패킷을 보낼때 파라미터를 url뒤에
												name=John&age=12와 같이 &로 파라미터를 구분해서 보내듯이,
												multipart/form-data형으로 보낼때 파라미터구분을 boundary로 하는것.
											ㄴ 	--XXX	//임의로 설정한 boundary값.
												Content-Disposition: form-data; name="name"

												John
												--XXX
												Content-Disposition: form-data; name="age"

												12
												--XXX--
											ㄴ 이렇게 boundary에 설정한 값으로 파라미터를 구분하여 패킷을 만든다.

							</pre>

						</pre>
						ㄴ TLS/SSL )<button>더보기</button>
						<pre>
							ㄴ 개요 )
								ㄴ 보안 목적의 일종의 암호 규약.
								ㄴ Transport Layer Security, TLS, 전송 계층 보안 : SSL이 표준화 되면서 이름이 바뀐것.
								ㄴ Secure Sockets Layer, SSL, 보안 소켓 레이어
								ㄴ TCP/IP 통신에 적용된다.
								ㄴ transport 계층의 종단간 보안과 데이터 무결성을 보장해준다.
								ㄴ url상에 https를 사용하는게 tls/ssl을 사용하고있는것이다.
							ㄴ 동작과정 )<button>more</button>
							<pre>
								ㄴ TLS record )<button>more</button>
								<pre>
									ㄴ TLS 프로토콜을 통한 통신은 'record'라는 것을 교환하는 방식으로 이루어진다.
									ㄴ 'record'란 특정한 형식대로 내부의 데이터를 캡슐화한 데이터 덩어리???
									ㄴ 'content type' 필드('record'가 어떤 데이터를 캡슐화했는지 지칭), TLS version 필드 등을 가진다.
									ㄴ 'content type'필드에 해당 'record'가 따르는 'Record Layer Protocol Type'이 명시되며,
										이 protocol type에 맞게 'rocord'의 형식이 구성된다.
										ㄴ 종류는 'ChangeCipherSpec', 'Alert', 'Handshake', 'Application', 'Heartbeat'
										ㄴ 각 type의 content type필드값은 20, 21, 22, 23, 24.
									ㄴ 'record' 공통적인 형식
										<img src="image/TLS_record_format.png"/>
									ㄴ ChangeCipherSpec 프로토콜
										ㄴ 'record' 형식
											ㄴ ~~~
									ㄴ Handshake 프로토콜
										ㄴ
										ㄴ 'record' 형식
											<img src="image/TLS_record_format_for_handshake_protocol.png"/>
											ㄴ tls 'record' 중, content type이 'handshake'인 경우에 갖는 format.
										ㄴ format에서 'message type'에 가능한 값들. (code, message type 쌍)
											0	HelloRequest
											1	ClientHello
											2	ServerHello
											4	NewSessionTicket
											8	EncryptedExtensions (TLS 1.3 only)
											11	Certificate
											12	ServerKeyExchange
											13	CertificateRequest
											14	ServerHelloDone
											15	CertificateVerify
											16	ClientKeyExchange
											20	Finished
									ㄴ Alter 프로토콜
										ㄴ ~~~
									ㄴ ChangeCipherSpec 프로토콜
										ㄴ ~~~
								</pre>
								ㄴ TLS Handshake 과정 )
									ㄴ 'content type' 22(TLS의 'Record Layer Protocol type' 중 Handshake 프로토콜)인 'record'를 전달하는 것으로 tls 연결 시작.
									ㄴ 클라이언트와 서버 상황이나 여건 등에 따라 여러가지 방식 중 하나로 handshake 과정이 진행된다.
									ㄴ 세션 id, random number, ~~~
										ㄴ ~~~
									ㄴ 기본 handshake 과정
										ㄴ negotiation phase
											ㄴ client가 서버로 'ClientHello' 메세지 전송.
												ㄴ 클라이언트가 지원 가능한 가장 최신의 TLS버전, 랜덤 숫자, 지원 가능한 'cipher suite' 목록,
													지원 가능한 압축 방식 목록 명시.
												ㄴ handshake 단계를 재개하려는 것이면 session id 전달.
												ㄴ ??? If the client can use Application-Layer Protocol Negotiation, it may include a list of supported application protocols, such as HTTP/2.
											ㄴ 서버가 client에게 'ServerHello' 메세지 전송.
												ㄴ 선택한 TLS 버전, 랜덤 숫자, 클라이언트가 전해준 'cipher suite', 압축 방식 목록 중 선택된 것들을 명시.
												ㄴ TLS 버전은 클라이언트와 서버 둘다 지원가능한 버전 중 가장 최신 버전 선택.
											ㄴ 서버가 'Certificate' 메세지 전달.
											ㄴ ??? 서버가 'ServerKeyExchange' 메세지 전달?
											ㄴ 서바가 'ServerHelloDone' 메세지 전달. negotiation 단계가 완료되었음을 명시.
											ㄴ ??? 클라이언트가 'ClientKeyExchage' 메세지 전달.
											ㄴ ???
										ㄴ 클라이언트가 'ChangeCipherSpec' 메세지 전송
											ㄴ ~~~
										ㄴ 서버가 'ChangeCipherSpec' 메세지 전송
											ㄴ ~~~
										ㄴ application phase
											ㄴ handshake 단계 완료이고, 'record'의 'content type' 23을 통하여
												application protocol('Record Layer Protocol type' 중 application protocol)이 활성화된다.
									ㄴ Client-authenticated TLS handshake
										ㄴ ~~~
									ㄴ Resumed TLS handshake
										ㄴ ~~~
									ㄴ TLS 1.3 handshake
										ㄴ ~~~
								ㄴ [웹브라우저] SSL로 암호화된 페이지를 요청하게 된다. (일반적으로 https://가 사용된다)
								ㄴ [웹서버] Public Key를 인증서와 함께 전송한다.
								ㄴ [웹브라우저] 인증서가 자신이 신용있다고 판단한 CA(일반적으로 trusted root CA라고 불림)로부터 서명된 것인지
									확인한다. (역주:Internet Explorer나 Netscape와 같은 웹브라우저에는 이미 Verisign, Thawte와 같은 널리
									알려진 root CA의 인증서가 설치되어 있다) 또한 날짜가 유효한지, 그리고 인증서가 접속하려는 사이트와 관련되어
									있는지 확인한다.
									ㄴ 인증서가 CA에서 나온 것인지 검증하는 방법
										ㄴ 보통 브라우저는 CA의 공개키를 가지고 있다
										ㄴ CA의 인증서는 CA의 비밀키로 암호화 되어 있다.
										ㄴ 브라우저가 서버로부터 받은 인증서가 CA의 공개키로 복호화에 성공한다면 CA로부터 나온 인증서라 검증할 수 있다.
								ㄴ 통신에 사용할 '세션키(대칭키)?' 결정
									??? 아래 두 가지 중 어떤 방식이 실제로 적용되는지는 모르겠다. 이론으로만 확인한 것이라. 비슷한 내용이긴 한데..
									ㄴ 웹브라우저와 웹서버가 이후의 보안 통신에 사용할 '세션키'를 생성한다.
										ㄴ 생성 방법
											ㄴ 브라우저가 웹서버에서 넘어온 공개키로 임의의 랜덤 숫자를 암호화하여 서버로 전달. 서버는 개인키로 이를 복호화하고,
												이 랜덤 숫자를 이용하여 세션키 생성.
											ㄴ ??? Diffie-Hellman key exchange 사용?
										ㄴ 이후, 이 '세션키'를 사용하여 이후의 통신이 암호화, 복호화된다. (통신 데이터 암호화의 대칭키인셈)
									ㄴ [웹브라우저] Public Key를 사용해서 랜덤 대칭 암호화키(Random symmetric encryption key)를 비릇한 URL,
										http 데이터들을 암호화해서 전송한다.
										그리고 [웹서버] Private Key를 이용해서 랜덤 대칭 암호화키와 URL, http 데이터를 복호화한다.
								ㄴ [웹서버] 요청받은 URL에 대한 응답을 웹브라우저로부터 받은 랜덤 대칭 암호화키를 이용하여 암호화해서 브라우저로
									전송한다
								ㄴ [웹브라우저] 대칭 키를 이용해서 http 데이터와 html문서를 복호화하고, 화면에 정보를 뿌려준다
							</pre>
							ㄴ ??? 도메인에 적용되는 것이기 때문에 한 도메인을 여러 서버에서 사용하는 경우, 각 서버들에 인증서를 설치하여 ssl접속을 할 수 있다.
							ㄴ 인증서 )
								ㄴ ~~~
								ㄴ 도메인별 분류 )
									ㄴ single domain
										ㄴ 한 인증서에 단 하나의 도메인에 대해서만 인증이 가능.
										ㄴ ex ) deepq.kr
									ㄴ multi domain
										ㄴ 한 인증서에 여러개의 도메인에 대해서 인증 가능.
										ㄴ ex ) app.deepq.kr, www.deepq.kr, deepq.kr
									ㄴ wildcard domain
										ㄴ 한 인증서에 와일드카드 패턴과 일치하는 도메인에 대해서 인증 가능.
										ㄴ ex ) *.deepq.kr => app.deepq.kr (O), aaa.deepq.kr (O), www.aaa.deepq.kr (X),
								ㄴ 등급별 분류 )
									ㄴ
									ㄴ DV (Domain Validation)
										ㄴ 도메인의 소유 정보만을 인증.
									ㄴ OV (Organization Validation)
										ㄴ 소속되어있는 회사, 조직 정보 인증
									ㄴ EV (Extended Validation)
										ㄴ OV에서 추가적인 부분 인증.
										ㄴ 인증을 받기 위한 추가적인 까다로운 조건 존재.
										ㄴ 은행 및 공공기관.
							ㄴ 질문 )
								ㄴ ??? 왜 공개키, 비밀키를 이용해 통신 데이터를 암호화하지 않고 대칭키를 따로 만드나?
									ㄴ 당연히 공개키는 모든 브라우저가 가지고 있는 것이고,
										브라우저에서 보내는 데이터는 해독 못한다쳐도 이는 서버에서 개인키로 암호화된 데이터가 제3자에 의해 해독될 수 있다는 것이니까?
										그래서 세션키를 공개키로 암호화해서 보내고 이후부터는 세션키로 데이터를 암호화하는 것?
							ㄴ SNI (=Server Name Indication)<button>more</button>
							<pre>
								ㄴ TLS의 확장 프로토콜.
								ㄴ 클라이언트가 어떤 호스트명의 서버에 대해 ssl연결을 시도하는지(ssl handshake 과정을 하려하는지)를
									지정하게 해주는 프로토콜.
									ㄴ 클라이언트가 tls handshake단계(client hello)시에 가상 도메인명을 함께 보냄.
									ㄴ 이를 통하여, 서버가 동일한 ip, port에 대해 여러개의 ssl 인증서가 있을 때,
										이중 어떤 것을 handshake 과정에서 넘겨주어야 하는지 알 수 있게 해준다.
									ㄴ 멀티 인증서나 와일드카드 인증서를 통해, 단 하나의 인증서에 모든 도메인을 담을 필요 없이,
										여러 인증서를 가지고 있으면서 도메인명에 따라 선택적으로 알맞은 ssl 인증서를 넘겨줄 수 있다.
									ㄴ 함께 전달되는 호스트명은 암호화되지 않는다.
								ㄴ 배경 )
									ㄴ tls handshake 단계에서 인증서를 교환해야 하는데, 이는 application protocol 이전 단계라고 한다.
										ㄴ 특정 프로토콜이 정확히 어떤 계층에 속하는지 분명하게 구분될 수는 없지만
											tls handshake 단계는 https와 같은 application 프로토콜이 동작하기 이전 단계라고 한다.
									ㄴ 따라서, tls handshake 단계에선 도메인명과 같은 http header정보를 읽을 수 없다.
									ㄴ 기존 TLS연결에선, 클라이언트가 서버로 어떤 사이트에 대한 요청을 보내는 것인지 명시할 수 없었다.
										따라서, 한 서버에서 여러 사이트를 호스팅하고 이 사이트들에 대한 인증서들이 각자 있는 경우,
										서버가 어떤 사이트에 대한 인증서를 넘겨주어야 할지 알 수 없었다.
										~~~
										HTTP 연결에선 'name-based virtual hosting'을 통하여 한 서버, 한 ip에서 여러 dns를 호스팅하는게 가능하다.
									ㄴ HTTPS 연결에선, TLS handshake 단계에선 http header를 읽을 수 없기 때문에 이러한
										'name-based virtaul hosting'이 불가능하다.
										이로인해, 인증서가 여러개 있는 경우, 호스트명에 따라 어떤 인증서를 넘겨줘야 하는지 알 수 없다.
								ㄴ 클라이언트와 서버 둘다 SNI를 구현해야 동작한다.
									ㄴ 2022.12.26기준 대부분의 주요한 브라우저, 서버, 소프트웨어들이 이를 구현하고 있다.
										ㄴ 참조 ) https://en.wikipedia.org/wiki/Server_Name_Indication#Support

								ㄴ SNI was added to the IETF's Internet RFCs in June 2003 through RFC 3546,
									Transport Layer Security (TLS) Extensions.
							</pre>
						</pre>
						ㄴ DHCP <button>more</button>
						<pre>
							ㄴ Dynamic Host Configuration Protocol
							ㄴ Internet Protocol Suite에서 application layer에 속하는 프로토콜이다.
							ㄴ Internet protocol에서 ip address를 할당할 때 사용된다.
								ip를 자동으로 할당하여 개별 장치마다 수작업으로 ip설정을 할 필요 없게 해준다.
							ㄴ ??? HAN ~ CAN 범위까지 모두 구현이 가능하다?
							ㄴ ??? 많은 라우터와 지역 게이트웨이에 적용이 가능하다?
							ㄴ 라우터가 ISP로부터 유일한 ip address를 받으면, dhcp가 로컬 장치들에게 로컬 ip address들을 자동으로, 동적으로 할당해준다.
							ㄴ IP v4, v6에 적용되는 프로토콜이다.
							ㄴ ??? 컴퓨터나 장치가 네트워크에 접속하면 DHCP 클라이언트가 DHCP broadcast 쿼리 요청을 보낸다.
								네트워크 내의 DHCP서버는 이 요청을 처리한다. 관리자에 의해 이전에 설정된대로 특정한 정보를 반환해주거나, 전체 네트워크와 특정 시간동안 유효한 ip address 및 정보들을 반환해준다.
								DHCP서버는 가능한 ip address pool과 각 클라이언트들의 설정 정보(디폴트 게이트웨이, 도메인명, name servers, time servers 등)을 가지고 관리한다.
								DHCP 클라이언트는 부팅시에 또는 DHCP서버로부터 받은 정보 유효시간 만료 직전에 쿼리요청을 보낸다.
							ㄴ ??? On large networks that consist of multiple links, a single DHCP server may service the entire network when aided by DHCP relay agents
								located on the interconnecting routers. Such agents relay messages between DHCP clients and DHCP servers located on different subnets.
							ㄴ DHCP 서버는 ip 할당을 위한 세가지 방법을 가진다
								ㄴ 동적할당 )
									ㄴ 관리자에 의 해 설정된 ip address 범위가 정해져있고, 클라이언트는 네트워크 초기화시 서버에 ip 주소를 요청하도록 되어있다.
									ㄴ 서버는 유효 기간이 있는 ip주소를 할당하고 이후 이를 회수 후 재할당하는 방식.
								ㄴ 자동할당 )
									ㄴ 관리자에 의해 설정된 ip address 범위 내에서, DHCP서버가 클라이언트에게 영구적인 ip주소를 할당한다. 서버가 과거 ip 할당 테이블을 가지고 있어 이전에
										클라이언트가 가지고 있던 ip가 할당되도록 한다.
								ㄴ 수동 할당 )
									ㄴ static DHCP 할당, fixed address 할당, reservation, MAC/IP address binding이라고도 불린다.
									ㄴ 서버가 클라이언트로부터 받은 클라이언트의 유일한 식별값(id 또는 mac address)과 ip를 연결해 고정한다.
									ㄴ 실패시 다른 방법을 사용한다.
							ㄴ 동작과정 )
								ㄴ ??? connectionless 서비스 모델을 따른다?
								ㄴ udp 프로토콜을 사용하여 클라이언트와 서버가 통신한다. 서버는 67 port, 클라이언트는 68port 사용.
								ㄴ 서버 인식, 임대 요청, 임대 제공, 임대 인식의 단계를 가진다.
								ㄴ 시작은 클라이언트가 네트워크로 브로드캐스트 요청을 전송.
									한번 요청하여 할당받은 후, 다음 요청시엔 서버의 ip를 앎으로 unicast 요청을 전송.
								ㄴ ~~~
						</pre>
						ㄴ ~~~~~

				</pre>

                ㅡ WebSocket
                    ㄴ 하나의 TCP연결에서 양방향 통신을 가능하게 해주는 프로토콜
                    ㄴ IETF RFC 6455에서 표준화.
                    ㄴ OSI model 7계층, TCP 4계층에 해당. HTTP와 엄연히 구분됨.
                    ㄴ ??? HTTP port(443, 80)과 HTTP proxy를 지원한다함. 즉, HTTP와 호환되도록 설계됨.
                        ㄴ 호환을 위해 WebSocket handshake 단계에서 'HTTP Upgrade header'를 사용하여
                            http protocol을 websocket protocol로 변경한다함.
                    ㄴ 배경
                        ㄴ 과거 웹 상에서 클라이언트와 서버 사이에 양방향 통신을 위해선
                            http polling 방식 사용.
                            tcp연결을 두개를 사용하며 한쪽은 c->s 방향으로 데이터 전송,
                            한쪽은 s->c로의 데이터 받기 위해 서버로 요청 보내 받아오는 방식.
                            ~~~
                        ㄴ 이러한 HTTP를 이용한 양방향 통신 기법을 대체하고자 생김.
                    ㄴ ??? 두 부분으로 구성?
                        ㄴ handshake
                            ㄴ opening handshake
                                ㄴ http와 호환되도록 설계.

                        ㄴ data transfer
                            ㄴ 양쪽에서 데이터 전송이 가능한 통신.
                            ㄴ client와 server가 "message"라 불리는 데이터를 주고 받음.

			</pre>

			ㅇ OSI 모델
				ㅡ 국제 표준화 기구 (ISO)에서 만든 계층 모델.
				ㅡ OSI 7계층 )
					ㄴ Application, presenstation, session, transport, network, data link, physical 으로 나뉜다.
				ㅡ TCP/IP에 밀려 널리 사용되지 못함.

			ㅇ 회선 교환 방식, 패킷 교환 방식<button>더보기</button>
			<pre>
				ㅡ Packet Switched Network ) 패킷 교환 방식
					ㄴ 보내려는 데이터를 '패킷'이라는 단위로 잘라 보내는식으로 통신하는 방식.
					ㄴ 인터넷 등의 기반이되는 방식.
					ㄴ '공유 매체'를 통하여 여러 사용자가 이를 나누어 통신한다.
					ㄴ 비동기 통신이라 볼수있다.
				ㅡ Circuit Switched Network ) 회선교환방식
					ㄴ 두 종단이 한 회선을 일정시간동안 독점적으로 차지하고 통신을 하는 방식.
					ㄴ 통신의 쌍 사이에 point-to-point 통신을 제공해준다.
					ㄴ circuit를 creation, use, termination 단계를 거친다.
					ㄴ Circuit는 영구적일수도있고 아닐수도있다.
			</pre>

			ㅇ 포트
				ㅡ 네트워크 상에서 어떤 컴퓨터를 특정하기 위해 필요한게 ip주소이고, 그 컴퓨터 안에서 어떤 프로그램에 데이터를 넘겨줄지를 특정하기 위해 필요한것이 포트번호이다.
				ㅡ 컴퓨터에서 프로그램마나 포트 번호를 할당하여 해당 포트로 데이터가 넘어올시, 그 프로그램으로 데이터를 전송해주는 방식.
				ㅡ 포트 번호 )
					ㄴ 일반적으로 0~1023 은 미리 특수용도로 지정되어 있다고한다.
					ㄴ 21 : ftp
					ㄴ 22 : ssh
					ㄴ 25 : smtp
					ㄴ 80 : http 등등.
				ㅡ 포트 포워딩 )
					ㄴ

			ㅇ 소켓 프로그래밍
				ㅡ 웹을통해 request, response을 이용한 통신말고도 소켓을 이용한 프로그램의 통신도 가능하다.
					ㄴ 대충간단히말해, 임의의 포트를 이용해 연결을 만든뒤, 이 경로로 통신하는 방식?
					ㄴ socket api를 이용한다.

			ㅇ Proxy 서버
				ㅡ 일단은 그냥 클라이언트와 서버 사이에 위치하여, 요청,응답이 중간에 한번 거쳐가는 중계하는 서버.
					ㄴ 클라이언트로부터 요청을 받아 내부처리를 하고, 서버로 보내주고, 서버로부터 데이터를 받아서 클라이언트에게 보내준다.
					ㄴ 요청과 응답을 중간에서 가로채서 할 수 있는 다양한 기능들을 한다.
				ㅡ 유형 )
					ㄴ forwrad proxy )
						ㄴ Client - proxy - internet - server
							위 위치에 존재하는 프록시 서버.
					ㄴ reverse proxy )
						ㄴ Client - internet - proxy - server
							위 위치에 존재하는 프록시 서버.
				ㅡ 보안상의 목적(서버는 클라이언트에대해 아는게 없게된다), 개인정보, 로드벨런싱 등의 목적으로 사용한다고함.
				ㅡ 스크래핑에서의 프록시 )
					ㄴ forward 프록시를 사용하여,
						ip추적을 통한 스크래핑 차단을 방지한다.
					ㄴ 쉽게 찾을 수 있는 free proxy들은 전세계의 누구나 사용 가능한 ip들이기 때문에 금방 막히고 보안상 안전하지도 않다.

			ㅇ 네트워크 일부..
				ㅡ NOS : 컴퓨터간 네트워킹이 가능하게 해주는 os.
					ㄴ 따라서 윈도우나 리눅스 등도 nos에 속하는것.

			ㅇ 웹서버
				ㅡ ??? 그냥 클라이언트 서버 관계에서 서버역할을 하는 소프트웨어를 추상적으로 가리키는 말인가?
				* 프로그램에서 file open의 의미 : 파일 io는 os에서 담당해준다하고, file open을 시켜주는 api를 사용하는것은 os에게 현재 프로그램이 해당 파일과
					작업을 할것임을 알리는 기능이라함. 당연히 권한에 따라 가능하면 허가, 아니면 불가.
					ㅡ 이 라이브러리를 통해 데이터 input/output을 위한 '스트림'을 생성하는 것이라함.
					ㅡ stdin, stdout역시 스트림을가리키는 포인터라고함. 프로그램실행시 os가 자동으로 만든다고한다.

			ㅇ Global IP Internet<button>more</button>
            <pre>
				ㅡ ip 프로토콜
					ㄴ naming scheme와 delivery mechanism을 제공한다.
					ㄴ '데이터그램'이라 불리는 패킷을 보낸다.
					ㄴ'unreliable'하다. 중복이나 손실된 데이터그램에 대한 처리가 없기때문.
				ㅡ tcp 프로토콜
					ㄴ 호스트간이 아니라 프로세스간 양방향 연결을 하게해주는 프로토콜.
				ㅡ 프로그래머의 관점에서, 우린 인터넷을 다음 세가지 조건을 만족하는 넓은 호스트들의 집합이라고 볼 수있다.
					ㄴ 호스트들은 32비트 ip주소와 매핑된다.
					ㄴ ip주소들은 인터넷 도메인 이름과 매핑된다.
					ㄴ 호스트에있는 프로세스는 다른 호스트에 있는 프로세스와 통신 할 수 있다.
				ㅡ IP Address )
					ㄴ unsigned 32 bit integer 값이다.
					ㄴ 네트워크 프로그램들은 ip 주소를 'IP address structure'에 저장한다.
						ㄴ 구조체에 저장하는 이유는 특별한게 없고 처음에 그렇게 만들었는데 바꾸기엔 너무 늦어서.
					ㄴ 호스트마다 바이트 정렬 순서가 다를 수 있기 때문에 tcp/ip 프로토콜에서 '빅엔디안'으로 통신하도록 바이트정렬순서를 정의 .
					ㄴ 유닉스에선 호스트용 바이트 정렬순서와 네트워크용을 상호 변환해주는 함수들을 제공한다.
					ㄴ ip주소는 'dotted decimal notation'형태로 사람들에게 보여진다. ex) 128.2.194.242
						ㄴ 이를 변환해주는 함수 역시 제공.
				ㅡ Internet Domain Names )
					ㄴ 사람들이 쓰기 쉽도록 ip주소와 이름을 매핑시켜주는것
					ㄴ 계층적 형태이다.
						ㄴ 예로 kittyhawk.cmcl.cs.cmu.edu 라는 도메인 주소가 있으면
						ㄴ 뒤에서부터 edu가 첫번째 레벨의 도메인 이름, cmu가 그다음 이런식.
					ㄴ 옛날엔 HOSTS.txt라는 일반 텍스트 파일에 저장되었는데 현대에는 분산 world-wide 데이터베이스 (DNS)에서 유지관리하고잇다.
						ㄴ 이안에 'host entry structure'의 형태로 무수히 많은 entry들이 저장되어 있으며 (896페이지에 entry structure 형태)
						ㄴ 각 entry는 도메인 이름과 ip주소를 가지고있어 매핑을 할수있게해준다.
						ㄴ 도메인이름이나 ip주소를 인자로 넘겨 해당 entry를 가져오는 함수를 제공한다. ( gethostbyname(), gethostbyaddr() )
					ㄴ 'localhost'는 해당 같은 기계에서 동작하는 클라이언트와 서버를 참조하기 위해 사용되는 편리한 방법이다.
					ㄴ 한 도메인 네임이 하나의 ip주소와 매핑될 수도 있지만, 여러 도메인이 한 ip주소에 매핑되거나, 여러 도메인이 여러 ip주소에매핑되거나
						도메인이 ip주소에 매핑되지 않을 수도 있다.
				ㅡ Internet Connection )
					ㄴ 클라이언트와 서버는 connection을 통해 바이트 스트림을 주고받는것을 통하여 통신한다.
						ㄴ 이는 '점대점'이며, '양방향'이다.
					ㄴ 소켓은 connection의 종단점이다. 각 소켓은 internet 주소와 16bit port로 이루어진 '소켓 주소'를 가진다. (*address*) : (*port*) 로 표현.
					ㄴ 클라이언트의 소켓주소는 커널에 의해 자동적으로 할당된다. 반면 서버의 소켓주소는 well-known port와 연결된다.
					ㄴ 양끝단의 소켓주소 쌍을 통해 연결은 유일해지며, 이쌍을 tuple이라고 부른다.
						( 클라이언트주소 : 클라이언트 포트 ,  서버주소 : 서버 포트 )
            </pre>

			ㅇ 소켓 인터페이스
				ㅡ 네트워크 어플리케이션을 만들기위해 Unix i/o 함수와 함께 사용되는 함수의 집합.
				ㅡ CSAPP책 901페이지 소켓의 동작 전체 뷰.
				ㅡ 소켓 API : 컴퓨터에 내장되어있는 프로토콜 통신 프로그램.

			ㅇ

		</pre>

		JPA, Hibernate(하이버네이트)<button>더보기</button>
		<pre>
			ㅇ 소개<button>더보기</button>
			<pre>
				ㅡ JPA의 간단 설명 : SQL언어를 직접 코딩하여 db를 사용할 필요없이 간단한 메소드 등을 사용하는 것만으로 할 수있게해준다.
				ㅡ 강의 목표 )
					ㄴ 객체와 테이블 설계 : JPA가 강력하기는 하나, 객체와 테이블의 매핑을 제대로 하지 못하면 실무의 복잡한 상황에서 사용하기 어렵다.
					ㄴ JAP 내부 동작 방식이해 : 이걸 제대로 이해못하면 당연히 제대로 사용하지 못함.
						ㄴ JPA가 어떤 SQL을 만드는지
						ㄴ 이 SQL을 JAP가 언제 실행하는지
				ㅡ JPA학습 방법 )
					ㄴ 표준 스펙만 500페이지라 혼자 공부하기 어렵.
					ㄴ 강의에서는.. )
						ㄴ 이론과 라이브 코딩으로 설명
						ㄴ 6단계의 실전 예제
						ㄴ 강의를 메인으로 하고 책을 참고하는걸 추천. (강의에선 실무적인 느낌이 강하고 책에서 더 디테일한 내용들이 있으므로)
				ㅡ JPA 많이 사용하는지 )
					ㄴ 전세계적으로 한국에서의 경쟁자인 mybatis에 비해 훨씬많고
					ㄴ 한국안에서는 mybatis가 더많기는 하나 거의 따라잡았다고한다.
				ㅡ 강사의 JPA실무 경험담 )
					ㄴ sql 작성 노가다에 드는 시간이 없어져서 다른곳에 투자가능했다는게 가장 좋았다.
			</pre>

			ㅇ JPA 소개<button>더보기</button>
			<pre>
				ㅡ SQL중심적인 개발의 문제점 )<button>더보기</button>
				<pre>
					ㄴ 현재는 객체지향언어와 관계형DB가 가장 많이 쓰인다. 따라서 객체를 관계형 DB에 저장하여 관리해야함.
					ㄴ 근데 관계형DB를 다루기위해서 SQL언어를 사용해야하는데 이러다보니 코드상에 중심이 sql문이라 할정도로 많이 사용되어야
                        한다는 문제점이 있다.
						따라서 무한반복, 단순하고 지루한 코드가 된다.
						ㄴ 매번 똑같은 select, insert, update sql문들이 반복됨.
						ㄴ 이러한 코드상에 있는 sql문들이 유지보수 및 수정, 개발과정에서 좋은 요소가 아닌라는 점.
						ㄴ 이렇게 반복되는 sql코드들을 jpa를 이용하면 엔터티라는 객체를 중심으로 하는 코드로 대체할 수 있다.
							ㄴ 엔터티 객체에 대해 속성을 수정하고(update), 새 객체를 생성하고(insert), 객체를 가져오고(select) 등.
					ㄴ 패러다임의 불일치 )
						ㄴ 객체지향과 관계형 데이터베이스의 패러다임이 너무 다르다.
						ㄴ 근데 이걸 같이 사용하려고하니까 문제가 생김.
					ㄴ 객체와 관계형 데이터베이스의 차이 )
						ㄴ 상속 )
							ㄴ 객체에는 상속관계라는게 있다. RDB에서는 'Table슈퍼타입 서브타입 관계'라는게
								객체의 상속관계와 그나마 가장 유사하다.
								<img src="image/객체지향의 상속과 RDB.png" height="300px"/>
							ㄴ 'Table슈퍼타입 서브타입관계'로 객체의 상속을 표현하려고하면 매우 복잡하다.
								ㄴ 강좌에서 간단한 예로 설명.
							ㄴ 만약 데이터를 자바 컬렉션에 저장한다면? )
								ㄴ list.get, list.add()등으로 간단하게 데이터의 삽입과 삭제가 가능하고
								ㄴ 컬렉션은 자바 클래스이니까 상속관계도 잘 표현할수있다.
								ㄴ 근데 컬렉션이 아닌 RDB로 상속을 표현하려하니 매우 복잡.
						ㄴ 연관관계 )
							ㄴ 객체는 '참조'를 사용하여 다른 객체를 가져와 사용. RDB는 PK, Fk를 통해 조인을하여 참조.
							ㄴ 객체A가 객체B를 참조하면, A는 B를 참조하지만 그렇다고 B가 A를 참조할수있지는 않다.
								RDB는 조인으로 양방향 참조가 가능하다. (자세한건 이후에 설명)
						ㄴ ~~~~~~~~~~~~~~~~~
				</pre>

				ㅡ JPA 소개 )<button>더보기</button>
				<pre>
					ㄴ Java Persistence API. 자바 진영의 ORM기술 표준.
					ㄴ ORM 이란? )
						ㄴ Object-relational mapping. 객체와 관계형 데이터베이스간의 매핑을 말함.
						ㄴ 객체는 객체지향대로 개발하고, RDB는 RDB답게 개발을 하면 ORM이 중간에서 잘 연결을 해주는것.
					ㄴ JPA의 동작 )
						ㄴ 어플리케이션과 JDBC사이에서 동작
							ㄴ 어플이 JPA에게 명령하면 JPA가 JDBC API를 사용하여 db와 작업을 하는식.
						ㄴ 저장 ) JPA에게 객체를 넘기면 JPA가 그 객체를 분석하고 적절한 SQL을 생성하고 JDBC api를
							이용해서 RDB와 통신.
						ㄴ 조회 ) PK와 함께 정보를 JPA에게 넘겨주면 JPA가 적절한 SQL을 생성해서 JDBC사용하여
							RDB와 통신. 결과 ResultSet을 객체에 다 매핑해줌.
					ㄴ 역사 )
						ㄴ 처음엔 EJB라는 자바 표준 ORM을 사용.
							ㄴ 여러면에서 부족했음.
						ㄴ 하이버네이트라는 오픈소스가 나옴.
						ㄴ 자바 진영에서 하이버네이트를 참고하여 JPA라는 자바표준 ORM을 발표.
					ㄴ 사실상 JPA는 인터페이스의 모음.
						ㄴ 대표적 구현체 3가지 : 하이버네이트가 가장 많이쓰임.
					ㄴ JPA 장점 )
						ㄴ 생산성 )  jpa.persist(member), jpa.find(memberId), member.setName("~~"), jpa.remvoe(member)
							와 같이 간단하게 RDB에 CRUD를 수행할수있다.
						ㄴ 유지보수 ) 수정사항이 생겼을때 코드상의 SQL문을 수정할 필요가 없다.
						ㄴ 패러다임의 불일치 해결 )
							ㄴ 상속 )
								ㄴ <img src="image/객체지향의 상속과 RDB.png" />
								ㄴ JPA가 알아서 내부적으로 조인을 수행하여 필요한 정보들을 가져옴.
						ㄴ 성능 최적화 )
							ㄴ JPA를 사용해서 성능이 떨어지지 않을까라는 이슈가 있다.
							ㄴ JPA라는 중간계층이 있기때문에 버퍼링, 캐싱기능을 가질수있어 성능최적화가 가능하다.
							ㄴ 캐싱 (유사한) 기능 )
								ㄴ 같은 트랜젝션 안에서는 같은 엔터티를 반환한다.
								ㄴ ex)	String memberId = "100";
									Member m1 = jpa.find(Member.class, memberId);
									Member m2 = jpa.find(Member.class, memberId);
									=>m1, m2가 한 트랜젝션 안에서 수행된다면 같은 엔터티 객체를 반환.
							ㄴ 지연 기능 )
								ㄴ 트랜젝션 '커밋'기능이 있어 이걸 하기전에 여러 작업을 하고 커밋을 하면
									한번에 작업내용들이 전송된다.
								ㄴ 작업할때마다 db와 통신할필요가 없기때문에 성능 최적화 효과가 있다.
									ㄴ 작업한 내용을 모아두었다가 한꺼번에 보내는 '버퍼링'같은 효과가 있다.
								ㄴ JDBC BATCH SQL기능을 내부적으로 사용한다.
							ㄴ 지연 로딩과 즉시 로딩 )
								ㄴ 지연 로딩 : jpa를 통해 가져온 객체를 실제 사용할때 로딩하여 가져온다.
								ㄴ 즉시 로딩 : 지연로딩이 아닌 항상 데이터를 모두 가져오는 방식.
					ㄴ ORM은 객체와 RDB 두 기둥 위에잇는 기술이다.
						ㄴ 객체지향과 RDB 둘다 잘해야 ORM을 잘 사용할 수 있다
				</pre>
			</pre>

            ㅇ JAP 시작하기<button>더보기</button>
			<pre>
				ㅡ hello jpa 프로젝트 생성 )
					ㄴ h2 db, maven,사용
						ㄴ
					ㄴ jpa 사용을 위해 'persistency.xml'을 resource/MEAT-INF 안에 만들어야함.
						ㄴ
					* 데이터베이스 방언
						ㄴ jpa는 특정 db에 종속되지 않도록 설계.
						ㄴ db마다 표준적으로 같은 부분이 많지만 문법같은게 조금씩 다른부분이 있는데 이런 부분을 db방언이라고 한다.
						ㄴ jpa가 이런부분들을 알아서 변환해준다.
							ㄴ jpa persistence.xml에 'dialect' 속성으로 설정만 해주면 이 방언을 알아서 변환해준다.
				ㅡ hello jpa 어플 개발 )
					ㄴ jpa 구동 방식 )
						ㄴ 'Persistence'라는게 persistence.xml의 설정정보를 확인하여 'EntityManagerFactory'를 만들고 이 팩토리에서
							'EntityManager'라는걸 생성해내는 식이다.
					ㄴ entitymanagerfactory : db당 하나만 생성
					ㄴ entityManager : 요청이 올때마다 생성.
						ㄴ 스레드간 공유해서는 안된다.
					ㄴ JPA의 모든 데이터 변경은 '트랜잭션'안에서 수행되어야 한다.
					* JPQL )
						ㄴ ex) entityManager.createQuery("select m from Member as m", Member.class)
							.setFirstResult(5)
							.setMaxResults(8)
							.getResultList();
						ㄴ 하나의 엔터티 객체가 필요한게 아니라 원하는 임의의 형태의 데이터를 검색하려할때 결국 검색쿼리를 사용해야 하는데,
							이때 엔터티 객체를 대상으로 쿼리문을 만들어 사용하는거라고 보면 된다.
							ㄴ 실제 rdb 테이블이 아닌 엔터티 객체를 대상으로 쿼리를 작업함으로서 rdb에 종속되지 않고 객체지향을
								유지할수있다.
						ㄴ sql문법에 있는 select, from, where, group by, join 등이 지원.
						ㄴ db에 따라서 다른 db 방언을 알아서 변환해줌.
						ㄴ 이후에 자세히 공부한다.
			</pre>

            ㅇ ??? 아키텍처
                ㅡ SessionFactory
                    ㄴ ???
                    ㄴ jakarta의 EntityManagerFactory와 동일.
                ㅡ Session
                    ㄴ ???
                    ㄴ jakarta의 EntityManager와 동일
                    ㄴ jdbc의 connection을 wrap.
                    ㄴ org.hibernate.Transaction의 팩토리처럼 사용???
                ㅡ Transaction
                    ㄴ ???
                    ㄴ jakarta의 EntityTransaction과 동일.

			ㅇ 영속성 컨텍스트<button>더보기</button>
			<pre>
				ㅡ 영속성 컨텍스트란?
					ㄴ JPA의 논리적 개념.
					ㄴ 엔터티를 영구 저장하는 곳을 의미. EntityManager의 persist( (*객체*) )를 통해 이곳에 저장할수있다.
                    * EntityManager
                            ㅡ 영속성 컨텍스트와 상호작용하는데 사용되는 interface.
                                entityManager가 제공하는 api들을 통하여 영속성 컨텍스트와 상호작용하여 엔터티들을 다룰 수 있다.
					ㄴ 영속성 컨텍스트에 저장만 되는것이고 db에 저장된느건 아님.
						ㄴ db저장은 이후 transaction.commit()을 통해 영속성 컨텍스트에 있는 정보들이 db에 저장됨.
					ㄴ EntityManager하나당 PersistenceContext가 하나 생성된다.
					ㄴ 영속성 상태들, 엔터티 생명주기 )
						ㄴ 비영속(transient) : 그냥 객체만 생성된상태
						ㄴ 영속(managed, persistent) : 영속성 컨텍스트에 저장된상태
						ㄴ 준영속(detached) : 영속이었다가 detached를 통해 영속성 컨텍스트에서 분리된상태
						ㄴ 삭제(removed) : 	db삭제 상태.
				ㅡ 영속성 컨텍스트의 이점 )
					ㄴ 캐싱과 유사한 기능 )
						ㄴ 영속성 컨텍스트 안에는 '1차 캐시'
						ㄴ 엔터티 객체를 저장시 1차 캐시에 저장된다.
						ㄴ pk값과 Entity객체 쌍으로된 값을 1차캐시에 저장된다.
						ㄴ 엔터티 객체 조회시 1차 캐시에서 먼저 찾는다.
						ㄴ 없으면 db에서 찾아서 있으면 이를 1차캐시에 저장하고 값을 넘겨준다.
						ㄴ 실무에서 사실상 큰 도움은 안되는 이점. 동작을 이해한다는 면에서 도움.
					ㄴ 엔터티의 동일성 보장 )
						ㄴ 같은 트랜잭션 안에서 가져온 같은 엔터티 객체는 '동일'하다. ('동등'말고)
					ㄴ 쓰기 지연 )
						ㄴ 위의 'JPA의 장점' - '성능 최적화' 부분의 '지연 기능'과 같은 이야기.
						ㄴ EntityManager의 persist()를 통해 엔터티 객체를 영속성 컨텍스트에 저장하면,
                            바로 db에 반영되는 것이 아니라, 1차캐시에 저장됨과 동시에
							적절한 SQL문이 생성되어 '쓰기 지연 SQL저장소'에 이 SQL문이 저장된다.
						ㄴ transaction의 commit()을 실행하면, 영속성 컨텍스트의 내용들이 한꺼번에 'flush'되어 db에 적용된다.
						ㄴ 버퍼링같은 효과가 있다.
						ㄴ persistence.xml에서 속성으로 hibernate.jdbc.batch_size값 설정을 통해 크기조정가능.
					ㄴ 엔터티 수정 - 변경 감지 )
						ㄴ Dirty Checking )
							ㄴ JPA에서 트랜잭션이 끝나는 시점에, 모든 entity객체에 대해 변경사항이 생겼는지 확인하는 것.
							ㄴ 변경사항을 자동으로 db에 반영해준다.
							ㄴ 변경사항이 있다의 기준은 '최초 죄회 상태'. 이때를 기준으로 1차 캐시안에 엔터티에 대한 '스냅샷'을 만들어둠.
								이 스냅샷과 비교하여 변경사항이 있으면 '쓰기지연SQL저장소'에 적절한 update sql문을 만들어 저장한다.
							ㄴ '영속성 컨텍스트가 관리하는 엔터티'에만 적용된다.
				ㅡ flush )
					ㄴ 영속성 컨텍스트의 변경내용이 db에 적용, 동기화되는것을 말함.
					ㄴ dirty checking, '쓰기 지연 sql 저장소'의 쿼리를 db에 전송.
					ㄴ flush 하는 방법 )
						ㄴ em.flush() 직접 호출
						ㄴ 트랜잭션 커밋을 통한 자동 호출
						ㄴ JPQL 쿼리 실행을 통한 자동호출 : JPQL 쿼리를 실행하면 바로 flush()가된다.
					ㄴ flush 모드 옵션 : 굳이 필요없다함. 디폴트인 'auto'값 쓰라함.
					ㄴ 기타 )
						ㄴ 영속성 컨텍스트의 내용들이 db에 반영이 되는과정일뿐, 1차 캐시, 영속성 컨텍스트의 내용이
							비워지고 그렇지는 않음.
				ㅡ 준영속 상태 )
					ㄴ 영속상태의 엔터티가 컨텍스트에서 분리(detached)된 상태.
						ㄴ 영속성 컨텍스트에서 더이상 관리하지 않음.
                    ㄴ 비영속과의 차이점
                        ㄴ 특별히 유의할만한 차이점은 없다.
                            그냥 비영속은 엔터티 생성 후 아직 한번도 영속성에 추가된 적이 없는 것이고,
                            준영속은 영속성 관리가 되고 있다가 detach()나 트랜젝션이 종료되어
							말 그대로 영속성 관리가 되고 있지 않은 상태.
					ㄴ 준영속 상태로 만드는 방법 )
						ㄴ EntityManger의 detach() 이용 : 특정 엔터티만 준영속으로 만들때 사용.
						ㄴ EntityManger의 clear() : 영속성 컨텍스트의 내용 전체를 지움.
						ㄴ EntityManger의 close() : 영속성 컨텍스트를 '닫는다'???????????
					ㄴ !!!!!!!!!!!이후에 웹쪽 연결해서 자세하게 배운다함.
			</pre>

			ㅇ 식별자(Identifier)<button>more</button>
			<pre>
				ㅡ 엔터티를 식별하는 식별자를 말한다. 엔터티의 pk인셈. 엔터티를 유일하게 식별해낸다.
				ㅡ 식별자 속성
					ㄴ 엔터티에서 '식별자' 역할을 하는 속성(또는 속성들)을 말함.
					ㄴ '엔터티 식별자'인 속성이 db상의 pk인 컬럼과 일치하는 속성일 필요 없다.
						엔터티를 유일하게 식별 가능한 속성이면 된다.
						ㄴ ex )<button>more</button>
						<pre>
							in db table.. ) 아래와 같이 정의된 테이블이 '이미' 존재한다 가정.
							create table noname
							(
								pk   integer not null
									constraint noname_pkey
										primary key,
								name varchar(255),
								id   bigint  not null
							);

							in entity.. )  위와 같이 '이미' 존재하는 테이블에 아래와 같이 엔터티를 정의하여 테이블 매핑.
							@Entity
							@Table(name = "noname")
							public class NoName {
								// '엔터티 식별자'로 쓰이는 속성. jpa에선 이 속성을 기준으로 엔터티를 식별.
								// 따라서 jpa가 어플단에서 not null, unique, immutable 제약을 걸어 위반시 오류발생.
								// db 상에선 그냥 일반 컬럼.
								@Id
								private Long id;

								@Column
								private String name;

								// db의 pk로 쓰이는 속성.
								private int pk;

								public NoName(
										Long id, String name, int pk
								){
									this.id = id;
									this.name = name;
									this.pk = pk;
								}

								~~~
							}

							in app logic.. )
							// '엔터티 식별자'인 id는 자동 생성, db의 pk인 pk속성은 1로 직접 할당함.
							// noname1, noname2의 id컬럼이 같을 경우 어플단에서 '식별자'가 같다고 오류,
							// pk컬럼이 같을 경우 db단에서 primary key가 같다고 오류.
							NoName noname1 = new NoName(1L, "sample1", 11);
							NoName noname2 = new NoName(2L, "sample2", 22);
							em.persist(noname1);
							em.persist(noname2);

							em.flush();
							em.clear();
							em.commit();

							// '엔터티 식별자'인 NoName의 id속성을 기준으로 find.
							// db의 pk가 아닌 '엔터티 식별자'가 식별 기준이므로.
							NoName foundNoname = em.find(NoName.class, noname1.getId());

						</pre>
						ㄴ 참고 )
							ㄴ https://en.wikibooks.org/wiki/Java_Persistence/Identity_and_Sequencing#No_Primary_Key
							ㄴ https://stackoverflow.com/questions/3820897/jpa-entity-without-id
							ㄴ https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#entity-pojo-identifier
					ㄴ ??? hibernate, jpa는 '엔터티 식별자' 속성에 해당하는 db 컬럼이
						unique, not null, immutable 하다고 가정한다.
						ㄴ ??? 무슨말인진 알겠는데 이 가정이 구체적으로 어떤 영향을 미치는지?
					ㄴ 모든 엔터티는 '식별자'를 반드시 가져야한다.
						상속 계층 엔터티의 경우, 부모 엔터티만 가지면 된다.
				ㅡ 단일 식별자(simple identifier), 복합 식별자(composite identifier) <button>more</button>
				<pre>
					ㄴ 단일 식별자
						ㄴ 단일 속성에 매핑되며, @Id를 통해 표시된다.
						ㄴ 가능한 타입
							ㄴ JPA
								자바 원시 타입, 자바 원시 타입의 wrapper, String, java.util.Date, java.sql.Date,
								BigDecimal, BigInteger
							ㄴ Hibernate : jpa보단 더 많은 타입이 가능하다함.
						ㄴ 식별자 값 할당 vs 생성
							ㄴ 식별자의 값을 어플 로직이 직접 할당할 수도, 자동으로 생성되게 할 수도 있다.
							ㄴ 자동 생성 )
								ㄴ hibernate가 해당 엔터티 영속성 추가 직전에 '자동 생성 전략'에 따라 식별자 값을 자동 생성하여 할당.
								ㄴ 식별자 속성에 jakarta.persistence.GeneratedValue 어노테이션을 붙여 사용.
					ㄴ 복합 식별자
						ㄴ ??? 하나 이상의 속성들에 해당한다?
						ㄴ JPA 사용시, JPA 스펙에 따라 복합식별자는 다음을 지켜야 한다. (Hibernate만 사용시 다름)
							ㄴ 'primary key class'로 정의되어야하고, primary key class는
								jakarta.persistence.EmbeddedId, jakarta.persistence.IdClass annotation으로 정의될 수 있다.
							ㄴ public class이어야 하고, public no-argu 생성자가 있어야한다.
							ㄴ ??? 해당하는 db table과 일치하게 equals(), hashCode()를 override해야 한다.
						ㄴ ??? 복합식별자를 구성하는 속성들은 기본, 복합, @ManyToOne이 될 수 있다?
							컬렉션과 one-to-one은 안 된다.
						ㄴ @EmbeddedId 를 이용한 복합식별자 )
							ㄴ ~~~
						ㄴ @IdClass 를 이용한 복합식별자 )
							ㄴ ~~~
						ㄴ 연관관계 속성을 이용한 복합식별자 )
							ㄴ ??? hibernate에서 제공하는 기능. JPA는 안 된다?
							ㄴ ~~~
						ㄴ 자동 값 생성 속성을 이용한 복합식별자 )
							ㄴ 기본적으로 복합식별자를 구성하는 속성은 '자동 값 생성' 속성이어선 안된다.
								(@Generated, @CreationTimestamp 등)
							ㄴ ??? ~~~

				</pre>
				ㅡ 자동 생성 식별자 값<button>more</button>
				<pre>
					ㄴ hibernate는 여러 타입에 대해 자동 생성 식별자 값을 지원하지만, jpa의 경우, integer 타입 자동 식별자 값만 지원한다함.
					ㄴ jakarta.persistence.GeneratedValue 어노테이션을 사용하여 지정한다.
						ㄴ 속성 'strategy'에 'jakarta.persistence.GenerationType' enum값 중 하나를 설정하여
							자동 생성 전략을 선택할 수 있다.
					ㄴ jakarta.persistence.GenerationType
						ㄴ AUTO )
							ㄴ 설정시, hibernate가 자동으로 적절한 전략을 선택.
							ㄴ 선택 방식
								ㄴ ??? 식별자 타입이 UUID인 경우, 'UUID IDENTIFIER'를 사용.
								ㄴ 식별자 타입이 숫자형(integer, long)인 경우,
									ㄴ 해당 db가 sequences를 지원한다면 SEQUENCES방식을,
									ㄴ 아니라면 TABLE 방식을 선택.
						ㄴ IDENTITY )
							ㄴ db의 IDENTITY 컬럼을 이용하여 식별자값 생성.
							ㄴ 문제점 )
								ㄴ db에게 위임하게 되므로, db에 접속해서 insert를 해야 pk값을 알수있다.
								ㄴ 따라서 db에 반영하기 전인 '영속성 컨텍스트'상에서는 엔터티의 pk값이 없는
									없는 상태이므로 문제가 생김.
							ㄴ 해서, GenerationType.IDENTITY 전략일때는 persist()로 영속성컨텍스트에 추가되는 시점에
								바로 db에 접속해 insert sql을 실행하는식으로 동작한다. (commit()할때 적용되는게
								아니라) 실행하고 pk값을 받아와서 영속성 컨텍스트에 저장한다.

						ㄴ SEQUENCE )
							ㄴ db의 'sequence'를 이용해 식별자 값 생성.
							ㄴ hibernate의 'org.hibernate.id.enhanced.SequenceStyleGenerator'을 이용하여 식별자값 생성.
								ㄴ ??? SequencestyleGenerator는 db가 sequence를 지원하지 않더라도 작동할 수 있다.
							ㄴ ex )

							ㄴ db로부터 sequence값을 받아와서 pk에 저장해야하므로,
								GenerationType.IDENTITY의 경우와 유사하게 영속성 컨텍스트 저장시점에
								db에 접속하여 'sequence 값만' 받아와서 이를 pk로 저장시켜준다.
								(IDENTITY와 달리 insert sql을 실행하지는 않는다)
							ㄴ 영속성 컨텍스트에 저장하려 할때마다 db에 네트워크를 타고 접속해서 sequence번호를
								받아오기때문에 성능 이슈가 있을수있다. 해서 jpa에서는
								@SequenceGenerator의 속성 allocationSize 값만큼의 sequence번호를 한번에 받아와
								저장해둔다.
						ㄴ GenerationType.TABLE )
							ㄴ db table을 이용하여 자동 식별자 값 생성.
							ㄴ 키 생성 전용 테이블을  따로만들어서 db sequence같은 기능을 하게하는 전략.
							ㄴ 모든 db에 적용이 가능하다는 장점이 있다.
							ㄴ ????????????성능이 떨어지는 단점이 있다.
							ㄴ ???????????????????

					ㄴ 권장하는 식별자 전략 )
						ㄴ 기본키 제약조건 : null이 아니고, 유일하고, 변하면 안된다.
							ㄴ '변하면 안된다'는 조건이 어렵다. 몇년이 될지 모르는 먼 미래까지 변하면 안되는 값이어야 하므로.
						ㄴ 이러한 조건을 만족하는 '자연키'를 찾기 어려우므로 '대체키'를 사용하는것 권장.
						ㄴ 권장 : Long형 + 대체키 + 키 생성전략
							ㄴ Long형은 이후에 키값이 10억을 넘겼을때도 문제가 없도록.
						ㄴ 비즈니스 영역의 값을 키로 사용하는것 권장하지 않음.
							ㄴ ex)	주민번호를 키로 사용하는것 비추.
				</pre>

			</pre>

			ㅇ 엔터티 매핑<button>더보기</button>
			<pre>
				ㅡ JPA에서 가장 중요한 두가지. JPA의 내부동작 방식에 대한 이해, 객체와 RDB사이의 매핑 방식에 대한 이해.
					이번 챕터에서는 후자에 대해 배움.
				ㅡ 객체와 테이블 매핑 )
					ㄴ @Entity
						ㄴ JPA가 관리하는 클래스임을 선언. '엔터티'라고 한다.
						ㄴ JPA로 테이블과 매핑할 클래스는 붙여주어야 한다.
						ㄴ 주의 )
							ㄴ 기본 생성자가 필수로 있어야 한ㄷㅏ.
							ㄴ final 클래스, enum, interface, inner 클래스에는 사용불가.
							ㄴ 저장할 필드에 final 사용 불가.
						ㄴ @Table
							ㄴ 해당 엔터티와 매핑할 테이블에 대한 설정.
							ㄴ 속성 )
								ㄴ name : 매핑할 테이블의 이름 지정.
								ㄴ uniqueConstraints )
									ㄴ ddl auto generate시, unique 제약조건을 추가.
									ㄴ ex ) <button>more</button>
									<pre>
										@Entity
										@Table(
											name = "indicator_value",
											uniqueConstraints = {
												@UniqueConstraints(
													name = "(*제약조건명*)",
													columnNames = {
														(*컬럼1명*), (*컬럼2명*)
													}
												),
												@UniqueConstraints(~~~)
											}
										)
										class IndicatorValue{
											~~~
										}
									</pre>
								ㄴ indexes )
									ㄴ ddl auto generate시, index 추가.
									ㄴ ex ) <button>more</button>
									<pre>
										@Entity
										@Table(
											name = "author",
											indexes =  {
												@Index(
													name = "idx_author_first_last_name",
													columnList = "first_name, last_name",
													unique = false
												),
												@Index(~~~)
											}
										)
										public static class Author {
											~~~
										}
									</pre>
								ㄴ ~~~~~~~~~~~~~~
				ㅡ db 스키마 자동생성 )
					ㄴ 항상 사용되는건 아니지만, 엔터티를 설정해두면 어플 시작시점에 엔터티 클래스들을 보고 적절한 테이블들을 자동으로
						생성해주는 기능이 있다.
					ㄴ 즉, DDL을 어플 실행시점에서 자동생성해주는 기능.
					ㄴ???????????? 이렇게 생성된 DDL을 개발장비에서만 사용하고  운영서버에서는 사용해선 안됨.
					ㄴ persistence.xml에 hibernate.hbm2ddl.auto 속성으로 설정 가능. 사용가능한 값의 종류는 아래와 같다.
						ㄴ create : 기존 테이블 삭제 후 다시생성
						ㄴ create-drop : create와 같으나 종료시점에 테이블 drop.
						ㄴ update : 변경부분만 변경 (alter table사용)
							ㄴ 컬럼이 지워지지는 않음. 추가만된다.
						ㄴ validate : 엔터티와 테이블이 정상 매핑되었는지 확인.
						ㄴ none : 기능 사용하지 않음.
					ㄴ db 스키마를 직접 자동으로 변경하는 기능이기 때문에 매우 위험하여 가급적 사용하지 않는것을 권장.
						ㄴ 운영서버의 db 테이블이 실수로 drop되거나 컬럼 변경으로 데이터가 날아갈 위험이 있다.
						ㄴ 'update' 등으로 데이터가 날아가는 일은 없더라도, jpa에서 자동으로 db를 정의, 수정하기 때문에
							섬세하지 못하거나 어떻게 수정할지 알 수 없으므로 예상치 못한 경우도 우려되므로.
						ㄴ 번거롭더라도 db스키마 등은 직접 db에서 처리하고 엔터티를 그에 맞게 수정하는 식으로 작업하고
							이 옵션은 validate나 none으로 사용하라.
				ㅡ 필드와 컬럼 매핑 )
					ㄴ 어노테이션 )
						ㄴ @Column : 컬럼 매핑
							ㄴ name 속성 : 매핑할 테이블 컬럼 이름
							ㄴ insertable, updatable : 해당 컬럼을 삽입, 수정했을때 적용을 할지말지 결정.
								true또는 false. 디폴트값 true
							ㄴ nullabe = (*true or false*) : null값을 가질수있는지
							ㄴ unique = (*true, false*) : 유니크 제약조건을 걸때 사용.
								(@Table의 uniqueConstraints와 동일)
								ㄴ 엔터티 정의를 통해 jpa에서 ddl을 직접 생성할 때만 제약조건을 추가
									기존 존재하는 테이블이면 제약조건을 추가하지 않음.
									ㄴ 항상인지는 모르겠음.
							ㄴ columnDefinition = (*컬럼 정의 설정을 sql문으로직접 입력*) : 컬럼정보를 직접 입력.
								ㄴ ex)
									//값이 sql ddl에 그대로 들어감.
									@Column( columnDefinition="varchar(100) default 'EMPTY'")
							ㄴ length = (*숫자*) : 문자 길이 제약조건 입력
							ㄴ precision, scale
						ㄴ @Temporal : 날짜 타입 매핑
							ㄴ 자바8부터는 그냥 LocalDate, LocalDateTime타입으로 필드를 정의하면 된다.
							ㄴ 그 이전 버전에서만 사용됨.
						ㄴ @Enumerated : enum타입 매핑
							ㄴ value = (*EumType.ORDINAL, EnumType.STRING*) : EnumType.ORDINAL은 enum의 순서, 즉, 0,1,2,... 값을
								저장하는 방식이고 EnumType.STRING은 enum의 이름을 db에 저장하는 방식이다. 디폴트는 ORDINAL.
								ㄴ EnumType.ORDINAL 사용시, 이후 enum클래스상에서 변경이 발생하면 순서는 바뀌었는데 db상에선
									예전 순서대로 저장이 되어있기때문에 문제가 발생한다. 따라서 EnumType.STRING 권장.
						ㄴ @Lob : BLOB, CLOB 매핑
							ㄴ 속성이 없음.
							ㄴ 필드가 문자면 CLOB으로, 나머지는 BLOB으로 매핑됨.
						ㄴ @Transient : 해당 필드는 컬럼에 포함시키지 않음.
				ㅡ 기본 키 매핑 )
					ㄴ 직접 할당 : @Id만 사용.
					ㄴ 자동 생성 )
						ㄴ auto_increment같은걸로 자동으로 만들어주는 설정방법.
						ㄴ @GeneratedValue 사용하면된다.
						ㄴ 속성 )
							ㄴ strategy = (*아래값중 하나*) )
								ㄴ GenerationType.AUTO : db 방언에 맞게 자동생성.
								ㄴ GenerationType.IDENTITY : db가 알아서 하도록 위임.
									ㄴ ex) mysql의 경우, auto_increment를 넣는등.
									ㄴ 문제점 )
										ㄴ db에게 위임하게 되므로, db에 접속해서 insert를 해야 pk값을 알수있다.
										ㄴ 따라서 db에 반영하기 전인 '영속성 컨텍스트'상에서는 엔터티의 pk값이 없는
											없는 상태이므로 문제가 생김.
									ㄴ 해서, GenerationType.IDENTITY 전략일때는 persist()로 영속성컨텍스트에 추가되는 시점에
										바로 db에 접속해 insert sql을 실행하는식으로 동작한다. (commit()할때 적용되는게
										아니라) 실행하고 pk값을 받아와서 영속성 컨텍스트에 저장한다.
								ㄴ GenerationType.SEQUENCE : 'sequence'를 이용해 설정. ????????????????시퀀스란?
									ㄴ db로부터 sequence값을 받아와서 pk에 저장해야하므로,
										GenerationType.IDENTITY의 경우와 유사하게 영속성 컨텍스트 저장시점에
										db에 접속하여 'sequence 값만' 받아와서 이를 pk로 저장시켜준다.
										(IDENTITY와 달리 insert sql을 실행하지는 않는다)
									ㄴ 영속성 컨텍스트에 저장하려 할때마다 db에 네트워크를 타고 접속해서 sequence번호를
										받아오기때문에 성능 이슈가 있을수있다. 해서 jpa에서는
										@SequenceGenerator의 속성 allocationSize 값만큼의 sequence번호를 한번에 받아와
										저장해둔다.
								ㄴ GenerationType.TABLE )
									ㄴ 키 생성 전용 테이블을  따로만들어서 db sequence같은 기능을 하게하는 전략.
									ㄴ 모든 db에 적용이 가능하다는 장점이 있다.
									ㄴ ????????????성능이 떨어지는 단점이 있다.
									ㄴ ???????????????????
					ㄴ 권장하는 식별자 전략 )
						ㄴ 기본키 제약조건 : null이 아니고, 유일하고, 변하면 안된다.
							ㄴ '변하면 안된다'는 조건이 어렵다. 몇년이 될지 모르는 먼 미래까지 변하면 안되는 값이어야 하므로.
						ㄴ 이러한 조건을 만족하는 '자연키'를 찾기 어려우므로 '대체키'를 사용하는것 권장.
						ㄴ 권장 : Long형 + 대체키 + 키 생성전략
							ㄴ Long형은 이후에 키값이 10억을 넘겼을때도 문제가 없도록.
						ㄴ 비즈니스 영역의 값을 키로 사용하는것 권장하지 않음.
							ㄴ ex)	주민번호를 키로 사용하는것 비추.
				ㅡ 실전 예제 1 )
					ㄴ 예제와 같이 엔터티끼리 관계를 맺고있을때, 한 엔터티가 다른 엔터티의 pk를 가지고있음으로서 관계를 표현하는 방식은
						객체지향스럽지 않다. 이건 객체지향을 RDB에 맞춘것이다.
					ㄴ 객체지향적이려면 pk값이 아닌 해당 객체 자체를 가지고 있어야 한다.
			</pre>

			ㅇ 연관관계 매핑 기초<button>더보기</button>
			<pre>
				ㅡ 단방향 연관관계 )<button>more</button>
				<pre>
					ㄴ 객체의 참조와 테이블의 외래키를 매핑.
					ㄴ 다중성 : RDB에서 사용되는 개념
					ㄴ 연관관계의 주인 : 포인터같은거?
					ㄴ 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.
						ㄴ '객체지향의 사실과 오해' 책
						ㄴ '오브젝트' 책
					ㄴ 예제 시나리오 )
						ㄴ 회원과 팀 존재
						ㄴ 회원과 팀은 N:1관계.
					ㄴ 객체를 테이블에 맞추어 모델링 )
						ㄴ 연관관계가 객체가 다른 테이블의 pk를 필드값으로 가짐으로서 표현되는 방식.
						ㄴ 객체는 참조를 통해 관계를 맺는데, RDB는 외래키 조인을 통해 관계를 맺는다.
							이러한 연관관계에 대한 차이가 있다.
					ㄴ 객체 지향적인 모델링 )
						ㄴ pk값을 필드로 가지는게 아니라, 엔터티객체의 참조를 필드로 가지고 있는것이 객체지향적인 연관관계의 표현이다.
						ㄴ Member{
							int id;
							Team team;	//연관관계가 있는 객체에 대한 참조를 가지고 있음.
							~~~
						   }
					ㄴ 단방향 연관관계 )
						ㄴ 위에서 나온 회원:팀 관계같이 N:1관계의 경우, 다음과같이 하면된다.
							public class Member {
								~~~
								@ManyToOne	//회원이 N이고 팀이 1이니까 Many to one. 다대일관계임을 나타낸다.
								//rdb상에서 연관관계이므로 조인을 해야하는데, 조인할 컬럼이 뭔지 명시.
								@JoinColumn(
									name = "team_id",  // 사용할 외래키명
									referencedColumnName="id"  // 외래키가 참조할 대상 테이블의 컬럼명. default=참조하는 테이블의 기본키 컬럼명.
									foreignKey

								)
								private Team team;
								~~~
							}
						ㄴ 사용 )
							//팀 저장
							 Team team = new Team();
							 team.setName("TeamA");
							 em.persist(team);
							 //회원 저장
							 Member member = new Member();
							 member.setName("member1");
							 member.setTeam(team); 	//객체 Team을 그냥 setter로 저장하면 jpa가 알아서 team에서 pk값을 가져와 fk값으로 사용한다.
							 em.persist(member);

							Member findMember = em.find(Member.class, member.getId());
							Team findTeam = findMember.getTeam();	//이렇게 getter로 team객체를 가져오면 fk로 연결된 엔터티가 바로나온다.
				</pre>

				ㅡ 양방향 연관관계와 연관관계의 주인 )<button>more</button>
				<pre>
					ㄴ 양방향 연관관계 )
						ㄴ 양쪽이 서로 참조를 할 수 있는 것.
						ㄴ rdb의 경우에는 fk지정만으로 양쪽에서 서로를 참조할수있다.
							ㄴ pk, fk로 조인하면 된다.
						ㄴ 객체지향에서는 각 엔터티가 상대방 엔터티 객체에 대한 참조를 가지고 있어야 한다.
						ㄴ 방법 )
							ㄴ N : 1 의 경우,
								N에 해당하는 쪽에선 위에 단방향에서와 같이 @ManyToOne와 @JoinColumn을 붙이면 된다.
								1에 해당하는 엔터티에선
								@OneToMany (
									mappedBy = " (*연관관계가 있는 상대방엔터티에서 자신이 연결되어있는 객체 참조변수의 이름*) "
								)
					ㄴ 연관관계의 주인 )
						ㄴ 객체의 양방향 관계는 사실상 단방향 관계가 두개 있는것과 마찬가지이다.
							양쪽 모두 서로에 대한 객체참조를 가지고 있으므로.
							ㄴ 그에비해 RDB는 fk라는 하나의 관계로 양방향이 가능하니 양방향관계 하나있는것.
						ㄴ 객체로 양방향을 표현한경우, 둘중 어떤쪽을 변경하여 rdb의 양방향 관계를 업데이트할지 애매한데,
							이 기준점을 '연관관계의 주인'이라함.
						ㄴ 연관관계의 주인만이 외래키에 해당하는 엔터티 참조값을 변경가능하다.
						ㄴ 주인이 아닌쪽은 읽기만 가능하다.
							ㄴ 주인이 아닌 쪽에서 참조값을 변경하면 해당 로직이 그냥 무시된다.
								ㄴ ex )
									KRXDailyData가 연관관계의 주인이라 할 때,

									StockBasicInfo basicInfo2 = em.find(StockBasicInfo.class, 4L);
									// KRXDailyData dailyData3=basicInfo2.getKrxDailyDataList().get(0);
									// dailyData3.setStock(null);
									// 연관관계 주인이 아닌 basicInfo에서 KRXDailyData를 변경해도 적용되지 않는다.
							        basicInfo2.getKrxDailyDataList().add(new KRXDailyData(new Date(), new Float(3000)));

						ㄴ mappedBy 속성값이 연관관계의 주인이 누군지 나타낸다.
							ㄴ mappedBy 속성이 설정된 엔터티의 상대 엔터티가 연관관계의 주인이 된다.
							ㄴ ex)
								public class Member{
									~~~
									@OneToMany(mappedBy = "member")	//Member엔터티가 주인이 아닌게 되고,
									private List< Order> list; 	//주인이 아닌쪽의 연관관계에 속해있는 객체로는 조회만 가능하다.
									~~~
								}
								~~~
								public class Order{
									~~~
									@ManyToOne	//Order가 연관관계의 주인이 되고,
									@JoinColumn(name="member_id")
									private Member member;	//주인쪽의 객체를 통해서 데이터 변경이 가능하다.
									~~~
								}
							ㄴ 이게 선언된 엔터티객체를 통해서는 읽기만 가능한것.
						ㄴ 관례적으로, fk값을 가지고 있는 테이블에 해당하는 엔터티 객체를 주인으로 지정한다.
							ㄴ 반대쪽을 주인으로 지정할경우, 그 주인 엔터티를 변경하면 뭐 아무튼 헷갈린다함.
							ㄴ rdb상에선, fk를 가진쪽이 1:n관계에서 n에 해당한다.
							ㄴ '관계의 주인'이라고 하니까 의미적으로 헷갈릴수있는데 의미부여하지말자. 그냥 관례적으로만 하라.
						ㄴ 주의점 )
							ㄴ 객체지향적으로 보면, 양방향 관계에서 양쪽 엔터티 참조객체에 모두다 변경사항을 저장해주는게 맞다고함.
								ㄴ 또한, EntityManager의 flush(), clear()을 하면 영속성 컨텍스트의 내용이 모두 db에 적용되고 비워지고,
									연관관계 주인을 통해 연결된 엔터티들이 업데이트가 되니 문제가 없지만,  flush(), clear()를 하지않은
									영속성 컨텍스트 안에서 작업하는 경우에는 연관관계 주인을 통한 업데이트가 되지 않으므로 양쪽 객체에
									 값을 다 업데이터해주는게 좋다고 한다. db에 직접 연결하지 않는 테스트 케이스 상황에서도 연관관계
									주인을 통한 값 업데이트가 되지 않으므로 양쪽다 업데이트해주는 방식이 좋다.
									ㄴ 즉, db와의 연결되지 않는 순수 객체 상태인 환경을 고려하여 항상 양쪾에 값을 업데이트해야한다.
								ㄴ 양쪽에 일일히 넣어주는게 번거롭고실수의 여지가 많기때문에 전용 편의 메소드를 만들어두는걸 추천.
							ㄴ 컨트롤러에서 엔터티를 반환하지 마라.
								ㄴ 양방향 연결이 되어있을 경우, 객체를 string으로 변환하려할때 무한루프에 빠질수있다.
									ㄴ 서로를 참조하고있으므로, 한쪽에서 string으로 만드려고 보니 참조객체가 있고 이걸 string으로 만드려고
										보니 또 참조객체가 있고... 이런식으로
								ㄴ 이후에 엔터티에 변화가 생길경우, restful api의 스펙자체가 변경된다.
								ㄴ 엔터티 대신 DTO를 이용해라.
							ㄴ 양방향 매핑.. 지향해라..? )
								ㄴ 단방향 매핑만으로 테이블, 엔터티간 연관관계를 충분히 나타낼 수 있다. 단지 역방향 조회의 경우에 필요한것.
									따라서 단방향 매핑만으로 설계를 끝내는걸 추천한다함.
									ㄴ 설계상에서 비즈니스 부분을 적절하게 판단하여 불필요하게 양방향이 쓰이지 않도록 해야함.
								ㄴ 사실상 단방향 매핑과 양방향 매핑의 차이점은 rdb상에는 전혀없고, 객체상에서 단방향 매핑에서 반대쪽에서
									참조객체를 하나 추가한것에 불과하다. 따라서 일단 단방향매핑만으로 설계하고, 나중에 필요하면 양방향으로
									추가하는것도 좋은 방법이다.
				</pre>

			</pre>

			ㅇ다양한 연관관계 매핑 )<button>더보기</button>
			<pre>
				ㄴ
				ㄴ 일대다 )
					ㄴ 1쪽이 연관관계의 주인.
					ㄴ 그러나 테이블상에서는 N쪽에 fk가 존재하기때문에, 1쪽인 엔터티에서 N쪽의 엔터티를 추가하면 객체지향적으로는
						1쪽에서 N을 추가한것처럼 보이지만, db상으로는 N쪽 테이블에서 fk를 업데이트하여 1쪽 테이블의 값을
						추가하는식으로 동작함.
					ㄴ Collection, List, Set, Map 중 하나를 사용하여 연관관계 필드를 만들어야 함.
						ㄴ ex)
							@OneToMany
							List< Member> memberList;
					ㄴ 단방향과 양방향 )
						ㄴ 단방향 )
							ㄴ @OneToMany만 정의하여 단방향 매핑 생성 가능(반대쪽 엔터티에선 아무런 연관관계 없음)
							ㄴ @JoinColumn 설정 필요. 없을시, '조인 테이블' 전략으로 매핑을 하여, manyToMany방식처럼 중간
								테이블이 생기는 방식으로 매핑됨.
							ㄴ sql 동작 방식. <button>more</button>
							<pre>
								ㄴ 이를 통한 연관관계 조작시, N 쪽의 테이블의 외래키 컬럼을 update하는 식으로 동작한다.
								ㄴ ex )
									Member, Team 이 n:1 인 경우,
									class Team{
										~~~
										@OneToMany
										@JoinColumn
										private List< Member> memberList;
										~~~
									}

									class Member{
										~~~
									}

									// in 로직..
									Member member = new Member(~~~);
									Team team = new Team(~~~);
									// 리스트에 값 추가. 테이블 상에선 member가 team에 대한 외래키값을 가지게됨.
									team.getMemberList().add(member);

									em.persist(team);
									em.persist(member);
									em.flush();

									// em.flush()시, sql..
									insert into member(~~~) values (~~~)
									insert into team(~~~) values (~~~)
									// member insert시 외래키를 한번에 넣지 않고 비워두었다가 이후 update문으로
									// 외래키 값을 채워넣는다.
									// 이는 그냥 oneToMany 리스트에 값을 추가 삭제할 때뿐 아니라 지금 예제처럼
									// member를 생성함과 동시에 이를 리스트에 추가해도 update문이 따로 나간다.
									update member set member_id=~~~ where id=~~~
								ㄴ 위와 같이 update문이 따로 나가는 방식이라 N쪽의 외래키 컬럼은 db상에서 nullable이 된다.
									ㄴ @OneToMany 컬럼에 @JoinColumn(nullable=false) 를 부여하여도 db상에선 nullable이고
										jpa상에서 제약조건을 확인한다.
									ㄴ 이렇게 개복잡하니 @ManyToOne 단방향 또는 양방향 쓰자.
							</pre>
						ㄴ 양방향 ) <button>more</button>
						<pre>
							ㄴ ex )
								class StockBasicInfo{
									~~~
									@OneToMany(mappedby="stock")
									// @JoinColumn
									private List< KRXDailyData> krxDailyDataList;
									~~~
								}

								class KRXDailyData{
									~~~
									@ManyToOne
									private StockBasicInfo stock;
									~~~
								}

								StockBasicInfo basicInfo = new StockBasicInfo();
								KRXDailyData dailyData = new KRXDailyData();

								// 연관관계 주인이 아니기 때문에 db에 아무런 변화가 없다. jpa에서 db상으로 적용을 한 하는 것.
								basicInfo.getKrxDailyDataList().add(dailyData);
								// 연관관계 주인이기 때문에 KRXDailyData 테이블에 stock컬럼을 업데이트 친다.
								dailyData.setStock(basicInfo);

							ㄴ @OneToMany에 연결된 엔터티 쪽에서 @ManyToOne을 설정하고
								@OneToMany에 mappedby="(*반대쪽 엔터티에서 현재 엔터티로의 연관관계를 나타내는 필드명*)" 설정시
								양방향 @OneToMany가 설정된다.
								ㄴ mappedby 속성으로 어떤 필드 변경시 db에서 실질적으로 외래키가 변화하는지를 정한 것이고
									위 예제에선 KRXDailyData의 "stock"필드를 조작해야 실질적으로 db값이 변경됨을 정의
									이를 '연관관계 주인'이라 한다.
								ㄴ 다대일, 일대다 관계에서 연관관계 주인은 항상 N쪽이다. (jpa 스펙상?)
									1쪽이 연관관계 주인이 될 수 없다.
									ㄴ 즉, @OneToMany 양방향에선 항상 @OneToMany 쪽에 mappedby가 설정되는 것.
							ㄴ 양방향과 단방향 2개 매핑 차이 )<button>more</button>
							<pre>
								ㄴ mappedby를 설정하지 않고 반대쪽에 @ManyToOne을 설정시,
									이는 양방향 관계매핑이 아닌 단방향 2개가 매핑된다.
								ㄴ ex )
									class StockBasicInfo{
										~~~
										@OneToMany
										@JoinColumn(name="stock_id")  // KRXDailyData쪽과 동일하게 맞추면 컬럼 하나 생김.
										private List< KRXDailyData> krxDailyDataList;
										~~~
									}

									class KRXDailyData{
										~~~
										@ManyToOne
										@JoinColumn(name="stock_id")
										private StockBasicInfo stock;
										~~~
									}

									StockBasicInfo basicInfo = new StockBasicInfo();
									KRXDailyData dailyData = new KRXDailyData();

									// 값 변경됨. 그냥 단방향 @OneToMany로 값변경하는 것과 동일한 것.
									basicInfo.getKrxDailyDataList().add(dailyData);
									// 값 변경됨. 그냥 단방향 @ManyToOne 값변경하는 것과 동일.
									dailyData.setStock(basicInfo);

								ㄴ jpa가 @OneToMany에 의한 단방향 매핑 한개, @ManyToOne에 의한 단방향 매핑 한개로 인식하여
									KRXDailyData 테이블에 KRXDailyData->StockBasicInfo 인 fk가 두 개만들어지고
									서로 각각의 필드를 조작하게 된다.
									ㄴ 두 필드에 @JoinColumn(name="")으로 이름을 동일하게 하면 fk가 하나만 생기고
										양쪽에서 조작이 가능하기는 한데
										김영한 책에서는 언급하고 있지 않은 것 같아 자세히는 모르겠다.
										일단 쓰면 많이 꼬일 것 같다.
								ㄴ 정석은 아니지만,
									위와 같이 단방향 두개 식으로 매핑한 뒤, 한 쪽에
									insertable=false, updatable=false를 설정하여 한쪽에서만 조작 가능하도록 하여
									연관관계 주인처럼 사용할 수 있다.
							</pre>
							ㄴ 어플리케이션 단에서의 동기화
								ㄴ 연관관계 주인이 어느 쪽이든, 단방향 2개인 식으로 정의되었든, flush()시 db에는
									적절하게 반영이 되고 그 후 엔터티 로드시 양쪽 모두 정상적으로 값들이 들어있으나,
									db 적용하기 전 어플리케이션 로직 단에서는 한 쪽에서 값을 변경하면 자동으로
									반대쪽에서 값 변경이 동기화되지 않으므로 buggy할 수 있다.
									명시적으로 양쪽에 반영해 주어야 한다.
								ㄴ ex )
									위 예와 같은 엔터티 정의라 할 때...

									StockBasicInfo basicInfo = new StockBasicInfo();
									KRXDailyData dailyData = new KRXDailyData();

									// 이렇게만 하면 dailyData의 stock필드에는 여전히 값이 비어있다.
									// 명시적으로 반대쪽에도 값을 반영해 주어야 좋다.
									basicInfo.getKrxDailyDataList().add(dailyData);
									// dailyData.setStock(basicInfo);


						</pre>
					ㄴ 객체지향과 관계형db의 방식이 달라서 이런방식이되는것인데
					ㄴ 이렇게 조금 꼬여있는듯한 방식이 복잡도를 올려 버그의 위험성이 커짐.
					ㄴ 김영한은 이걸쓰느니 다대일 양방향을 추천한다함.

				ㄴ 일대일 )<button>more</button>
				<pre>
					ㄴ 양 테이블 중 어느테이블에 외래키를 넣을지 선택할 수 있다.
					ㄴ 외래키에 db 유니크 제약조건이 추가되어야 한다.
					ㄴ 주테이블에 fk vs 대상테이블에 fk )
						ㄴ 정확한 정의는 모르겠으나 전자가 주인이 된다하여 주테이블, 후자가 주인이 아닌 것쯤?
							두 대상을 비교하여 상대적으로 더 주인이라는 의미에 적합한 개념이 주태이블(주엔터티)이 되는 듯 싶다.
							가령, member, locker가 있으면 전자가 주테이블, 후자가 다상테이블?
						ㄴ 주테이블에 fk인 경우,
							좀 더 객체지향적?
						ㄴ 대상테이블에 fk인 경우,
							전통적인 rdb 방식?, 일대일에서 일대다로 변경되어도 구조상의 큰 변화가 없다.
					ㄴ 단방향 )
						ㄴ 그냥 @OneToOne을 사용하여 매핑.
						ㄴ @OneToOne이 선언된 엔터티에 fk가 생성.
						ㄴ @OneToOne을 선언한 반대쪽에서 fk를 가지도록은 jpa스펙상 불가능함.
					ㄴ 양방향 )
						ㄴ 양쪽에 @OneToOne을 선언 후, 연관관계 주인 반대쪽에 mappedby 설정.
							ㄴ 당연히, 연관관계 주인쪽에 fk 생성.
					ㄴ 정리 )
						ㄴ 주 테이블에 외래기 설정한 경우 )
							ㄴ ex) Member가 주테이블, Locker가 대상테이블일때, Member 테이블이 Locker에 대한 fk를
									가지고있는 구성인 경우.
							ㄴ 주 테이블 조회만으로 대상테이블 데이터를 알수 있어 jpa사용이 편리하고 객체지향적으로 개발가능.
							ㄴ 주테이블에 대상테이블에 대한 값이 없으면 null을 허용해야함.
						ㄴ 대상 테이블에 외래키 설정한 경우 )
							ㄴ ex ) Member가 주테이블, Locker가 대상테이블일때, locker가 member에 대한 fk를 가지고있고
								member와 locker가 일대일 양방향 관계로 구서되어있을때,
								ㄴ member 엔터티 조회시, member의 locker를 조회하려면 어차피 locker에 대한 쿼리문이 나가야
									하기때문에 locker를 '지연로딩'하지 않고 항상 '즉시로딩'을 한다.
				* db 설계, 엔터티 설계 관련 ... )
					ㄴ Member, Locker의 예를 보면, Member엔터티가 Locker를 가지고잇게 하느냐, 그 반대이느냐, oneToMany이냐
						ManyToOne이냐, 테이블상 member 가 locker에 대한 fk를 가지고있느냐, 그반대이느냐 등에 따라 당장 개발할때와
						미래에 수정사항이 생길때 어떻게 될지 등이 바뀐다. 해서 어떻게 db, 엔터티 설계를 하느냐가 중요하다.
				</pre>

				ㄴ 다대다 )<button>more</button>
				<pre>
					ㄴ rdb상에선 다대다 매핑을 테이블 두개만으로 표현할 수 없기때문에 중간 테이블을 하나 더 두어서 다대일,
						일대다 형태로 대다대를 표현.
						ㄴ ex) Member와 Product간 다대다일 경우, member_and_product란 중간테이블을 두어 구현
					ㄴ 객체지향상에서는ㄴ 다대다 매핑이 가능하다. 양쪽에 서로에 대한 필드를 추가해주면되기때문에.
						ㄴ ex) Member엔터티에 Product필드, Product엔터티에 Member필드 추가.
					ㄴ 사용법 )
						ㄴ 다대다 필드에 @ManyToMany, @JoinTable 선언
						ㄴ @JoinTable의 속성 설정
							ㄴ name : 중간 테이블명
							ㄴ joinColumns : 중간테이블의 현재 엔터티를 나타내는 필드에 대한 설정 정보
							ㄴ inverseJoinColumns : 중간테이블의 상대 엔터티를 나타내는 필드에 대한 설정 정보
							ㄴ ex )
								@ManyToMany
								@JoinTable(
										// 중간테이블명 설정.
										name = "noname_basic_info",
										// noname_basin_info 테이블의 noname fk에 대한 설정.
										joinColumns = @JoinColumn(name="noname"),
										// noname_basic_info 테이블의 stock_basic_info fk에 대한 설정.
										inverseJoinColumns = @JoinColumn(name = "stock_basic_info")
								)
								private List< StockBasicInfo> stockBasicInfoList = new LinkedList<>();
						ㄴ 양방향시,
							반대쪽에도 @ManyToMany(mappedby=~~~) 선언 후 사용하면 된다.
							동일하게 mappedby로 연관관계 주인을 설정하며,
							@JoinTable 선언은 연관관계 주인쪽에서 해야한다.
					ㄴ 단점 )
						ㄴ jpa를 통해 생성된 중간테이블에는 매핑정보만들어갈 수 있고, 추가적인 다른데이터를 넣을 수 없어
							복잡한 실무에서 사용하기에 제한이 많다.
						ㄴ 중간테이블을 사용하여 쿼리가 생성되기때문에 복잡한 쿼리가 나간다.
					ㄴ 단점의 극복 )
						ㄴ @ManyToMany로 중간테이블을 사용하는게 아니라, 중간에 아예 새로운 엔터티를 설계하고 이 엔터티에 대해
							원래 다대다 연결하려던 두 엔터티를 @OneToMany, @ManyToOne을 사용하여 매핑해주는 방식.
							ㄴ ex) Member와 Product를 다대다연결하려면 @ManyToMany를 사용하는게 아닌 Order라는 새로운 엔터티를
									만들고 Member와 Order을 연결하고 Order와 Product를 연결하는 방식.
							ㄴ 즉, 다대다 매핑 쓰지말고 비즈니스 설계상 새로운 엔터티를 설계하여 이를 중간테이블처럼 사용하라는것.
					* JPA 복합키 사용법<button>more</button>
					<pre>
						ㅡ ex )
							in 복합키로 정의할 엔터티 클래스...
							@Entity
							@IdClass(NoNameStockBasicInfoId.class)
							public class NoNameStockBasicInfo {
								@Id
								private Long id1;

								@Id
								private Long id2;

								private String name;
							}

							in 식별자 클래스...
							public class NoNameStockBasicInfoId implements Serializable {
								private Long id1;
								private Long id2;

								@Override
								public boolean equals(Object o){
									~~~
								}
								@Override
								public int hashCode(){
									~~~
								}
							}

							in table...
							create table nonamestockbasicinfo
							(
								id1  bigint 		not null,
								id2  bigint       	not null,
								name varchar(255),
								constraint nonamestockbasicinfo_pkey
									primary key (id1, id2)
							);
						ㅡ 엔터티 클래스에 @IdClass( (*식별자 클래스 타입*) ) 선언
						ㅡ 식별자 클래스 정의
							ㄴ Serializable 구현해야함
							ㄴ equals(), hashCode()를 overide해야함.
							ㄴ 기본생성자 필수, 클래스는 public.
						ㅡ 식별자 클래스의 필드들과 같은 이름의 필드가 엔터티 클래스에서 찾아 매핑되어
							이 필드들이 엔터티의 복합키로서 정의된다?
							ㄴ 식별자 클래스의 필드명이 엔터티 클래스의 필드에 없으면 오류 발생,
								엔터티 클래스에서 식별자 클래스의 필드명과 같은 필드 이외의 필드가 @Id로 선언되면
								무시되고 일반 필드로 정의되는 듯?
							ㄴ 식별자 클래스의 필드 타입과 엔터티 클래스의 필드 타입이 다를 경우, 영속성 추가시 오류발생.
								ㄴ 단, 엔터티 클래스의 필드가 연관관계 매핑 필드이고 매핑된 엔터티의 id와 식별자 클래스의
									필드 타입이 같으면 문제 없음.
									ㄴ ex )
										in  복합키로 정의할 엔터티 클래스...
										@Entity
										@IdClass(NoNameStockBasicInfoId.class)
										public class NoNameStockBasicInfo {
											@Id
											@ManyToOne
											private NoName id1;

											@Id
											@ManyToOne
											private StockBasicInfo id2;

											private String name;
										}
					</pre>
					ㄴ 다대다가 아닌 중간 연결 엔터티 방식 )
						ㄴ 위에 나온 복합키를 사용하여 다대다를 대신할 연결 테이블을 만들 수 있다. (위 예제 참고)
						ㄴ 복합키를 이용한 다대다 연결 엔터티 방식 vs 대리키를 이용한 다대다 연결 엔터티 방식
							ㄴ 대리키를 이용한 다대다 연결 엔터티 방식이란,
								위와 같이 jpa복합키를 사용하는 연결 엔터티를 정의하는 것이 아닌,
								jpa에서 자동으로 생성해주는 Long값 같은 idx값을 기본키로 사용하고 연관관계는 그냥
								일반 fk필드처럼 사용하는 방식.
							ㄴ 김영한의 추천 : 대리키를 이용한 연결 엔터티 방식.
								ㄴ jpa에서 복합키 이용시 설정이 손이 많이감.
								ㄴ 대리키 사용시 비즈니스에 의존하지 않음.

				</pre>

				ㄴ 실전예제 3 - 다양한 연관관계 매핑 )
					ㄴ

			</pre>

			ㅇ 고급 매핑 <button>더보기</button>
			<pre>
				ㅡ 상속관계 매핑 <button>더보기</button>
				<pre>
					ㄴ 객체의 상속 관계를 db 테이블에서 어떤식으로 구현할지에 대해.
						ㄴ db 테이블에는 상속 개념이 없어 아래 방식 중 하나로 상속 관계를 구현한다.
							1. '조인 방식' ) 개념적으로 O를 상속하는 A,B,C가 있다 하면,
								O 테이블을 만들고 A,B,C가 O를 fk로 참조하도록 하는 방법.
							2. 단일 테이블 ) 테이블을 하나만 만들어 모든 필요한 컬럼을 다 포함시키고 A,B,C 중 어떤 것인지
								구분하는 컬럼을 두는 방법.
							3. A,B,C에 해당하는 테이블을 각각 만드는 방법.
					ㄴ 엔터티에서 다른 엔터티를 클래스 상속하면 JPA에서 알아서 상속관계 형태로 테이블을 생성해 준다.
						ㄴ 디폴트 방식은 2번 방식이다.
						ㄴ 다른 방식으로 하려면, 엔터티 클래스에 어노테이션 '@Inheritance(strategy = InheritanceType.(*원하는 타입*) )'을
							추가하면 해당 방식으로 상속관계 형태의 테이블이 생성된다.
					ㄴ join 방식 )
						ㄴ base 엔터티 클래스에서 @Inheritance(strategy = InheritanceType.JOINED) 를 설정시 사용.
						ㄴ ex ) <button>more</button>
						<pre>
							상위 엔터티 클래스... )
							@Entity
							@Inheritance(strategy = InheritanceType.JOINED)
							@DiscriminatorColumn(name="dtype")
							public class NoName {
								@Id @GeneratedValue(strategy = GenerationType.AUTO)
								private Long id;

								protected String name;
								protected int price;

							하위 엔터티 클래스... )
							@Entity
							@DiscriminatorValue("b")  // 디폴트는 엔터티 클래스 명.
							public class Book extends NoName{
								@Id @GeneratedValue(strategy = GenerationType.AUTO)
								private Long id;

								private String author;
								private String isbn;

								public Book(){}
								public Book(String name, int price, String author, String isbn){
									this.name = name;
									this.price = price;
									this.author = author;
									this.isbn = isbn;
								}
							}

						</pre>
						ㄴ 하위 엔터티의 id값이 상위 엔터티의 id값이 된다.
						ㄴ 하위 엔터티 객체를 생성하여 영속성이 추가시, 상위 엔터티의 값도 생성된다.
						ㄴ 상위 엔터티 클래스에 '@DiscriminatorColumn(name="(*컬럼명*)")'
							ㄴ 상위 엔터티 클래스에 자동으로 컬럼 추가. 디폴트 컬럼명은 'dtype'
								이 컬럼은 상속관계 엔터티 중에서 어떤 하위 엔터티 생성과 관련하여 이 상위 엔터티가 생성되었는지를 나타낸다.
								ㄴ 가령, O를 상속하는 A,B 엔터티가 있다고 하면, A엔터티 생성이 되면 O의 'dtype' 컬럼에 A엔터티명이
									들어간다.
								ㄴ 하위 엔터티 클래스에 '@DiscriminatorValue( "(*dtype명*)" )'으로 상위 엔터티의 'dtype'에 들어갈
									이름을 결정할 수 있다.
						ㄴ 기본적으로 정석.
							ㄴ 외래키 기능도 사용할 수 있고, 객체 상속 형태에 가장 잘 들어맞는다.
					ㄴ 단일 테이블 )
						ㄴ 상위 객체가 O, 하위 객체가 A,B,C라고 하면, 한 테이블에 A,B,C의 모든 컬럼이 들어가고, dtype으로 이 레코드가
							A,B,C 중 어떤건지 구분만 하는 방식.
						ㄴ @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 을 통하여 설정.
						ㄴ dtype 컬럼이 자동으로 추가된다.
						ㄴ 특징 )
							ㄴ 모든 컬럼을 때려넣기 때문에 사용하지 않는 컬럼에 대한 null처리 등이 필요하다.
							ㄴ 한 테이블을 사용하므로 쿼리가 단순하여 성능에 이점이 있다.
					ㄴ 각각의 테이블 생성 )
						ㄴ O의 컬럼을 포함하고 있는 A,B,C 테이블을 각각 만드는 방식.
						ㄴ @Inheritance(strategy = InheritanceType.TABLE_PRE_CLASS) 을 통하여 설정.
						ㄴ dtype컬럼은 필요 없다.
						ㄴ 특징 )
							ㄴ 상위 객체에 해당하는 컬럼이 똑같이 여러 컬럼에 나뉘어 들어가기 때문에 관리가 어렵다.
							ㄴ select시, 상위 객체에 속한 정보로 검색을 할 경우, 하위 객체에 해당하는 테이블을 모두 검색해야 하여
								매우 buggy해진다.
				</pre>
				ㅡ MappedSuperclass<button>more</button>
				<pre>
					ㄴ ex ) <button>more</button>
					<pre>
						@Getter
						@Setter
						@MappedSuperclass
						public abstract class Timestamped {  // 따로 생성할 일이 없으므로 보통 abstract.

							private LocalDateTime createdDate;  // 여기서 정의한 속성이 그대로 이를 상속하는 클래스에 들어간다.
							private LocalDateTime modifiedDate;
						}

						@Entity
						public class User extends Timestamped {  // MappedSuperclass를 상속. createdDate, modifiedDate를 속성으로 가짐.

							@Id
							@GeneratedValue(strategy = GenerationType.AUTO)
							@Column(name = "USER_ID")
							private Long id;

							@Column(nullable = false)
							private String username;
							...
						}
					</pre>
					ㄴ 엔터티에서 공통적인 속성을 뽑아내어 클래스를 만들고 이를 엔터티 클래스가 상속하게 함으로써 공통된 속성을 엔터티에
						추가할 수 있게 하는 기능.
					ㄴ 공통으로 뽑아낸 클래스에 '@MappedSuperclass' 선언을 해준다.
					ㄴ 상속과 유사해 보이지만 단순히 엔터티의 속성을 똑같이 재사용하는 것.
						특히, 상속 전략 중 'table per class'와 많이 유사해 보인다.
						속성이 공통되게 들어간다는 점은 똑같지만, 엔터티 상속은 orm에 의해 객체 지향의 상속처럼 처리되지만 mappedSuperclass는
						단순히 속성이 똑같을 뿐.
						상속이 아니므로 당연히 엔터티가 아니며 독립적으로 엔터티가 생성될 일이 없다.
					ㄴ 당연히, 공통으로 뽑아낸 클래스에 컬럼에 대해 여러 어노테이션을 주면 공통적으로 적용된다.
				</pre>
				ㅡ 상속관계 매핑 vs MappedSuperclass vs embedded
					ㄴ 당연히 뭐가 딱 좋다하기 어렵.
						비슷한 기능을 하지만 다른 점들도 있고, 각각의 특징을 잘 고려하여 상황에 적절히 사용.
					ㄴ 항상 완벽하게 이상적이라 생각되는 형식이 아니더라도 상황에 맞게 적절하게 개발해야함.

			</pre>

			ㅇ 프록시와 연관관계 관리<button>더보기</button>
			<pre>
				ㅡ 프록시 <button>더보기</button>
				<pre>
					ㄴ 배경? )
						ㄴ Member 엔터티 안에 Locker라는 연관관계가 매핑되어있을때, Member 조회시, Locker까지 한번에
							읽어오느냐 member만 읽어오느냐의 문제. locker를 사용하지도 않는데 locker까지 쿼리로 조회하면
							이는 분명 낭비이다.
						ㄴ 하여, jpa의 기능 중에는, orm을 통해 엔터티를 불러올 때, 한번에 모든 정보를 불러오는 게 아닌 일부만 불러와 놓고,
							그 엔터티에 대해 실제 데이터를 읽어야 할 때 엔터티의 정보를 불러오는 기능이 있고 이 임시로 불러와진 것을 '프록시'라 한다.
					ㄴ 프록시 객체?? )
						ㄴ 해당하는 실제 엔터티 클래스를 상속한다.
					ㄴ EntityManager의 getReference()
						ㄴ EntityManager의 find()와 다르게 db에서 실제 엔터티 객체를 조회하는게 아닌, db에서 조회를 미루는
							가짜(프록시) 엔터티를 조회한다.
						ㄴ 이미 엔터티의 모든 정보가 읽어와진 상태라면(영속성 컨텍스트 안에 있는 엔터티라면), 프록시가 아닌 실제 엔터티
							객체를 가져온다.
						ㄴ 특정 엔터티에 대해, getReference()와 find() 중, getReference()가 먼저 호출되었다면, find()에서도 프록시를 반환,
							그 반대 순서로 호출되었다면 getReference()에서도 실제 엔터티 객체를 반환한다.
							ㄴ ex )
								Book bookByFind = em.find(1L);  // 실제 엔터티 객체 반환.
								Book bookByGetReference = em.getReference(1L);  // 실제 엔터티 객체 반환. (프록시 아님)

								Member memberByGetReference = em.getReference(1L);  // 프록시 반환.
								Member memberByFind = em.find(1L);  // 프록시 반환. (실제 엔터티 객체 아님)
					ㄴ detach나 EntityManager.clear() 등을 통해 준영속 상태일 때, 프록시를 통해 엔터티 객체의 데이터를 로드하려 하면
						프록시를 초기화 할 수 없어 오류 발생. (LazyInitializationException)
						ㄴ 프록시에서 실제 데이터를 읽으려 할 때 실제 엔터티 객체를 불러와 읽어야 하는데 준영속 상태라 읽을 수 없는 것.
						ㄴ 당연히, 프록시 객체가 아닌 실제 엔터티 객체는 준영속 상태와 상관없이 읽을 수 있다.
					ㄴ EntityManagerFactory의 PersistenceUnitUtil의 isLoaded( (*프록시객체*) )
						ㄴ 해당 프록시 객체가 초기화 되었는지 확인.
					ㄴ Hibernate의 initialize( (*프록시객체*) ) : 프록시 객체 강제 초기화.

				</pre>

				ㅡ 즉시 로딩과 지연 로딩 <button>more</button>
				<pre>
					ㄴ 엔터티A가 엔터티B에 대해 연관 관계를 가지고 있을 때, 연관 관계를 가지는 엔터티A를 읽어올 때, 엔터티B를 바로 db로부터
						읽어올지, 나중에 읽어올지를 설정할 수 있고 이를 '즉시 로딩'과 '지연 로딩'이라고 한다.
						ㄴ 즉시 로딩 : 엔터티A를 읽을 때, db에서 엔터티B에 대한 데이터도 같이 쿼리해서 읽어옴.
						ㄴ 지연 로딩 : 엔터티A를 읽을 때, db에서 엔터티A에 대한 데이터만 가져오고 엔터티B는 프록시로 읽어옴. 이후, 엔터티B에
										대해 실제 데이터가 필요할 때, db로부터 엔터티B의 데이터를 읽어옴.
							ㄴ '엔터티B의 실제 데이터가 필요할 때'란, 엔터티B의 속성을 읽어들여야 하거나 엔터티B를 변수에 할당할 때?
					ㄴ 엔터티 정의 클래스에서 연관 관계가 있는 속성의 어노테이션에 'fetch = FetchType.(*값*)'을 부여하여
						해당 연관관계의 엔터티를 즉시로딩할지, 지연 로딩할지 결정할 수 있다.
						ㄴ 지연 로딩 ex )<button>more</button>
						<pre>
							@Entity
							public class BBB extends Base {
								@Id
								@GeneratedValue(strategy = GenerationType.AUTO)
								private Long id;

								@ManyToOne(fetch = FetchType.LAZY)  // '지연 로딩'으로 설정.
								@JoinColumn
								private NoName noname;

							~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							BBB bbb = new BBB(noname);
							em.persist(bbb);

							em.flush();
							em.clear();  // context 비움.

							// BBB엔터티를 읽어옴(db에 쿼리가 나가 BBB엔터티의 데이터를 읽어옴).
							// BBB엔터티의 NoName은 '지연 로딩'이므로 db에 NoName에 대한 쿼리가 나가지 않고 프록시 상태로 가져와짐.
							BBB bbb2 = em.find(BBB.class, bbb.getId());
							System.out.println(bbb2.getNoname().getClass());  // NoName의 프록시 객체 출력.
							// NoName 엔터티의 값을 변수에 할당함으로서 실제 데이터가 필요해짐. 이 시점에 db에 쿼리가 나가 NoName에 대한
							// 데이터 읽어옴.
							NoName noname12 = bbb2.getNoname();
							System.out.println(bbb2.getNoname().getClass());  // 여전히 프록시.
						</pre>
						ㄴ 즉시 로딩 ex ) <button>more</button>
						<pre>
							@Entity
							public class BBB extends Base {
								@Id
								@GeneratedValue(strategy = GenerationType.AUTO)
								private Long id;

								@ManyToOne(fetch = FetchType.EAGER)  // '지연 로딩'으로 설정.
								@JoinColumn
								private NoName noname;

							~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							BBB bbb = new BBB(noname);
							em.persist(bbb);

							em.flush();
							em.clear();  // context 비움.

							// BBB엔터티와 함께 NoName의 데이터를 읽어옴(db에 쿼리가 나가 BBB엔터티와 NoName의 데이터를 읽어옴).
							// BBB엔터티의 NoName은 '즉시 로딩'이므로 NoName은 엔터티 상태로 가져와짐.
							BBB bbb2 = em.find(BBB.class, bbb.getId());
							System.out.println(bbb2.getNoname().getClass());  // NoName의 엔터티 객체 출력.
							NoName noname12 = bbb2.getNoname();
							System.out.println(bbb2.getNoname().getClass());  // 여전히 엔터터ㅣ 객체.
						</pre>
					ㄴ 특징 )
						ㄴ 즉시 로딩을 사용하게 되면, 엔터티 조회시마다 연관된 테이블들이 모두 join으로 읽히기 때문에 주된 성능 저하의 원인이 된다.
						ㄴ JPQL에서의 N+1 문제 )
							ㄴ JPQL을 사용하여 즉시로딩인 연관 관계가 있는 엔터티를 조회하게 되면, 내부 동작이 다음과 같다.
								JPQL을 sql로 번역하여 쿼리가 나감. 이때, jpql은 EntityManager의 find()와 다르게, 연관관계 즉시로딩인 엔터티들을
								한번에 쿼리해 오지 않는다. 그냥 대상이 되는 엔터티만 쿼리해옴.
								그 다음에 결과로 나온 엔터티 목록에 대해 연관관계 즉시로딩인 엔터티들을 하나씩 쿼리하여 읽어들임.
								결과 목록이 N개이면, N번을 따로 쿼리하여 즉시로딩인 연관관계 엔터티들을 읽어들이게 된다.
							ㄴ 하나의 조회 명령에 대해 쿼리가 여러번 나가게 된다.
							ㄴ 해결 )
								ㄴ 일단 모든 연관관계에 지연 로딩을 사용한다.
								ㄴ 'fetch join' 사용. (이후 나옴)
								ㄴ 그 외에 어노테이션을 사용하거나 batch 사용 등..
						ㄴ @ManyToOne, @OneToOne은 디폴트 fetchType이 즉시로딩으로 되어있다. 명시적으로 지연 로딩으로 설정해 주어야함.

				</pre>

				ㅡ 영속성 전이 ( Cascade ) <button>more</button>
				<pre>
					ㄴ 엔터티A 정의가 연관관계인 엔터티 속성을 가질 때,
						엔터티A를 영속성에 추가하거나 삭제 등의 연산을 할 때 연관 관계를 가지는 하위 속성 엔터티들에도 같이
						해당 연산을 적용시켜주는 기능.
						ㄴ ex )<button>more</button>
						<pre>
							@Entity
							public class BBB extends Base {
								@Id
								@GeneratedValue(strategy = GenerationType.AUTO)
								private Long id;

								@ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
								@JoinColumn
								private NoName noname;  // 엔터티BBB가 연관 관계 하위 속성으로 엔터티 NoName을 가지고 있고,
														// 이게 영속성 전이의 대상이다.

								public BBB(){}
								public BBB(NoName noname){
									this.noname = noname;
								}

							~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

							NoName noname  = new NoName("hello1", 1000, 10000);
							// em.persist(noname);  // noname을 영속성컨텍스트에 저장하지 않음.

							BBB bbb = new BBB(noname);
							em.persist(bbb);  // BBB를 영속성 컨텍스트에 저장하면 cascade all이기 때문에 BBB의 하위 속성인 noname이 같이 영속성 컨텍스트에 저장.
												// cascade설정이 없었으면, flush()할때, BBB의 noname이 저장되지 않은 데이터라고 오류 발생.
												// (이 경우, noname을 먼저 영속성 저장 후 BBB를 영속성 저장해야 함)

							em.flush();
							ㄴ cascade all인 상태에서 noname을 영속성 저장 후, bbb를 영속성 저장해도 알아서 jpa가 noname과 bbb를
								db에 넣는다.
								단, noname을 영속성 저장 후, flush()를 하게 되면, noname이 db에 저장되고, 이후 bbb를 영속성 저장 후
								flush()를 하면 noname이 이미 db에 존재하기 때문에 오류 발생.
						</pre>
					ㄴ 종류 )
						ㄴ CascadeType.ALL : 모든 경우에 적용
						ㄴ CascadeType.PERSIST : 영속성 저장할 때만 적용.
						ㄴ CascadeType.REMOVE : 엔터티 삭제시 적용.
						ㄴ CascadeType.MERGE
						ㄴ CascadeType.REFRESH
						ㄴ CascadeType.DETACH
					ㄴ ALL, PERSIST, REMOVE 정도만 사용하고 쓰지 않음.
						ㄴ REMOVE도 신중하게 사용해야 함.

				</pre>

				ㅡ 고아 객체<button>more</button>
				<pre>
					ㄴ 엔터티A가 @OneToOne, @OneToMany 연관관계를 가지는 하위 엔터티B가 있다고 할때, 'orphanRemoval=true' 옵션을 붙이면,
						엔터티A에서 엔터티B를 삭제시, 엔터티B를 '고아'라고 하고 이를 제거하는 기능.
					ㄴ ex )<button>more</button>
					<pre>
						class Parent{
							(*id*)

							// ??? 정확한 이유는 모르겠지만 CascadeType.PERSIST가 같이 있어야 orphanRemoval이 동작한다.
							@OneToMany(orphanRemoval = true, cascade = CascadeType.PERSIST)
							@JoinColumn
							List< Child> childList;
							~~~~~
						}

						class Chilc{
							(*id*)

							~~~~~
						}

						~~~~~~~~~~~~~~~~~~

						Child child = new Child();
						Parent parent = new Parent();
						parent.addChild(child);  // parent의 childList에 child를 추가했다침.

						~~~~~
						Parent parent2 = em.find(Parent.class, parent.getId());
						parent2.getChildList().remove(0);  // child가 고아취급되어 삭제된다.
					</pre>
					ㄴ 실무 팁 )
						ㄴ 엔터티를 내부적으로 알아서 삭제하는 기능이기 때문에 당연히 주의해서 사용해야 한다.
						ㄴ cascadeType.ALL과 orphanRemoval=true를 모두 사용하면,
							부모 엔터티 안에서 자식 엔터티의 생명주기를 모두 관리할 수 있다.
							ㄴ ??? DDD의 'aggregate root'에 유용하다.
				</pre>

			</pre>

			ㅇ 데이터 타입<button>more</button>
			<pre>
                ㅡ hibernate는 'Type' 기능을 통해 java의 데이터 타입과 db의 데이터 타입을 자유자재로 처리할 수 있다.
                ㅡ hibernate는 데이터 타입을 두가지로 분류. 'entity type', 'value type'
				ㅡ 엔터티 타입
					ㄴ 알고 있는 그 엔터티 타입을 말함. 식별자를 통해 계속 추적 가능.
				ㅡ 값 타입<button>more</button>
				<pre>
					ㄴ int, Integer, String 등 단순히 값으로 사용되는 원시 타입이나 객체. 당연히 변경되면 추적은 안되고 그냥 사라짐.
					ㄴ 분류 )
						ㄴ 자바 기본
                            ㄴ 자바 타입과 db 컬럼 타입 사이의 매핑.
                            ㄴ 상세한 매핑 정보는 다음 참고
                                ㄴ https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#basic
                                ㄴ 위 페이지를 타고 jdbc spec doc에서 B-3,4테이블
                            ㄴ 기본 타입 매핑 )<button>more</button>
                            <pre>
                                ㄴ @Basic
                                    ㄴ 엔터티 클래스의 속성에 부여.
                                    ㄴ 속성에 디폴트로 부여됨. (명시하지 않아도 @Basic이란 뜻)
                                    ㄴ 매개변수 )
                                        ㄴ optional )
                                            ㄴ boolean 값
                                            ㄴ 해당 속성이 nullable인지.
                                            ㄴ default = true
                                        ㄴ fetch )
                                            ㄴ javax.persistence.FetchType 값
                                            ㄴ eager fetch할지 lazy fetch할지
                                            ㄴ default = FetchType.EAGER
                                ㄴ @Column
                                    ㄴ 명시적으로 db column명 지정.
                                    ㄴ 사용 안 하면 디폴트로 '네이밍 전략'에 따라 자동 부여
                                ㄴ @Formula
                                    ㄴ sql 게산식 문자열을 인자로 받아 엔터티 로딩시에 계산식대로 계산하여 엔터티의 속성으로 가져옴.
                                    ㄴ db상에는 당연히 존재하지 않는 속성.
                                    ㄴ
                                ㄴ ???기본 타입을 매핑하기 위해 hibernate가 고려하는 것들
                                    ㄴ 자바 타입을 어떻게 비교하는지, hash값을 어떻게 구하는지, 다른 타입과 동등성 비교는 어떻게 하는지
                                    ㄴ jdbc 타입과의 변환
                                    ㄴ db에서 가져오고 넣을 때 해야 하는 변환 작업
                                    ㄴ 내부 값이 immutable한지 mutable한지. ex ) String처럼 값이 변할 수 없는지 Date처럼 변할 수 있는지
                                ㄴ ???
                                ㄴ enum type )
                                    ㄴ ex )
                                        @Entity(name = "Phone")
                                        public static class Phone {

                                            @Id
                                            private Long id;

                                            @Column(name = "phone_number")
                                            private String number;

                                            @Enumerated(EnumType.STRING)
                                            @Column(name = "phone_type")
                                            private PhoneType type;

                                            //Getters and setters are omitted for brevity

                                        }
                                    ㄴ 속성이 enum class 타입인 경우이고,
                                        @Enumerated 또는 @MapKeyEnumerated를 붙여 enum 타입을 매핑.
                                    ㄴ enum 값 전략 )
                                        ㄴ @Enumerated( (*enum전략*) )
                                            위와 같이 인자로 jakarta.persistence.EnumType의 값을 받음.
                                        ㄴ 이 값으로 enum값을 어떻게 저장할지 설정.
                                            ㄴ EnumType.ORDINAL : enum의 ordinal position을 값으로 저장. (enum순서값)
                                            ㄴ EnumType.STRING : enum의 name을 값으로 저장.
                                ㄴ ~~~
                            </pre>
						ㄴ 임베디드 타입<button>more</button>
						<pre>
							ㄴ 클래스를 정의하고 이를 엔터티의 속성으로 포함시켜 '값 타입'으로서 사용하는 것.
							ㄴ ex )
								embedded 객체...
								@Embeddable  // 임베디드 타입 클래스를 정의하는 곳에 선언해야 함.
								public class EmbeddedClass{
									public int property1;
									public String property2;
								}

								~~~~~~~~~~~~
								embedded객체를 포함할 엔터티...
								@Entity
								public class NoName{
									~~~~~
									@Embedded  // 임베디드 타입 클래스를 정의하는 속성에 선언해 주어야 함.
									private EmbeddedClass embeddedClass;
								}
								ㄴ noname의 컬럼으로 EmbeddedClass의 속성인 property1, property2가 추가된다.
							ㄴ 여러 엔터티에서 공통적으로 사용하는 속성들을 추출해 내는데 유용하다.
							ㄴ 관련있는 속성들을 객체화 할 수 있다.
								ㄴ 클래스이므로 당연히 임베디드 클래스 안에서 여러 메소드를 정의하여 사용할 수 있다.
							ㄴ 한 엔터티에서 한 임베디드 타입을 두개 이상 사용하려 하면, 중복된 속성으로 인해 오류 발생.
								이때는 '@AttributeOverrides' 사용.
							ㄴ 어쨋든 객체이기 때문에, 여러 엔터티에 공유해서 영속성 저장할 경우, 임베디드 객체를 변경하면 공유하고 있는
								다른 엔터티에서도 모두 수정이 되게되고, flush()시 해당 엔터티들에 대해 update가 되게된다.
								ㄴ ex )
									EmbeddedClass embeddedClass = new EmbeddedClass();

									NoName noname = new NoName();
									noname.setEmbeddedClass(embeddedClass);

									BBB bbb  = new BBB();
									bbb.setEmbeddedClass(embeddedClass);  // noname과 동일한 embeddedClass를 공유해서 저장.

									embeddedClass.setProperty1(5);  // embeddedClass의 속성 변경.

									em.flush()  // noname, bbb 모두에서 embeddedClass의 property1이 5로 update된다.
								ㄴ 영속성 context가 비워지고, embeddedClass를 공유하던 엔터티들을 새롭게 가져오면 더이상 같은
									embeddedClass 객체가 아니므로 동기화되지는 않는다. (db에서 각 엔터티의 속성값으로 새로운
									EmbeddedClass객체를 만들기 때문)
									context가 비워지지 않으면, 여전히 context안에 embeddedClass를 공유하는 noname, bbb가 들어있기
									때문에 그 안의 embeddedClass도 동일한 객체이고, embeddedClass는 동기화된다.
								ㄴ 하여, 당연히 임베디드 값 타입 객체를 공유하면 buggy하고, 객체를 복사해서 사용해야 한다.
									ㄴ 그래도, 실수로 복사하지 않고 그냥 같은 객체를 넣어버리면 컴파일러 상에서 오류로 잡을 수 없다.
									ㄴ 그래서, 값 타입 객체는 '불변 객체'로 설계한다.
										ㄴ 불변 객체? 객체 생성시점 이후에, 내부 값을 변경할 수 없는 객체를 의미.
											setter 등을 만들지 않거나 하여 만들 수 있다.
							ㄴ == 비교
								ㄴ 객체이기 때문에 == 비교는 당연히 참조값을 비교하게 된다. (동일성)
									equals()를 재정의하여 적절하게 '동등성' 비교를 해야한다.
								* equals(), hashCode() 오버라이드시 IDE의 자동생성기능을 사용하는 것이 좋다.
						</pre>
						ㄴ 컬렉션 타입<button>more</button>
						<pre>
							ㄴ 엔터티 정의에 속성으로 @OneToMany 등과 같이 엔터티 컬렉션을 가지는 게 아니라, 값 타입에 대한 컬렉션을
								속성으로 가지는 것.
								ㄴ ex )
									@Entity
									class NoName{
										~~~~~

										//@ElementCollection을 통해 컬렉션 값 타입임을 명시.
										// @CollectionTable으로 새로 생성될 테이블에 대한 설정을 한다. name은 테이블명,
										@ElementCollection
										@CollectionTable(name="propertyList1", joinColumns = @JoinColumn(name="id"))
										Set< String> propertyList1;

										@ElementCollection
										@CollectionTable(name="propertyList2", joinColumns = @JoinColumn(name="id"))
										List< EmbeddedClass> propertyList2;

									}
							ㄴ 컬렉션 속성은 해당 엔터티 테이블 안에 넣을 수 없으므로 따로 테이블이 생성되고 그 안에 엔터티와 컬렉션의
								값 타입의 값이 매핑되어 저장되게 된다.
								ㄴ 위 예의 경우,
									table propertyList1
										id (*NoName의 id*)
										String (*propertyList1 안에 들은 문자열 하나*)
									위와 같이 테이블이 생성되어 컬렉션의 목록이 각 row로 저장된다.
									ㄴ EmbeddedClass의 경우, EmbeddedClass의 속성들이 테이블의 속성이 되고.
							ㄴ 지연 로딩이 디폴트이다.
							ㄴ 값 타입 컬렉션의 수정 )
								ㄴ 기본적으로, 값 타입 컬렉션을 수정하면, db상에서 해당 엔터티와 연결된 모든 row를 삭제하고 현재 엔터티의
									그 값타입 컬렉션 안에 들은 값들을 새로 다시 모두 insert하는 방식으로 동작한다.
								ㄴ 엔터티의 id와 값타입 컬렉션의 데이터로만 테이블이 구성되기 때문에, 그 컬렉션의 요소 하나에 해당하는
									row들을 하나하나 추적하기 어렵기 때문에.
							ㄴ 값 컬렉션 vs 엔터티 )
								ㄴ 테이블 구성이 위에 나온 것과 같이 만들어지기 때문에 값타입 컬렉션의 각 요소들을 다루기 까다롭다.
									(각 요소들을 selct, 수정, 삭제 해야하는 경우 등)
								ㄴ 각 요소들이 pk를 따로 가지지 않고 연결된 엔터티의 id와 값으로만 구성되기 때문.
								ㄴ 하여, 컬렉션 값 타입을 쓸지, 엔터티로 만들어 일대다 연관관계를 할지 생각해보고 잘 결정해야 한다.
								ㄴ 정말 단순하고 간단하게만 사용하는 경우가 아니면, 값 타입 컬렉션보다는 엔터티로 만들어 사용하는 것을 추천한다함.

						</pre>
					ㄴ 서로 다른 엔터티끼리 '값 타입'의 데이터를 공유하면 안 된다.
					* 원시 타입은

				</pre>

			</pre>

			ㅇ Batch<button>more</button>
			<pre>
				ㅡ Hibernate는 JDBC의 Batching 기능을 사용할 수 있다.
					ㄴ JDBC batching이란 : 여러 sql 연산들을 한번의 db call에 보내는 기능. 성능상의 이점이 있다.
				ㅡ bathcing 관련 설정들 <button>more</button>
				<pre>
					ㄴ hibernate.jdbc.batch_size : batch size 설정. 양수 지정시, batch기능이 동작한다.
						ㄴ JPA의 식별자 자동 generate 기능을 사용하는 경우 동작하지 않는다.
						* Intellij에서 디버깅모드 실행시 동작하지 않는다? 일반 실행시 동작한다.
					ㄴ hibernate.jdbc.batch_versioned_data
					ㄴ hibernate.jdbc.batch.builder
					ㄴ hibernate.order_updates
					ㄴ hibernate.order_inserts
				</pre>

			</pre>

			ㅇ 객체지향 쿼리 언어<button>더보기</button>
			<pre>
				ㅡ JPA에서 쿼리를 만들 수 있는 다양한 기능을 지원.
					ㄴ JPQL, JPA Criteria, QueryDSL, native sql 등
					ㄴ JPA Criteria, QueryDSL은 자바 코드 형식을 사용하여 쿼리할 수 있게 해주는 문법, 기능이며, 내부적으로
						작성한 자바 코드에 맞춰 JPQL을 생성하여 동작한다.
					ㄴ 대부분은 앞의 3개로 커버가 가능하나, 쿼리가 매우 복잡하거나 db에 의존적인 경우
						native query를 사용해야 할 때도 있고 이런 기능도 지원.
				ㅡ JPQL )<button>more</button>
				<pre>
					ㄴ 개요 )
						ㄴ Java Persistence Query Language
						ㄴ JPA를 사용하면 엔터티 객체를 중심으로개발.
						ㄴ 검색을 할때도 테이블이 아닌 엔터티 객체를 대상으로 검색하는게 필요.
						ㄴ JPQL : JPA에서 SQL을 추상화한 객체지향 쿼리언어
						ㄴ 엔터티 객체를 대상으로 쿼리를 한다.
					ㄴ ex)
						TypeQuery< Member> query = em.createQuery ( "select m from Member m where m.username = :username ", Member.class );
						query.setParameter("username", "john")  // 변수명으로 JPQL에 변수 입력.
						Query query2 = em.createQuery("select m.age, m.name from Member m");

						List< Member> resultList = query.getResultList();  // 쿼리의 결과를 리스트로 반환받음. 없으면 빈 리스트.
						Member resultOne = query.getSingleResult();  // 쿼리의 결과하 하나일 때 사용. 0개나 2이상이면 예외.
						ㄴ Member는 테이블이 아닌 엔터티 객체를 말함.
						ㄴ JPA가 적절한 쿼리를 만들어서 db에 보냄.
						ㄴ 문법 )
							ㄴ 엔터티 명과 속성명은 대소문자 구분.
							ㄴ 엔터티명은 클래스명이 아닌 '엔터티명'. @Entity(name=" (*엔터티명*) ")으로 지정 가능.
								ㄴ ex )
									@Entity(name="noname")
									class NoName2 { ~~~ }
							ㄴ JPQL의 sql키워드들은 대소문자 구분 안함.
							ㄴ 테이블 이름이 아닌, 엔터티 이름으로 JPQL을 작성.
							ㄴ 엔터티에 별칭 필수.
						ㄴ 반환형 )
							ㄴ TypeQuery< (*select로 가져오는 데이터 타입*) > : 반환형이 하나이고 명확할 때 사용.
								ㄴ ex )
									TypedQuery< BBB> query = em.createQuery(
										"select b from BBB b join NoName n on b.noname=n", BBB.class
									);
        							Object q1Result = query.getResultList();
								ㄴ EntityManger의 createQuery( (*쿼리문자열*), (*반환 엔터티 클래스명*) ) 은 쿼리문에서 어떤
									엔터티를 받을지 명확하게 지정하는 메소드.
									ㄴ 쿼리문에서 select하는 엔터티와 (*반환 엔터티 클래스명*)이 다르면 안된다.
								ㄴ 이렇게 명확하게 하나의 엔터티를 반환받는 쿼리면 TypedQuery<>을 사용.
								ㄴ getResultList()는 List< BBB>를 반환.
							ㄴ Query : 반환형이 여러개이거나 명확치 않을 때 사용.
								ㄴ ex )
									Query query2 = em.createQuery(
										"select b, b.createdTime, b.embeddedClass, n from BBB b join NoName n on b.noname=n");
        							Object q2Result = query2.getResultList();
								ㄴ EntityManager의 createQuery( (*쿼리문자열*) )은 쿼리문에서 어떤 엔터티를 받을지 명확하게 지정하지 않는 메소드.
								ㄴ 예제와 같이 엔터티, 엔터티의 속성, 다른 엔터티 등 여러 데이터형을 반환받으려면 Query사용.
								ㄴ getResultList()는 반환받을 데이터들이 Object[] 안에 담겨 이 Object[]의 List를 반환.
									ㄴ List< Object[]> ?
									ㄴ ex ) 위 예제의 경우, q1Result 안에 [ Object[4], Object[4], ... ] 이런식으로 List가 들어있고,
											각 Object[4] 안에, [ BBB, BBB의 createdTime, BBB의 embeddedCalss, NoName ] 이런식으로 들어있음.
						ㄴ 위치기반 쿼리 파라미터는 헷갈리기 쉬워 buggy하다.
						ㄴ 위의 과정을 체인을 사용하여 쓸 수 있다.
							ㄴ ex )
								TypeQuery< Member> query = em.createQuery (
										"select m from Member m where m.username = :username ", Member.class )
									.setParameter("username", "john")
									.getResultList();
					ㄴ 프로젝션 (Projection)
						ㄴ JPQL의 selct부분에서 조회할 데이터를 정하는 것.
						ㄴ 기본 )
							ㄴ select m from m  // 엔터티를 조회.
							ㄴ select m.age from Member m  // Member의 속성 age 조회.
							ㄴ select m.embeddedClass from Member m  // 임베디드 타입인 속성을 조회.
							ㄴ 연관관계이 ㄴ엔터티, 여러개 속성 모두 가능하다.
						ㄴ 여러개인 경우, 반환 타입
							ㄴ DTO를 만들어 JPQL안에서 생성자처럼 호출해 줌으로서 DTO를 반환받을 수 있다.
							ㄴ ex )
								List< MemberDTO> result = em.createQuery(
									"select new jpql.MemberDTO(m.age, m.name) from Member m", MemberDTO)
								ㄴ 생성자 부분에 패키지명을 전체 적어주어야 함. JPQL이 문자열이기 때문에 자동으로 되지 않음.
					ㄴ 페이징 )
						ㄴ setFirstResult(), setMaxResult()를 이용하여 페이징 기능을 사용할 수 있다.
						ㄴ ex )
							TypeQuery< Member> query = em.createQuery ( "select m from Member m where m.username = :username ", Member.class )
									.setFirstResult(1)  // 목록 중 몇 번째 row부터 반환할지 결정.
									.setMaxResult(10)  // 목록 중 몇 번째 row까지 반환할지 결정.
									.getResultList();
					ㄴ 조인 )
						ㄴ createQuery()의 쿼리문자열에 'join', 'left join', 'on' 등의 키워드를 사용하면 sql의 조인을 사용할 수 있다.
						ㄴ ex )
							ㄴ List< Object> query4 = em.createQuery("select n, b from NoName n left join n.bbb b").getResultList();
								ㄴ NoName과 연관관계에 있는 BBB에 대해 연결된 것끼리 알아서 조인(또는 left join)하여 반환.
									(즉, 자동으로 select n, b from NoName n left join BBB b on b.noname=n 을 한 것같이 쿼리실행)
								ㄴ join, left join 키워드 후에 'n.bbb'와 같이 조인 대상을 연관관계를 가진 엔터티의 속성으로서 적어야함.
							ㄴ List< Object> query7 = em.createQuery("select b,n from BBB b left join NoName n on b.noname=n").getResultList();
								ㄴ 위 예와 같이, 연관관계를 가지고 있는 엔터티에 대해 조인이 아니더라도, 'on' 키워드를 사용하여
									연관관계가 없는 엔터티와도 조인이 가능하다.
								ㄴ join, left join 키워드 후에, 'NoName n'과 같이 조인 대상을 적어주어야함.
					ㄴ 서브쿼리 )
						ㄴ createQeury()의 쿼리문자열에 서브쿼리 기능을 사용할 수 있다.
						ㄴ exists, all, any 등의 키워드 사용 가능.
						ㄴ ex )
							List< Object> query8 = em.createQuery("select n from NoName n " +
                													"where exists (select b from BBB b where b.noname=n)").getResultList();
							List< Object> query8 = em.createQuery("select n from NoName n " +
                													"where n.price > All (select n2.price from NoName n2 where n2.name='hello3')").getResultList();
						ㄴ jpa 스펙상, where, having 절에서만 서브 쿼리가 사용 가능.
							ㄴ 하이버네이트에선 select 절에서도 가능.
						ㄴ 하이버네이트에서도 from 절에서의 서브쿼리 불가.
							ㄴ 현재 기능 지원을 안 함.
							ㄴ 대체 방안 )
								ㄴ from절 서브 쿼리 대신 조인.
								ㄴ 네이티브 쿼리
								ㄴ 일단 쿼리 후, 어플리케이션 단에서 처리.
					ㄴ JPQL 안에서의 데이터 타입 표현 )
						ㄴ 문자 ) 작은 따옴표 사용. ex ) 'hello'  / 작은 따옴표를 쓰려할 땐 작은 따옴표 두개('')로 표현. 'he''s'
						ㄴ 숫자 ) 10L(long), 30D(double), 20F(float)
						ㄴ boolean ) TRUE, FALSE
						ㄴ enum ) 패키지명을 포함한 enum값을 적어주어야 함. ex ) select m from Member m where m.type = (*패키지명*).ADMIN
						ㄴ 엔터티 타입 ) 엔터티 클래스 명. ex ) select m from Member m
							ㄴ JPQL 내부에서 type( (*엔터티*) ) 를 통해 엔터티의 타입 체크 가능.
								ㄴ ex ) select m from Member where type(m) = Person
								ㄴ 상속관계인 경우 쓰일 수 있다.
						ㄴ sql에서의 키워드 대부분 동일하게 사용 가능.
							ㄴ exists, in, and, or, not, <, >, =, <=, between, like, is null

						ㄴ setParameter()를 사용해서 넣으면 JPQL 문자열에 이런식으로 하드코딩 할 필요 없다.
				</pre>

				ㅡ JPA Criteria )
					ㄴ queryDSL처럼 JPQL을 자바 코드 형식으로 생성할 수 있게 해주는 기능.
					ㄴ jpql은 문자열로 된 쿼리기이 때문에 오타로 인한 오류가 컴파일로 잡히지 않음.
						criterai사용시, 이를 컴파일 시점에서 캐치가능.
					ㄴ 문법과 코드가 매우 복잡한편.
					ㄴ ex )	query.select(m).where(~~~)
					ㄴ 강사는 문법의 가독성이 떨어져 유지보수가 어렵다며 쓰지 않고, 자세히 내용을 소개하지 않음.
				ㅡ QueryDSL )
					ㄴ 오픈 소스.
					ㄴ Criteria와 같은 기능인데 문법의 가독성이 더 좋아 추천됨.
				ㅡ JDBC 직접 사용
					ㄴ 실db와 바로 직접 상호작용하므로, jpa와 같이 사용시 jpa에서 아직 flush되지 않은 영속성 컨텍스트 내의 내용들과
						충돌하지 않도록 주의 필요.

			</pre>

			ㅇ 관련 이슈 <button>more</button>
			<pre>
				ㅡ 영속성 추가시(em.persist()),
					IllegalArgumentException: Can not set java.lang.Long field id to entity
					와 같은 오류 발생.
					ㄴ 영속성 추가시, 해당 필드에(주로 pk 필드) 값을 할당하지 못 한다는 오류인데
					ㄴ 정확한 원인은 찾지 못했지만, 의존성에 'org.springframework.boot:spring-boot-devtools'가 있을시
						이런 오류 발생.
						ㄴ 참고 ) https://stackoverflow.com/questions/59510867/hibernate-illegalargumentexception-while-persisting-entity-object-cannot-set-fi

			</pre>
		</pre>

		Spring Framework<button>더보기</button>
		<pre>
			토비의 스프링>>><button>펼치기</button>
			<pre>
				1장. 오브젝트와 의존관계<button>펼치기</button>
				<pre>
					ㅇ 1.1 초난감 DAO
						ㅡ 리팩토링 : 코드의 기능에는 변경이 없으면서, 코드의 구조,  즉 어떤식으로 코딩이 돼있는지만 개선되는 것.
							ㄴ 코드가 이해하기 쉬워지고 변화에 더 잘 대응한다고 한다.
						ㅡ 메소드 추출 : 코드에서 공통적인 부분, 중복되는 부분을 따로 뽑아내는 것. 리팩토링의 기법 중 하나.
						ㅡ 템플릿 메소드 패턴 )
							ㄴ 전체적인 구조, 전체적인 로직, 작업, 알고리즘의 전체적인 틀은 정해놓고, 이 틀안에서 일부분만 유동적으로 변경하는 패턴.
							ㄴ 보통 상속구조로 상위클래스에서 전체적인 구조와 대부분의 메소드를 다 정의해놓고,
								이 중 일부를 추상메소드로 만들어 서브클래스에서 이 메소드부분만 유동적으로 정의할 수 있게하는식으로 만든다.
							ㄴ ex)
								public abstract class UserDao {
									public void add(){~~~~}	=>대부분의 메소드는 다 내용까지 정의해둔다.
									public User get(){~~~~}
									public abstract Connection getConnection();	=>유동적으로 변경할 부분을 추상메소드로만들어둠.
								}
								~~~
								public class NUserDao extends UserDao{	=>UserDao를 상속해 전체적인 알고리즘 구조는 유지되도록,
									public Connection getConnection(){ ~~~}	=>그러면서 유동적으로 변경할 부분인 getConnection() 추상메소드만
								}												재정의함.
						ㅡ 팩토리 메소드 패턴 )
							ㄴ 부모클래스에서 정확하게 어떤 객체를 생성하는지 모르게 자식클래스에서 객체를 생성하는 패턴.
							ㄴ 객체의 생성을 다른 클래스에서 담당하여 만들어주는 패턴.
							ㄴ 코드의 결합도를 낮추는 장점이 있다고한다.
							ㄴ ex) (내가 대충 만든 예제)
								public abstract class Number
								public class Number1 extends Number
								public class Number2 extends Number
								public class Number3 extends Number

								public abstract Factory{			=> 상위 추상클래스.
									public abstract Number createNumber(String name);	//구체적으로 어떤 객체를 생성할지 알지 못한다.
								}
								public NuberFactory extends Factory{		=> 자식클래스에서 구체적으로 어떤 객체를 생성할지를 결정하고 있다.
									@Override
									public Number createNumber(String name){
										switch(name){
											case "1" : return new Number1();
											case "2" : return new Number2();
											case "3" : return new Number3();
										}
									}
								}

								public class Main{
									public static void main(String[] args){
										NumberFactory nf = new NumberFacotry();
										Number num1 = nf.createNumber("1");
										Number num2 = nf.createNumber("2");
									}
								}
						ㅡ 1.3.4 원칙과 패턴 )
							ㄴ 개방 폐쇄 원칙
								ㄴ 클래스나 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
							ㄴ 높은 응집도, 낮은 결합도
								ㄴ 높은 응집도 : 하나의 모듈, 클래스가 하나의 관심, 책임만을 가지는것.
								ㄴ 낮은 결합도 : 책임과 관심이 다른 클래스, 모듈사이에는 '느슨한 연결'을 유지하는 것.
									ㄴ 결합도 : 하나의 오브젝트에서 변경이 일어나면 연속적으로 관계를 맺고있는 다른 오브젝트에서도 변화가 일어나야하는 정도.
									ㄴ '느슨한 연결'이란? 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적으로 제공하고 나머지는 서로 독립적이고 알 필요도 없게하는것.
									ㄴ 변화에 대응하기 쉬워지고 구성이 깔끔해지고 확장에 용이해진다.
							ㄴ 전략 패턴 )
								ㄴ 디자인 패턴의 일종.
								ㄴ 개념 )
									ㄴ 자신의 기능 맥락(context) (대충 일련의 기능들 중) 중에서 필요에 따라 변경이 필요한 관심,기능(알고리즘)을 인터페이스로
										통째로 분리시키고, 이 인터페이스를 구현한 구체적인 클래스를 선택적으로 사용함으로서 기능을 다양하게 변경할 수 있는 방식이다.
								ㄴ 알고리즘을 바꿔가는걸 '전략'을 대체한다 하여 전략패턴이라고함.
							ㄴ 스프링은 이와같은 원칙과 패턴들이 잘 적용되도록 만들어진 프레임워크이다.
						ㅡ 1.4 제어의 역전 (IoC) )
							ㄴ 일반적인 프로그램에서는 main과 같이 시작하는 부분에서 어떤 오브젝트를 사용할지 결정하고 또 이를 생성하고 이것의 메소드를 호출하고 등등
								다른 오브젝트를 사용한다. 그리고 그 안에서 또 사용할 오브젝트를 결정하고, 생성하고...
								이런식으로 오브젝트의 사용자(즉, 오브젝트의 클라이언트)에서 모든 작업을 제어한다.
							ㄴ IoC란 이러한 제어의 흐름을 역전시키는 것이다. 모든 오브젝트는 자신이 사용할 오브젝트를 결정하지도, 생성하지도 또한
								자신이 어디에 사용되는지도 알지 못한다. 모든 제어는 이 제어권을 위임받은 특별한 대상에 의해 수행된다.
							ㄴ 리스트 1-14,15에 나오는 것처럼 UerDao, ConnectionMaker가 DaoFactory에 의해 결정되고, 생성되고 있으므로 제어가
								역적되었다고 볼 수 있다.
							* 라이브러리와 프레임워크의 차이 )
								ㅡ 라이브러리의 경우에는 제어권이 라이브러리를 사용하는쪽(보통 개발자의 코드)에 있고,
								ㅡ 프레임워크의 경우에는 제어권이 (모두인지는 모르겠다) 프레임워크쪽에 있다. 개발자가 코드를 만들어 놓으면
									프레임워크(주로 컨테이너 등)에서 이 코드를 가져다 호출하고 사용하는 식.
							ㄴ ?????????? 디자인 패턴이 원래 이렇게 추상적인 내용이어서 그런지, 내가 이해를 못한건지는 모르겠지만 이해가 명쾌하게 된것같지는 않다.
								 두루뭉실하게 대충 이런게 IoC이구나 라는정도..
						ㅡ 스프링의 IoC )
							ㄴ 스프링의 핵심은 '빈 팩토리', '어플리케이션 컨텍스트'이며, 이전 주제에서 다룬 DaoFactory를 일반화한것이라고 볼 수 있다.
							ㄴ 스프링 빈 : 스프링 컨테이너가 제어권을 가지고 생성, 관계설정 등을 해주는 오브젝트를 말한다.
							ㄴ 스프링의 '빈 팩토리' : 스프링에서  스프링 '빈'을 제어하는 IoC오브젝트를 말함.
							ㄴ 스프링의 '어플리케이션 컨텍스트' : '빈 팩토리'의 일종. '빈 팩토리'를 조금 더 확장한 것이다. IoC컨테이너, 스프링 컨테이너 라고도 불린다.
							ㄴ '빈 팩토리', '어플리케이션 컨텍스트'는 별도의 '설정정보'를 읽어들여 이에 따라 '빈'들을 제어한다.
							ㄴ 간단한 어플리케이션 컨텍스트의 동작방식 )
								ㄴ 클라이언트에서 어플리케이션 컨텍스트에게 특정 이름의 '빈'을 요청하면 어플리케이션컨텍스트가 관리하고 있는 '빈' 목록중에서
									해당 이름을 가진 '빈'이 있는지 확인.
								ㄴ 있으면, 그 '빈'객체를 클라이언트에게 넘겨줌.
						ㅡ 1.6 싱글톤 레지스트리와 오브젝트 스코프 )
							* 스프링과 서버 어플리케이션
								ㅡ 스프링은 자바 엔터프라이즈에 적합한, 서버 어플리케이션에 사용되기위해 만들어진 기술이라고 한다.
								ㅡ 그래서 스프링은 주로 서버환경에서 사용된다함.
							ㄴ 서버환경에서는 무수히 많은 요청이 들어올 수 있고, 만약 각 요청마다 새로운 인스턴스를 생성해서 사용하게 되면 많은 부하가 생기게 된다.
							ㄴ 그래서 어플리케이션 컨텍스트는 따로 설정이 되어잇지 않으면 기본적으로 '빈'에 '싱글톤 패턴'을 적용하여 하나의 인스턴스만 생성하고 요청이
								들어올때마다 이를 반환해준다.
							* 싱글톤 패턴 : 어플리케이션 안에 클래스의 오브젝트를 단 하나만 생성하여 이를 사용하는 방식.
							ㄴ 싱글톤 패턴의 문제점 )
								ㄴ 자바에서 싱글톤 패턴을 구현하는 방식은 일반적으로 다음과 같다 )
									ㄴ 단 하나의 인스턴스만 생성해야 하므로 생성자를 private로 단 하나만 만든다.
									ㄴ 단 하나 생성하는 인스턴스를 저장하기 위한 자기자신 인스턴스를 저장할 static 변수를 만든다.
									ㄴ static 팩토리 메소드인 getInstance()를 만들고 이 메소드가 처음 단한번 호출시 private생성자를 통해 인스턴스를 생성하고
										이를 static변수에 저장하고 이를 반환, 그 이후부터는 그냥 static변수를 반환하게 한다.
								ㄴ 이에 따른 문제점들은 다음과같다 )
									ㄴ 생성자가 private이기때문에 싱글톤 패턴이 적용된 클래스에는 상속을 적용할 수 없다.
									ㄴ ??????????? 테스트하기가 어렵다.
									ㄴ 클래스 로더나 JVM분산 여부에 따라 싱글톤패턴이라도 단 하나의 인스턴스만 생성된다는것을 보장할 수 없다.
									ㄴ ?????????? 어디서든 누구든 접근할 수 있는 '전역 상태'가 될수있기때문에 적절하지 않다.
							ㄴ 스프링의 '싱글톤 레지스트리' )
								ㄴ 스프링에서는 '싱글톤 레지스트리'를 통해 위처럼 싱글톤 패턴대로 구현된것이 아닌 일반 자바 클래스도 싱글톤처럼 사용될 수 있게 해준다.
								ㄴ 오브젝트의 생성, 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기기때문에 컨테이너가 '빈'을 싱글톤처럼 사용할 수 있게하는게 가능.
								ㄴ 해서 스프링 컨테이너는 '싱글톤 레지스트리'라고도 불린다.
							ㄴ 싱글톤 객체의 '상태' )
								ㄴ 오브젝트의 상태란 필드, 멤버변수를 말한다.
								ㄴ 멀티스레드 환경에서는 당연히 싱글톤 인스턴스는 변수를 가지는것에 유의해야 한다. 여러스레드에 의해 동시접근되므로.
								ㄴ 읽기전용의 값이면 당연히 괜찮다.
							ㄴ 스프링 '빈'의 스코프 )
								ㄴ 스프링에선 빈의 스코프를 통해 빈의 범위를 조절할 수 있다.
								ㄴ 종류 )
									ㄴ 싱글톤 : 디폴트 스코프.
									ㄴ 프로토 타입 스코프 : 빈을 요청할때마다 새로운 인스턴스를 생성하는 것.
									ㄴ 요청 스코프 : http요청이 들어올때마다 새로 생성하는것.
									ㄴ 세션 스코프 :
									ㄴ .....
						ㅡ 1.7 의존 관계 주입, DI )
							ㄴ DI : 넓은 범위에서는 IoC안에 포함되기는 하는데, 스프링에서 제공하는 특별한 IoC방식을 DI라고 따로 명명햇다함.
							ㄴ 스프링 프레임워크의 핵심 개념이라함.
							ㄴ 의존 관계 )
								ㄴ 'A가 B에 의존하고 있다'는건 가령, A가 B의 메소드를 사용하고 있는 식으로 의존하고있다는 의미.
								ㄴ 따라서 B에서 변경이 발생하면 A에도 영향을 미치는 관계이다.
								ㄴ 의존관계에는 '방향성'이 있다. A는 B에 의존하고있지만 B는 A에 의존하지 않는 식으로.
								<img src="image/스프링_의존관계.png" />
							ㄴ 설계 관점의 의존관계, 런타임 의존관계 )
								ㄴ 클래스 상, 코드상의 의존관계를 말한다. 예에서 UerDao클래스와 ConnectionMaker인터페이스는 의존관계를 가지지만,
									ConnectionMaker인터페이스를 구현한 NConnectionMaker, DConnectionMaker와 UerDao는 설계관점상에선 의존관계가 없다.
								ㄴ 그러나 런타임시에 UserDao는 ConnectionMaker인터페이스 형태의 인자로 NConnectionMaker나 DConnectionMaker 객체를
									 받게되므로 의존관계가 생긴다. 이를 '런타임 의존관계'라 하고 이렇게 런타임시에 의존관계를 맺는 대상을 '의존 오브젝트'라 한다함.
									 (실제로 있는것인지 저자가 만든개념인지는 모르겠음)
							ㄴ 의존관계 주입은 위처럼 '런타임'시에 오브젝트간에 의존관계를 만들어주는것을 말한다.
							ㄴ 예에서 DaoFactory가 DI를 해주고 있으며, DaoFactory를 DI컨테이너라고 할 수 있다.
							ㄴ 의존 관계 검색 )
								ㄴ 의존 관계 주입과 더불어 IoC 방식으로 의존관계를 형성하는 또다른 방법이다.
								ㄴ 여전히 의존하는 인스턴스에 대한 결정이나  생성 등에 대한 제어권은 없지만 이를 받아오는 방법이 DI처럼 메소드 인자등으로 주입받는게 아니라
									직접 컨테이너로부터 검색하여 받아오는 식이다.
								ㄴ 가령, UserDao가 필요한 DConnectionMaker를 인자로 받는게 아니라 DI컨테이너인 DaoFactory를 직접생성하고
									이 객체의 메소드를 통해 DConnectionMaker 객체를 받아오는식.
								ㄴ 스프링의 '어플리케이션 컨텍스트'에서 getBean( (*빈 이름*) )을 통해 의존관계 검색 방법을 사용할 수 있다.
								ㄴ 의존관계검색을 사용하는 경우, 검색의 주체는 스프링 빈일 필요가 없다.
							ㄴ DI 장점 )
							ㄴ 메소드를 이용한 의존관계 주입 )
								ㄴ 꼭 생성자를 사용하지 않고도 의존관계를 주입할 수 있다.
								ㄴ setter메소드 또는 일반 메소드를 사용 할 수 있다.
						ㅡ XML을 이용한 설정 )
							ㄴ 뒤에나옴.

						* 빈 정의<button>펼치기</button>
						<pre>
							ㅡ 컨테이너에 의해 관리되고, 어플을 구성하는 object를 스프링에서 bean이라 부른다.
							ㅡ config metadat가 필요하며 다음으로 구성되어있다.
								ㄴ 어떻게 bean이 생성되어야하는지
								ㄴ 빈의 라이프사이클이 어떻게 되는지
								ㄴ 의존성은 어떻게되는지
							ㅡ 빈 정의는 다음의 프로퍼티들로 구성된다
								ㄴ class : 빈 정의에 사용될 class를 명시하는부분. 필수사항이다.
								ㄴ name : bean identifier를 명시한다. id또는 name 속성으로 명시할 수 있다.
								ㄴ scope : ...
								ㄴ constructor-arg : ...
								ㄴ properies
								ㄴ autowiring mode
								ㄴ lazy-initialization mode : 컨테이너에게  해당 빈생성을 시작할때가 아닌 처음 요청이 들어왔을때 해달라고 명시하는것.
								ㄴ initialization method : 빈의 모든 필요한 프로퍼티들이 컨테이너에 의해 세팅되고나서 호출되는 콜벡함수
								ㄴ destruction method : 빈을 포함하고있는 컨테이너가 파괴된후 호출되는 콜벡함수.
								ㄴ ex)
									< beans xmlns = "http://www.springframework.org/schema/beans"
									   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
									   xsi:schemaLocation = "http://www.springframework.org/schema/beans
									   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

									   <!-- A bean definition with lazy init set on -->
									   < bean id = "..." class = "..." lazy-init = "true">
									      <!-- collaborators and configuration for this bean go here -->
									   < /bean>

									   <!-- A bean definition with initialization method -->
									   < bean id = "..." class = "..." init-method = "...">
									      <!-- collaborators and configuration for this bean go here -->
									   < /bean>
									< /beans>
							ㅡ config metadata를 컨테이너에게 전달하는 방법 )
								ㄴ xml-based config file
								ㄴ Annotation-based config
								ㄴ Java-based config
						</pre>
						* 빈 라이프사이클<button>펼치기</button>
						<pre>
							ㅡ 빈이 인스턴스화되거나 더이상 필요없어질때 내부적으로 빈에 대한 처리가 일어난다.
							ㅡ 빈의 생성과 파괴단계에 호출될 메소드를 설정할 수 있다.
								ㄴ 초기화 콜백 )
									ㄴ org.springframework.beans.factory.InitializingBean interface이용 )
										ㄴ 이 인터페이스 안에 void afterPropertiesSet() throws Exception 라는 함수가있고,
											이함수는 빈이 인스턴스화 되고나서 호출되는 메소드이다.
										ㄴ 이 함수 몸체에 원하는 내용을 작업하면된다.
									ㄴ xml-based 이용)
										ㄴ < bean>의 속성으로 init-method를 주고 속성값으로 메소드이름을 설정하면, 해당 빈이 인스턴스화된 직후
											설정한 메소드가 호출된다.
								ㄴ 파괴 콜백 )
									ㄴ org.springframework.beans.factory.DisposableBean interface 이용)
										ㄴ 초기화와 동일. 이 인터페이스의 void destroy() throws Exception 메소드이용.
									ㄴ xml-based이용)
										ㄴ 초기화와 동일. < bean>의 destroy-method속성이용.
								ㄴ < beans> (< bean>이 아닌 < beans>이다) 의 속성값으로 default-init-method, defualt-destroy-method를
									 통해 하위의 모든 빈정의에 대해 init-mehod, destroy-method를 설정할 수 있다.
						</pre>
						* 빈 정의 상속<button>펼치기</button>
						<pre>
							ㅡ 빈 정의에 자바의 상속 개념을 도입할 수 있다.
							ㅡ xml ex)
								< ?xml version = "1.0" encoding = "UTF-8"?>

								< beans xmlns = "http://www.springframework.org/schema/beans"
								   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
								   xsi:schemaLocation = "http://www.springframework.org/schema/beans
								   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

								   < bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld">
								      < property name = "message1" value = "Hello World!"/>
								      < property name = "message2" value = "Hello Second World!"/>
								   < /bean>

								   < bean id ="helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "helloWorld">
								   		=>parent 속성값을 통해 상속받을 빈을 설정해준다. 부모 빈의 message1,2는 그대로 가지게되며,
								      < property name = "message1" value = "Hello India!"/>				=>message1의 경우  이를 오버라이드해주고있다.
								      < property name = "message3" value = "Namaste India!"/>				=>새로 추가된 message3.
								   < /bean>
								< /beans>
							ㅡ 다음과 같이 bean definition template를 사용하여 상속할 수도있다.
								< ?xml version = "1.0" encoding = "UTF-8"?>

								< beans xmlns = "http://www.springframework.org/schema/beans"
								   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
								   xsi:schemaLocation = "http://www.springframework.org/schema/beans
								   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

								   < bean id = "beanTeamplate" abstract = "true">	=>abstract값을 true로 줌으로서 bean template로 설정.
								   														이 빈은 인스턴스화 불가능하다.
								      < property name = "message1" value = "Hello World!"/>
								      < property name = "message2" value = "Hello Second World!"/>
								      < property name = "message3" value = "Namaste India!"/>
								   < /bean>

								   < bean id = "helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "beanTeamplate">
								   						=>위의 template bean을 상속한다.
								      < property name = "message1" value = "Hello India!"/>
								      < property name = "message3" value = "Namaste India!"/>
								   < /bean>
								< /beans>
						</pre>
				</pre>
				4장. 스프링 MVC>>><button>펼치기</button>
				<pre>
					ㅇ 4.1 @RequestMapping 핸들러 매핑
						ㅡ 스프링 MVC에서는 메소드 단위에서의 매핑이 가능하다. 어노테이션을 사용하기때문에 가능.
						ㅡ mvc의 핸들러 매핑을 위해서는 DefaultAnnotationHandlerMapping이 필요하다. 따로 핸들러 매핑 빈을 등록할 수도있다.
						ㅡ DefaultAnnotationHandlerMapping은 @RequestMapping을 이용하여 매핑을한다.
							ㄴ 타입레벨의 @RequestMapping을 우선적으로 기준으로 삼고 메소드레벨의 @RequestMapping정보를 사용한다.
						ㅡ @RequestMapping )<button>펼치기</button>
						<pre>
							ㄴ 사용가능한 값 )
								ㄴ value
									ㄴ 디폴트 형태로 string 배열타입이다.
									ㄴ url 패턴을 명시할때사용된다.
									ㄴ ex) @RequestMapping("/hello"), @RequestMapping("/admin/**/user"),  @RequestMapping{"/hello", "/hi"} 등
									ㄴ 여러 url패턴을 지정할수있다.
									ㄴ 값으로 'uri템플릿'이란것도 사용가능
										ㄴ @RequestMappign("/user/{userid}"
										ㄴ {}을 사용해서 템플릿을 사용하며 이안의 값은 컨트롤러 메소드로부터 인자로 받아올수있다.
										ㄴ {}안에 들어가는 이름을 '패스변수'라 한다.
								ㄴ http 요청 메소드
									ㄴ 값으로 http request 메소드를 지정할 수 있다. GET,POST, DELETE 등
									ㄴ ex) @RequestMapping(value="/user/add", method=RequestMethod.GET), @RequestMapping(method=RequestMethod.GET)
								ㄴ 요청 파라미터
									ㄴ requst의 파라미터에 대해서도 매핑을 적용할 수 있다.
									ㄴ params 값을 사용하며, '타입 = 값' 형식으로 지정한다.
									ㄴ ex) @RequestMapping(value="/user/edit", params="type=admin")	=>요청 파라미터로 type이란 인자의 값이 admin일 경우 매핑.
									ㄴ POST로 전송한 파라미터도 적용대상이다.
									ㄴ 특정 파라미터가 존재하지 않는다는 조건도 지정가능하다. '!'을 사용한다.
										ㄴ @RequestMapping(value="~~", params="!type")
									ㄴ 역시 배열선언이라 여러개 지정가능하다.
								ㄴ Http 헤더
									ㄴ http 헤더에 따라 매핑가능하다
									ㄴ 형식은 params과 비슷하다. '헤더이름=값'형식으로 지정한다.
									ㄴ ex) @RequestMapping(value="~~", headers = "content-type=text/*")
							ㄴ 타입 레벨 매핑과 메소드 레벨 매핑 )
								ㄴ 메소드 레벨 매핑은 타입레벨 매핑을 상속받는다 보면된다.
							ㄴ 타입 레벨 매핑에 아무런 부여할 조건이 없어도 어노테이션은 선언해주어야한다. 매핑대상이라고 지정은 해주어야해서.
							ㄴ 타입레벨 단독 매핑
								ㄴ ??????????????????????????????????//////
							ㄴ 4.1.2 매핑 정보의 상속 )
								ㄴ @RequestMapping이 적용된 인터페이스나 클래스 상속시, 이 매핑정보는 상속된다고 보면된다. 물론 자식에서 재정의하면 덮어씌울수있다.
								ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~...473페이지부터
						</pre>
					ㅇ 4.2 @Controller ) <button>펼치기</button>
					<pre>
						ㄴ 컨트롤러의 역할을 할 class를 지정하는 기능을 한다.
						ㄴ 컨트롤러를 만들때, HttpServletRequest같은 객체가 직접적으로 필요할 때도 있고, 이런 종속적인 인자없이 간단하게 만들 수 도 있다.
						ㄴ 근데 @MVC의 컨트롤러를 만드는 방식대로하면 HttpServletRequest같은 종속적인 객체를 가져오지않아도 이를 사용할 수있고, 이런 객체가 필요없으면 그냥 일반 인자만을 사용해서
							컨트롤러를 정의 할 수 있다고한다.
						ㄴ @Controller 어노테이션을 사용하여 만든다.
							ㄴ 이는 빈 자동인식에서 사용되는 스테레오 타입 어노테이션이다.
							ㄴ 컨트롤러에 해당하는 메소드의 파라미터 타입, 개수, 리턴 타입 등을 자유롭게 설정 할 수 있다. (물론 완전 자유는 아닌 몇가지 정해져있는거지만 이전 컨트롤러방식에 비해 월등하다)
						ㄴ 4.2.1 사용가능한 메소드 파라미터의 종류 ) <button>펄치기</button>
						<pre>
							ㄴ 스프링이 파라미터 타입과 이름, 어노테이션을 보고 적절한 파라미터값을 제공해준다고한다.
							ㄴ HttpServletRequest, HttpServletResponse : 거의쓸일이 없긴하다함
							ㄴ HttpSession
							ㄴ WebRequest, NativeWebRequest : HttpServletRequest와 거의 유사한데, 서블릿api에 종속적이지
								않은 request객체라고 보면된다.
							ㄴ Locale : java.util.Locale을 말하며, DispatcherServlet의 Locale Resolver가 결정한 Locale객체를
								받을 수 잇다.
							* java.util.Locale : 간단히말해 해당 지역긔 나라, 언어 정보를 얻을 수 있는 객체.
							ㄴ InputStream, Reader : HttpServletRequest의 getInputStream()으로 받던 스트림과 Reader타입을 받을 수 있다.
							ㄴ OutputStream, Writer : HttpServletResponse의 getOutputStream()으로 받던 스트림과 Writer를 받을 수 있다.
							ㄴ @PathVariable
								ㄴ ex) @RequestMapping("/user/view/{id}")
									public String view(@PathVariable("id") int id){ ~~ }
								ㄴ url설정에서 템플릿형태로 설정해둔다음 이 템플릿변수를 메소드에서 @PathVariable의 인자로 넘겨주어 파라미터에 선언해주면 해당 url의 값이
									들어오게된다.
								ㄴ 이때 반드시 일치하는 형태의 변수가 url에 들어와야하며, 그렇지않으면 예외가발생한다.
							* 템플릿 변수 ????(명칭 정확하지않음)
								ㅡ @RequestMapping을 이용해 uri를 지정할때 동적으로 이 url을 설정할 수 있다.
								ㅡex) @RequestMapping(value="/company/{companyId}/dept/{depId}~~~", method=GET)
									ㄴ {}로 둘러싸인 부분이 동적으로 url를 설정할 수 있는 부분이고 '템플릿 변수'??라고 하는 듯하다.
									ㄴ 이렇게 {}로 둘러싸인 저 변수를 저 @RequestMapping이 적용되는 범위 안에서 @PathVariable( " (*템플릿변수명*) " )을 통해,
										값에 따라 매핑 할 수 있다.
							ㄴ @RequestParam : form등으로 보내는 request안의 parameter를 가져올 수 있게 해주는 어노테이션이다.
								ㄴex) public String view(@RequestParam("id") int id){~~}
									ㄴ request.getParameter("id")에서 나온 값을 인자 id에 넣어준다.
								ㄴ 당연히 여러개를 선언할 수 있으며
								ㄴ 파라미터 이름을 지정하지 않고 파라미터를 받는 변수의 타입을 Map< String, String>으로 설정하면 request에 담긴 모든 파라미터가 전달된다.
									ㄴ ex) public String add(@RequestParam Map< String,String> params) {~~}
								ㄴ 옵션 )
									ㄴ ex) public void view(@RequestParam(value="id", required=false, defaultValue="-1") int id) {~~ }
									ㄴ reuired : 디폴트는 true. 해당 request 파라미터가 필수로 존재해야하는지 아닌지를 설정. true로 설정시 해당 파라미터가 없으면 예외발생.
									ㄴ defaultValue : 요청 파라미터가 없을시 적용할 디폴트값.
								ㄴ 메소드의 인자이름과 request 파라미터의 이름이 일치하면 @REquestParam만 사용해도 된다. 알아서 매핑됨.
								ㄴ request의 파라미터를 메소드의 인자 데이터 형에 맞게 알아서 변환해주며, 변환이 안될시 400에러가 난다.
								ㄴ
							ㄴ @RequestPart )
								ㄴ multipart/form-data형태의 요청을 받을때 사용되는 어노테이션이라함.
								ㄴ ~~~~~
								ㄴ
							ㄴ @CookieValue : http request에 들어있는 Cookie의 값을 받을 수 있다.
								ㄴ @RequestParam과 사용법이 거의 유사하다.
								ㄴ ex) public String check(@CookieValue("auth") String auth) {~~}
									ㄴ 쿠키의 이름을 @CookieValue에 값으로 넘겨주면 해당 쿠키의 값을 메소드 인자에 매핑해준다.
									ㄴ 쿠키의 이름과 메소드 인자의 이름이 같다면 @CookieValue만 선언해주어도 된다. 알아서 매핑해준다.
								ㄴ ex) public String check(@CookieValue(value="auth", required=false, defaultValue="NONE" String auth) {~~}
									ㄴ @RequestParam의옵션과 동일하다.
							ㄴ @RequestHeader : request의 헤더정보를 가져와주는 어노테이션. 헤더의 이름값을 어노테이션에 넘겨주면 해당 헤더의 정보를 준다. 사용법은 @RequestParam, @CookieValue와 동일하다.
							ㄴ Map, Model, ModelMap
								ㄴ View에서 쓰이는 Model 타입을 인자로 받을 수 있다.
							* Model, ModelMap
								ㅡ 스프링에서 View에 데이터 랜더링할때 쓰이는 model을 말함.
								ㅡ Map형식으로 데이터를 저장한다는 기능에서는 동일. 다른점은 Model은 인터페이스이고 ModelMap은 클래스.
							ㄴ @ModelAttribute
								ㄴ 컨트롤러에서 Http request정보를 사용할 때, 이 값들을 하나씩 받는게 아니라 자바빈처럼 여러 종류의 값을 객체형식으로 한꺼번에 받으려 할때 사용하는 어노테이션이다.
								ㄴ ex)	public class UserSearch {
										int id;
										String name;
										~~
									}
									이렇게 데이터를 담을 객체를 만들고,
									@RequestMapping("/user/search")
									public String search(@ModelAttribute UserSearch userSearch) {	=> 스프링은 @ModelAttribute가 선언된 객체를 이 객체의 디폴트 생성자를 이용해
																										생성하고 이 객체의 프로퍼티에 각각 이름이 같은 요청 파라미터의 값을 넣어준다.
										List< User> list = userService.search(userSearch);
										model.addAttribute("userList",list);
										~~
									}
									ㄴ request의 파라미터로 id,name이라는 이름이 있다면 자동으로 스프링이 UserSearch객체의 프로퍼티에 추가해준다.
									ㄴ @ModelAttribute가 선언되는 객체는 당연히 빈 형태로 setter/getter가 존재해야한다.
									ㄴ @ModelAttribute가 선언되는 객체는 디폴트 생성자가 있어야한다.
								ㄴ 이 어노테이션이 선언된 객체는 컨트롤러가 이후 model을 반환할때 같이 model로서 반환된다. 이름은 객체 타입과 같거나 @ModelAttribute(" (*model이름*) ")으로 지정해 줄 수 있다.
								ㄴ @RequestParam과 같이 request의 파라미터가 @ModelAttribute가 선언된 객체의 프로퍼티와 타입이 맞는지 확인을 하지만 @RequestParam과 다르게 400예외가 클라이언트로 날아가지는 않는다.
									타입변환이 불가한경우 BindException객체에 예외를 담아서 컨트롤러에게 전달해준다.
							ㄴ Errors, BindingResult )
								ㄴ 예외를 나타내는 인터페이스이다.
									ㄴ 구조 ) Errors interface
												ㄴ BindingResult interface
													ㄴ BindException class
								ㄴ @ModelAttribute를 사용할 때, @ModelAttribute의 타입변환 검사에서 발생하는 BindException에 대비해 반드시 같이 컨트롤러 메소드의 인자로 넣어주어야한다.
									ㄴ 컨트롤러 메소드 인자의 순서로, 반드시 @ModelAttribute가 선언된 인자 뒤에 와야한다.
								ㄴ 특정 객체에 대해, 바인딩 과정에서 생긴 변환오류와 validation 중에 발생한 오류에 대한 정보가 담긴다.
							ㄴ SessionStatus )
								ㄴ ?????????????????????????????????
							ㄴ @RequestBody )
								ㄴ 이 어노테이션이 선언된 메소드인자에 request body를 그대로 전달시켜주는 어노테이션이다.
									ㄴ json, xml등에서 유용하다.
								ㄴ ????????????????????????????
							ㄴ @Value
								ㄴ DI에 사용되던 이 @Value도 사용이 가능하며 사용방법은 동일하다.
							ㄴ @Valid
								ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								ㄴ 나중에 자세히 나온다함.
						</pre>
						ㄴ 4.2.2 리턴 타입 종류 ) <button>펼치기</button>
						<pre>
							ㄴ @MVC컨트롤러에서 사용가능한 리턴타입에 대해 알아본다.
							ㄴ 최종적으로는 결국 ModelAndView 형태를 반환하게 된다고 한다.
							ㄴ 자동으로 반환되는 모델에 추가되는 것들 )
								ㄴ @ModelAttribute가 선언된 객체
								ㄴ Map, Model, ModelMap 파라미터 : 이 세가지 형태가 메소드인자로 정의되면, 이객체들은 자동으로 반환되는 모델에 추가된다.
								ㄴ @ModelAttribute 메소드의 반환값
									ㄴ @ModelAttribute는 컨트롤러 메소드의 인자 뿐 아니라 컨트롤러 클래스의 일반 메소드에도 선언 할 수 있다.
										ㄴ 이 경우, 메소드인자에 설정했을때와는 다른기능을 한다.
										ㄴ 이 어노테이션이 선언된 메소드가 반환하는 값은 해당 메소드가 존재하는 컨트롤러 클래스의 다른 컨트롤러 메소드가 반환하는 model에 자동으로 추가된다.
										ㄴ 일반적으로 컨트롤러 클래스의 여러 컨트롤러메소드가 공통적으로 사용하는 model을 설정하기 위해 사용한다함.
									ㄴ ex) 	@ModelAttribute("aaa")
											public String aaa() {
												return "hello";		=>리턴값 "hello"는 컨트롤러가 반환하는 model의  "aaa"란 이름으로 자동으로 설정된다.
											}
								ㄴ BindingResult
									ㄴ @ModelAttribute를 컨트롤러메소드의 인자로 사용할때 같이 정의해주어야한다던 그 BindingResult이다.
									ㄴ 'org.springframework.validation.BindingResult.(*model이름*)' 이란 키값으로 들어간다.
									ㄴ ?????????????스프링의 JSP, 프리마커, 벨로시티 등의 뷰에 사용되는 커스텀 태그, 매크로에 사용된다함.
							ㄴ 리턴 타입의 종류 )
								ㄴ ModelAndView )
									ㄴ 다른 더 좋은 리턴타입이 많아 잘 안쓰이기는 하지만 가능하기는하다.
								ㄴ String )
									ㄴ 반환하는 문자열은 View의 이름이된다.
									ㄴ model은 따로 모델객체를 인자로 받아서 설정해 주어야 한다.
								ㄴ void )
									ㄴ 뷰 이름이 제공되지 않으므로 RequestToViewNameResolver에 의해 자동으로 뷰이름이 설정된다.
										ㄴ 컨트롤러에 해당하는 url이름으로 뷰이름이 설정된다.
								ㄴ 모델 객체 )
									ㄴ 미리 지정된 타입이나 void가 아닌 일반 객체를 반환할경우, 스프링은 이를 모델로 인식해서 자동으로 추가해준다.
									ㄴ 이름은 그 객체의 타입으로 지정된다.
									ㄴ 뷰 이름은 RequestToViewNameResolver에 따르고, 저장할 모델이 하나뿐일때 유용하다.
								ㄴ Map, Model, ModelMap )
									ㄴ ex)	@RequestMapping("/view")
											public Map view(@RequestParam int id){
												Map userMap = userService.gerUserMap(id);
												return userMap;
											}
									ㄴ 위 예처럼 Map객체를 반환할 모델에 인자로 추가하는 것이 아닌 Map객체 자체를 반환해버리면, 이 객체가 인자로 추가되어 model에서 사용 가능한것이 아니라
										이  Map자체가 model 맵이 되어서 userMap안에 있는 인자들이 model로 쓰인다.
									ㄴ userMap을 model의 인자로 사용하려면 다음과 같이해야한다.
										ㄴ ex)	@RequestMapping("/view")
												public Map view(@RequestParam int id, Model model){
													model.addAttribute("userMap", userService.gerUserMap(id));
												}
								ㄴ View )
									ㄴ 뷰 이름말고 뷰객체 자체를 반환해도 된다.
								ㄴ @ResponseBody )
									ㄴ 메소드레벨에 부여되면 해당 메소드의 반환값은 http response의 body에 그대로 들어간다.
									ㄴ ?????????????/메세지 컨버터에 의해 변환되어 보내진다고한다.
									ㄴ @RequestBody와 마찬가지로 xml, json사용에 자주쓰인다.
						</pre>
						ㄴ 4.2.3 @SessionAttribute, SessionStatus )
							ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~세션이 없을시 문제점 예시 ) 회원정보 수정 기능.
							ㄴ @SessionAttribute )
								ㄴ 클래스 레벨에 부여하는 어노테이션.
								ㄴ ex)	@Controller
										@SessionAttribute("user")
										public class UserController{ ~~ }
								ㄴ 컨트롤러가 만드는 model중 @SessionAttribute에 넘겨주는 이름과 일치하는것이 있을시, 이를 Http 세션에 저장시켜준다.
								ㄴ @ModelAttribute가 컨트롤러 메소드의 파라미터로 선언되어있을시, 이 @ModelAttribute에 해당하는 model과 @SessionAttribute에 부여된 이름이 같을시
									스프링은 @ModelAttribute가 선언된 객체를 새로만들지 않고 세션에서 가져와 사용한다.
							ㄴ SessionStatus )
								ㄴ 세션안의 데이터를 다 사용하고나면 제거해주어야한다.
								ㄴ SessionStatus의 setComplete()를 통해 세션에 저장해주었던 객체를 제거할 수 있다.
								ㄴ 4.2.1에서도 나왔지만 SessionStatus는 컨트롤러 메소드로 바로 사용할 수있는 내장 타입이다.
							ㄴ tip)
								ㄴ 스프링 @MVC에선 일반적으로 수정이든 등록이든 폼을 입력할때 세션에 객체를 저장해서 이를 가지고 폼을 뿌려준다고함.
							ㄴ @SessionAttribute 기능 테스트하기 )
								ㄴ AbstractDispatcherServletTest를 이용해 테스트할때, request로부터 HttpSession을 받아와 request.setSession( (*세션객체*) )로 추가해주는식으로
									세션을 테스트한다.
					</pre>
					ㅇ 4.3 모델 바인딩과 검증 ) <button>펼치기</button>
					<pre>
						ㄴ 스프링에서 바인딩이란 ? 객체의 프로퍼티에 값을 넣는 것을 말한다.
							ㄴ ex) xml을 이용한 빈 정의시, < property>를 이용해 빈의 프로퍼티들을 넣어주는 것.
									@ModelAttribute를 컨트롤러 메소드 파라미터에 선언시, request의 데이터를 이 어노테이션이 선언된 객체에 넣어주는 것 등.
							ㄴ 1. 적절한 형변환 과정
								ㄴ 위의 xml의 예의 경우, < property name="driverClass" value="com.mysql.jdbc.Driver"/>같은 문자열값을
									적절한 객체형태로 변환해서 값을 바인딩해주거나
								ㄴ 위의 @ModelAttribute의 예의 경우, 문자열 형태인 request의 데이터를 바인딩할 파라미터의 프로퍼티의 형태로 적절하게 변환하는 등
							ㄴ 2. setter를 호출해 값 넣기.
						ㄴ 검증이란 ? 바인딩에서 타입에 대한 검사를 끝내고 그 다음에 추가적으로 해당 값에 대해 검사하는걸 말하는 듯함.
							ㄴ 숫자가 지정된 값의 범위를 넘었거나, 문자열의 포멧이 틀렸거나, 값이 없거나, 쓸 수 없는 값이거나 등등.
							ㄴ 스프링에선 컨트롤러 로직과 검증 로직을 분리할 수 있다고 한다.
						ㄴ 스프링의 바인딩의 형변환에 쓰이는 API )
							ㄴ 4.3.1 PropertyEditor )
								ㄴ 원래는 스프링의 API가 아닌 자바빈의 인터페이스이다.
									ㄴ 문자열과 자바빈의 프로퍼티 타입 사이의 형변환 기능을 담당했었다.
								ㄴ 디폴트 PropertyEditor : 기본적으로 스프링이 제공하는 프로퍼티 에디터의 종류가 있고 해당 타입일 경우 그냥 사용할 수 있다.
														디폴트가 아니라면 직접 프로퍼티 에디터를 만들 수 있다.
								ㄴ 커스텀 PropertyEditor )
									ㄴ 디폴트 프로퍼티 에디터는 자바의 기본타입 20여가지밖에 안된다고한다. 따라서 커스텀 프로퍼티 에디터가필요하다.
									ㄴ ex)	public enum Level {
											~~~
											}
											이런 enum타입을 커스텀 PropertyEditor를 통해 자동으로 형변환이 되어서
											/user/search?level=1
											이렇게 요청을 보냈을때
											@RequestMapping("/user/search")
											~~ search(@RequestParam Level level){ ~~~ }
											이런 컨트롤러가 형변환 에러없이 enum Level형태를 받을 수 있도록 만들것이다.

								ㄴ 커스텀 PropertyEditor 등록방법 )
									ㄴ @InitBinder를 이용)
										ㄴ 알아두어야 할 내용 )
											ㄴ @Controller메소드를 호출하는 AnnotationMethodHandlerAdapter는 @RequestParam, @ModelAttribute 등과같이
												HTTP요청을 메소드 파라미터에 바인딩해야하는 어노테이션을 만나면 WebDataBinder를 만든다.
											ㄴ WebDataBinder의 기능 중 하나는 Http request으로부터 가져온 문자열을 메소드 파라미터에 맞게 형변환을 해주는것이고
												이 과정에서 PropertyEditor를 사용한다.
										ㄴ WebDataBinder에 커스텀 PropertyEditor를 등록해줌으로서 커스텀된 형변환이 가능하게 할 수 있다.
											ㄴ WebDataBinder의 형변환과정은 내부적으로돌아가므로 직접 PropertyEditor를 넣어줄 순없고
											ㄴ 스프링이 제공하는 @InitBinder를 통해서 넣어줄 수있다.
										ㄴ ex)	@InitBinder
												public void (*임의의 메소드이름*) ( WebDataBinder binder ) {
													binder.registerCustomEditor( (*에디터가적용될 타입*), (*커스텀 PropertyEditor객체*));
												}
											ㄴ @InitBinder가 붙은 메소드는 메소드 파라미터를 바인딩하기전에 자동으로 호출된다.
											ㄴ WebDataBinder를 인자로 받아 registerCustomEditor()를 호출한다.
												ㄴ 이 메소드가 커스텀 프로퍼티에디터를 등록시켜주는 메소드.
											ㄴ 같은 컨트롤러안에있는 모든 메소드에서 Http request 바인딩이 발생할때마다 적용된다.
												ㄴ @RequestParam, @CookieValue, @RequestHeader, @PathVariable, @ModelAttribute 파라미터 사용시 적용된다.
										ㄴ 커스텀 프로퍼티에디터 등록 방법 두가지 )
											ㄴ 기본적으로 위의 예에서처럼 registerCustomEditor( (*에디터가적용될 타입*), (*커스텀 PropertyEditor객체*))을 이용하여 등록하는 방ㅂ버.
												ㄴ 해당 타입이 나오면 항상 적용이된다.
											ㄴ 두번째는 특정 이름을 가진 프로퍼티의 경우에만 적용되게 등록하는 경우이다.
												ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									ㄴ WebBindingInitializer 이용 )
										ㄴ @InitBinder의 경우 속해있는 컨트롤러 안에있는 메소드들에 대해서만 적용이된다.
										ㄴ WebBindingInitializer를 이용하면 모든 컨트롤러에 한번에 적용 가능하다.
										ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									ㄴ 프로토타입 빈 프로퍼티 에디터 )
										ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

							ㄴ 4.3.2 Converter, Formatter )
								ㄴ PropertyEditor는 매번 새로운 객체를 생성해야 한다는 점에서 단점이 있다.
									ㄴ ?????????????? 스코프 부분에서 추가적인 설정이 필요하고 스레드관련 위험이 따르기때문.
								ㄴ Converter 인터페이스 )
									ㄴ PropertyEditor와 달리 인스턴스를 저장하지않고 메소드를 하나만 호출하여 변환하므로 멀티스레드 환경에서 안전하다.
									ㄴ 당연히 싱글톤으로 만들어 사용할 수 있다.
									ㄴ 형태 )	public interface Converter< S, T > {
												T covert( S source );
											}
										ㄴ S가 scouce를 의미하고 T가 target을 의미. S에서 T로의 형변환을 해준다.
					</pre>
				</pre>

				5장 Validation, Data Binding, and Type Conversion <button>펼치기</button>
				<pre>
					ㅡ 원래 보통 검증은 로직단계에서 하는데 스프링은 이와 다르게 검증 부분을 만들었다함.
					ㅡ 스프링에서 검증은 웹 같은 특정 계층에 속하지 않고 구성이 자유롭도록 만들었으며, 이를 Validator 인터페이스를 통해 구현하였다함.
					ㅡ validation 패키지 안에 DataBinder, Validator가 있으며 전자가 데이터 바인딩을 담당하고 후자가 검증을 담당.
					ㅡ ??? BeanWrapper가 이들을 구성하는 기반적인 개념이라함. 근데 직접 사용하지는 않는다함.
				</pre>

					ㅇ spring 프로젝트 구조 )
						ㅡ src폴더 )
							ㄴ
							ㄴ main 폴더 )
								ㄴ java
									ㄴ .java파일들이 모여있는곳
								ㄴ resource
									ㄴ java코드에서 사용할 resource들이 모여있는곳.
								ㄴ webapp
									ㄴ web에서 사용하는 자원들이 모여있는 곳. jsp, js, css, xml 등
									ㄴ web application의 루트 path인듯 하다.
							ㄴ test 폴더 )
								ㄴ TDD관련하여 쓰이는 폴더.
			</pre>

			ㅇ Maven<button>펼치기</button>
			<pre>
				ㅡ Maven이란 ?
					ㄴ 개발 규모가 커질수록 사용하는 라이브러리의 수도 수십가지가 되는데 이러한 라이브러리들을 관리해주는 도구. 사용하는 라이브러리뿐 아니라 그 라이브러리가 필요로하는 라이브러리까지 네트워크를 통해 자동으로 다운받아주는 도구이다.
					ㄴ pom.xml에 필요한 라이브러리를 명시해 놓으면 자동으로 처리된다.
					ㄴ java에서 쓰이는 기술이다.
					ㄴ pom.xml )
						ㄴ Project Object Model
						ㄴ maven에서 project configuation의 핵심.
				ㅡ https://maven.apache.org/guides/getting-started/index.html 참조.
				ㅡ 설치 )
				ㅡ configuration )
					ㄴ maven은 3개의 레벨로 환경설정이 이루어짐.
						ㄴ Project : 대부분의 설정은 pom.xml에서 이루어진다.
							ㄴ 유저가 누군지 상관없이 프로젝트에 대한 설정을 한다.
						ㄴ installation : maven설치시 설정되는 것
						ㄴ User : 특정 유저에 대한 설정.
				* archetype : 일종의 프로젝트 template.
				ㅡ maven 프로젝트 만들기
					ㄴ 원하는 디렉토리로 가서 다음 명령어를 입력하면 pom.xml과 함께 maven프로젝트가 저장될 폴더가 만들어진다.
					ㄴ mvn -B archetype:generate  -DarchetypeGroupId=org.apache.maven.archetypes  -DgroupId=com.mycompany.app  -DartifactId=my-app
				ㅡ POM )
					ㄴ maven은 본질적으로 프로젝트 중심적이고, 그 프로젝트에 대한 모든 내용이 이 pom.xml안에 들어있다.
					ㄴ 기본적 구성 )
						ㄴ project : 모든 maven pom.xml파일의 최상위 요소.
						ㄴ modelVersion : pom이 사용하고있는 모델의 버전. 의무이다.
						ㄴ groupId : 해당 프로젝트를 생성한 조직또는 group의 identifier.
						ㄴ artifactId : 프로젝트에 의해 생성된 primary artifact의 base name.
							ㄴ 일반적으로 primary artifact는 jar파일이라한다.
							ㄴ secondary artifact인 source들은 마지막이름의 일부로서 artifactId를 사용한다함.
							ㄴ maven에 의해 생성된 artifact들은 일반적으로 다음의 이름 형식을 따른다함.
								ㄴ (*artifactId*) - (*version*) . (*extension*)   (가령, myapp-1.0.jar)
						ㄴ packaging : 이 artifact에 의해 사용될 패키지 타입을 지칭한다. JAR,WAR, EAR등. 디폴트는 JAR.
							ㄴ 패키지 타입뿐 아니라 build lifecycle을 명시한다함.(나중에 나옴)
						ㄴ version : 프로젝트에 의해 생성된 artifact의 버전을 명시.
							ㄴ snapshot 이란것을 볼수있음. (나중에 나온다함)
						ㄴ name : 프로젝트에서 사용하는 display name을 의미.
						ㄴ url : 프로젝트의 site의 위치.
						ㄴ description : description

					ㄴ 더 자세히는 https://maven.apache.org/guides/introduction/introduction-to-the-pom.html 참조.
				ㅡ 컴파일 방법 )
					ㄴ pom.xml이 위치한 폴더에서 mvn compile 명령을 시행한다.
					* Apache Ant : maven과 마찬가지로 자바에서 제공하는 프로젝트 빌드 도구.
					ㄴ 자동으로 컴파일된 파일이 target/classess아래에 위치하는데 이런한 내용들은 Maven의 standard convention이라고하며, 많은 내용들이 이것에 의해 설정되어있어 pom.xml에는 실질적으로 아주 적은 내용만 명시적으로 설정하여도 된다고
						한다.
				ㅡ unit test 방법 )
					ㄴ mvn test 명령어 수행.
					ㄴ test시에 maven은 추가적인 dependency들을 다운받는다. 이는 컴파일에 필요한 dependency와 다르며(컴파일시에 필요한건 이미받았고 다시받지않는다), test 실행에 필요한 dependency들이다.
					ㄴ maven은 test를 컴파일하고 실행하기전에 main code들을 컴파일한다.
					ㄴ test 소스를 컴파일만 하고싶다면, mvn test-compile 명령 수행.
				ㅡ JAR생성 및 local repository에 설치 )
					ㄴ mvn package : JAR파일 만드는 명령어.
						ㄴ POM.xml에 있는 packaging 속성값에 따라 패키지타입이 결정된다.
						ㄴ target 폴더에 jar파일이 설치된다.
					ㅡ mvn install : 생성된 artifact ( jar파일)을 local repository에 설치하는 명령어
						ㄴ .mr/repository 가 디폴트 위치이다.
					ㅡ surefire plugin은 naming convention에 일치하는 이름을 가진 test파일을 찾는다.
						ㄴ **/*Test.java, **/Test*.java, **/*TestCase.java, **/Abstract*Test.java, **/Abstract*TestCase.java
				ㅡ 위의 까지의 내용들은 거의 대부분 pom에 의해 자동으로 세팅되어 편하게 사용할수 있는 것들이다. ant같은것을 사용했으면 이런것들을 설정하기위해 훨씬 긴 코드가 필요할 것이라한다.
				ㅡ 무수히 많은 maven plugin들이 있다. (ex) mvn site : 대충 웹사이트를 생성하게 해주는 명령어.
				ㅡ ???snapshot version )
					ㄴ pom에서 < version>값으로 ~~-SNAPSHOT 이라는 값형태가 있는데, 이는 코드가 안정되지 않고 바뀔수 있는 '최신'버전임을 의미한다.
					ㄴ release 이전의 'development'버전임을 의미한다.
					* ???release ???
				ㅡ plugin 사용법 )
					* Plugin )
						ㅡ maven은 플러그인 실행 프레임워크라고도 할 수 있다. 모든것이 플러그인에 의해 실행된다.
						ㅡ 두가지 종류의 플러그인이 있다.
							ㄴ Build plugin : build되는동안 실행되는 플러그인이고, pom의 < build>아래에 설정되어야 한다.
							ㄴ Reporting plugin : site generation동안 실행되는 플러그인이고, pom의 < reporting>아래에 설정되어야한다.
						ㅡ 위에서 나온 install, site 등도 모두 플러그인이고 maven에서 제공하는것이건 외부로부터 가져오는것이건 가져다쓰면되는 함수같은 느낌이다.
				ㅡ JAR에 리소스 추가하는법 )
					ㄴ ...
				ㅡ 리소스파일 filter하는 법 )
					ㄴ ...
				ㅡ ...
				ㅡ 나머지는 더 필요하면 공부하도록..
			</pre>

			ㅇ Spring Boot <button>펼치기</button>
			<pre>
				ㅡ ~~~~~
                ㅡ spring boot 구조 )
                    ㄴ spring boot는 특별한 코드 구조를 강요하지 않음.
                        단지 추천하는 최적의 관례가 있을 뿐.
				ㅡ spring boot에서 사용가능한 뷰 목록
					ㄴ JSP/JSTL
					ㄴ Thymeleaf
					ㄴ FreeMarker
					ㄴ Velocity
					ㄴ Groovy Template Engine
					ㄴ Tiles
				ㅡ thymeleaf 사용하기
					ㄴ dependency를 추가하면 기본적으로 resource폴더 안에 template안에있는 html파일들이 매칭된다.
				ㅡ jsp 사용하기
					ㄴ 설정
						ㄴ application.properties 또는 application.yml에 다음과 같이 설정
							spring.mvc.view.prefix=/WEB-INF/home
							spring.mvc.view.suffix=.jsp
							ㄴ 뷰를 반환시 뷰이름에 prefix아ㅗ suffix를 붙여 jsp파일을 매핑시키는것.
						ㄴ dependency에 다음과 같이 설정
							compile('org.apache.tomcat.embed:tomcat-embed-jasper')
							compile('javax.servlet:jstl:1.2')

					ㄴ 일반적으로 src/main/webapp/WEB-INF/(*임의의 폴더*) 안에 jsp파일들을 위치시킨다.
				ㅡ 요청 인자를 LocalDate으로 받기 )
					ㄴ 인자로 받는 dto에 @DateTimeFormat(~~~~~)을 선언해주면된다.
						ㄴ ex)
							@DateTimeFormat(iso = DateTimeFormat.ISO.DATE)
    						private LocalDate issueStartDate;
						ㄴ 어노테이션의 속성값으로 pattern을 주어 날짜형식을 설정할수도있다.
						ㄴ 예시에서나온 iso=DateTimeFormat.ISO.DATE는 'yyyy-MM-dd'형식으로 인자값을 받는 방식이다.
			</pre>

			ㅇ Spring Data JPA <button>more</button>
			<pre>
				ㅡ 의존성 )
					ㄴ ~~~~~
                ㅡ 설정 )
                    ㄴ spring boot
                        ㄴ application.properties
                            ㄴ ex )
                                spring.datasource.url= jdbc:postgresql://localhost:5432/deepqcopy
                                spring.datasource.username= (*username*)
                                spring.datasource.password= (*pw*)
                                spring.datasource.driver-class-name= org.postgresql.Driver

                                spring.jpa.database-platform= org.hibernate.dialect.PostgreSQLDialect
                                spring.jpa.hibernate.ddl-auto=create  // jpa를 통한 테이블 정의 옵션. create, update 등..
                                spring.jpa.show-sql= true

				ㅡ

				ㅡ 무제 )<button>more</button>
				<pre>
					ㄴ 기본적으로 Spring Data JPA의 목적은 db와 관련된 보일러플레이트 코드를 줄이기 위함.
					ㄴ 핵심 인터페이스는 'Repository'. 도메인 클래스와 이의 id 타입을 받는다.
						ㄴ marker interface의 역할을 한다함. 인터페이스의 타입을 지정하는 것과 이를 상속하는 인터페이스를 식별하게 하는 기능.
					ㄴ CrudRepository )
						ㄴ 기본적인 crud 기능을 제공해주는 인터페이스.
						ㄴ 일부 상세 )
							public interface CrudRepository< T, ID> extends Repository< T, ID> {

							  < S extends T> S save(S entity);

							  Optional< T> findById(ID primaryKey);

							  Iterable< T> findAll();

							  long count();

							  void delete(T entity);

							  boolean existsById(ID primaryKey);

							  // … more functionality omitted.
							}
						ㄴ 특정 영속성 기술에 특화된 추상 repository interface도 제공하고 있다. (JpaRepository, MongoRepository)
							ㄴ 이들은 CrudRepository를 상속한다.
					ㄴ CrudRepository 끝에 PagingAndSortingRepository 추상화도 존재한다. 페이징을 쉽게 해주는 구현체.
					ㄴ 쿼리 메소드 )
						ㄴ ????? CRUD기능의 repository는 내부적으로 쿼리들을 가지고 있다
						ㄴ 이 쿼리들은 다음의 과정을 통해 선언된다.
							ㄴ 'Repository' interface나 그 하위 인터페이스를 상속하는 인터페이스를 선언하고 이것에게 도메인 클래스와 id type을 정해준다.
								ㄴ ex ) interface PersonRepository extends Repository< Person, Long> { … }
							ㄴ 이 인터페이스에 메소드를 정의히나다.
								ㄴ ex ) 	interface PersonRepository extends Repository< Person, Long> {
											  List< Person> findByLastname(String lastname);
											}
							ㄴ ????? 자바 빈 주입을 말하는 드 하다.
							ㄴ repository 메소드 사용.
					ㄴ repository interface 정의하기 )<button>more</button>
					<pre>
						ㄴ 일반적으로, 'Repository', 'CrudRepository', 'PagingAndSortingRepository'을 상속하여 repository를 만든다.
							이를 사용하지 않으려면, @RepositoryDefinition을 이용하여 repository를 만들 수 있다.
						ㄴ CrudRepository 인터페이스 안에는 엔터티를 조작할 모든 메소드가 노출된 상태로 있다.
							이를 선택적으로 노출시키려면, CrudRepository를 상속하는 커스텀 repository를 만든 뒤, 이 커스텀 repository에
							노출시키고자 하는 메소드들만 정의한 뒤, 이를 내가 사용하려는 repository가 상속하게 하면 된다.
							ㄴ ex) 	@NoRepositoryBean
									interface MyBaseRepository< T, ID> extends Repository< T, ID> {

									  Optional< T> findById(ID id);

									  < S extends T> S save(S entity);
									}

									interface UserRepository extends MyBaseRepository< User, Long> {
									  User findByEmailAddress(EmailAddress emailAddress);
									}
							ㄴ ????? 이렇게 노출시킨 메소드들은, 스프링 데이터에서 개발자가 선택한 기본 repository로 route된다?
							* @NoRepositoryBean : 스프링이 빈으로 생성하지 않기를 바라는 중간 repository에 선언.
						ㄴ ????? 여러개의 스프링 데이터 모듈을 사용하는 경우 )
							ㄴ 한 개의 스프링 데이터 모듈을 사용하는 경우와 달리, 여러개를 사용하면
								스프링 데이터가 자동으로 엄격한 설정 모드로 바뀌고 특정한 규칙에 따라 repository 정의에 어떤 모듈을 사용할지 결정한다.
							ㄴ 규칙 )
								ㄴ repository가 특정 모듈의 repository를 상속한 경우, 그 특정 스프링 데이터 모듈의 후보가 된다.
									ㄴ ex )
										interface MyRepository extends JpaRepository< User, Long> { }  // String Data JPA Module의 JpaRepository가 상속되었기 때문에, MyRepository는 이 모듈의 후보가 된다.

										@NoRepositoryBean
										interface MyBaseRepository< T, ID> extends JpaRepository< T, ID> { … }  // 마찬가지.

										interface UserRepository extends MyBaseRepository< User, Long> { … }
									ㄴ ex 2 )
										interface AmbiguousRepository extends Repository< User, Long> { … }  // 한 종류의 Spring Data Module을 사용하는 경우는 아무 문제 없으나, 아닌 경우, 이것만으로 어떤 모듈을 사용해야 하는지 스프링이 구분할 수 없다.

										@NoRepositoryBean
										interface MyBaseRepository< T, ID> extends CrudRepository< T, ID> { … } // 마찬가지.

										interface AmbiguousUserRepository extends MyBaseRepository< User, Long> { … }

								ㄴ repository에 선언된 domain class가 특정 모듈의 type annotation이 선언되었다면,
									그 특정 스프링 데이터 모듈의 후보가 된다.
									ㄴ ex )
										interface PersonRepository extends Repository< Person, Long> { … }  // JPA모듈의 @Entity가 붙은 Person domain class를 사용하는 repository이므로, JPA모듈의 후보가 된다.

										@Entity
										class Person { … }

										interface UserRepository extends Repository< User, Long> { … } // 마찬가지로 MongoDB모듈의 후보가 된다.

										@Document
										class User { … }
									ㄴ ex 2 )
										interface JpaPersonRepository extends Repository< Person, Long> { … }  // Person domain class에 JPA모듈, MongoDB모듈의 어노테이션이 모두 붙었기 때문에 스프링은 어떤 모듈을 바인딩할지 결정할 수 없다.

										interface MongoDBPersonRepository extends Repository< Person, Long> { … }

										@Entity
										@Document
										class Person { … }
								ㄴ ????? repository의 basePackage를 설정하여 모듈 특정 가능.
									ㄴ basePackage : repository 정의 서칭시 시작 지점.
									ㄴ 당연히, 적절한 패키지 위치에 repository 정의 필요.
					</pre>

					ㄴ 쿼리 메소드 정의 <button>more</button>
					<pre>
						ㄴ repository가 메소드명으로부터 저장소(보통 db)에 맞는 쿼리를 만들어 내는 전략이 있다.
							ㄴ 메소드명에서 직접 가져오는 방식.
							ㄴ 수동으로 정의된 쿼리를 가져오는 방식.
						ㄴ xml 설정의 'query-lookup-strategy', 자바 config의 @Enable${store}Repositories의 queryLookupStrategy 속성으로 lookup 전략 설정 가능.
						ㄴ 전략 )
							ㄴ CREATE
								ㄴ 쿼리 메소드 이름으로 저장소에 맞는 쿼리를 생성하는 전략.
									기본적인 방식은 메소드 이름에서 특정 prefix들을 제거하고 나머지 부분으로 쿼리 생성.
							ㄴ USE_DECLARED_QUERY
								ㄴ 미리 선언된 쿼리를 사용하는 전략. 발견하지 못하면 예외.
									미리 선언된 쿼리는 다른 곳에 있는 어노테이션이나 다른 방법으로 정의할 수 있다.
							ㄴ CREATE_IF_NOT_FOUND
								ㄴ 위 두 옵션을 합친 전략. USE_DECLARED_QUERY를 먼저 적용하고 없을시, CREATE를 적용.
									디폴트 전략.
						ㄴ 쿼리 create ) <button>more</button>
						<per>
							ㄴ 쿼리 메소드명은 쿼리로 만들어지기 위해 '주부'와 '술부'로 나뉘어 진다. (주부는 주어, 대상 같은 것. 술부는 동사 같은 것)
								ㄴ 'find~~~~~By', 'exists~~~~~By' 등이 '주부'를 구성하고 그 뒷부분이 '술부'를 구성한다.
								ㄴ ?????
						</per>
						ㄴ ~~~~~

					</pre>

					ㄴ repository 인스턴스 생성 <button>more</button>
					<pre>
						ㄴ 정의된 repository 인터페이스를 자바 빈으로 정의하고 인스턴스를 생성하는 방법에 대해 다룸.
						ㄴ xml 이용 )
						ㄴ 자바 config 이용 )
						ㄴ ????? standalone )


					</pre>

					ㄴ ~~~~~

					ㄴ JPA Repository <button>more</button>
					<pre>
						ㄴ Spring Data JPA 설정
							ㄴ XML 설정
							ㄴ 자바 Config 설정
						ㄴ Persisting Entity )
							ㄴ CrudRepository.save()가 JPA EntityManager를 통해 엔터티를 persist 또는 merge해준다.
							ㄴ 해당 엔터티가 persist 되지 안은 경우, EntityManager가 persist()를 호출하고 아닌 경우, merge()를 호출.
							ㄴ 해당 엔터티가 persist 상태인지 아닌지는 Spring Data JPA가 다음 전략에 따라 결정한다.
								ㄴ ??? version 속성, id 속성 확인 )
								ㄴ

					</pre>

				</pre>

			</pre>


		</pre>

		Linux<button>펼치기</button>
		<pre>
			~~~

			ㅡ FHS (=Filesystem Hierarchy Standard)
				ㄴ unix-like 시스템의 파일시스템 구조에 대한 컨벤션.
					ㄴ ex ) 맨 위에 root( / ), 그 아래 /etc, /bin 등등이 있는 구조를 말함.
			ㅡ Unix-like os의 파일 시스템
				ㄴ 가상 파일 시스템을 만든다.
				ㄴ 이 가상 파일 시스템에서는 단 하나의 루트 디렉토리가 존재하고 다른 모든 파일, 디렉토리들은 이 하위에 존재한다. (계층형)
				ㄴ 마운팅
					ㄴ 어떤 장치 안에 들어있는 파일들이 파일 시스템 상의 특정 위치에 보이도록하여 사용자가 접근할 수 있게 하는 기능.
					ㄴ ex ) usb의 파일들을 마운트하여 /media 위치에서 이 파일들에 접근할 수 있음.
					ㄴ 이때 파일들을 접근 가능하게 된 위치를 'mount point' 라고 함. ex ) /media

			ㅡ chroot
				ㄴ UNIX-like os에서 모든 프로세스는 root directory를 가짐. 대부분은 시스템의 루트 디렉토리와 동일.
				ㄴ chroot 명령어를 통해 이 루트 디렉토리를 변경할 수 있다.
				ㄴ 보통 고립된 환경을 세팅하기 위해 사용된다.
					??? 레거시 라이브러리를 필요로하는 소프트웨어 구동을 위해서 또는 소프트웨어 설치와 디버깅의 단순화?
				ㄴ 프로세스가 root directory 밖으로 탈출할 수 있기 때문에 보안용도로는 사용되지 않는다.

			ㅡ namespace
				ㄴ ???namespace라는 것을 두고, 프로세스들과 커널 자원들을 특정 네임스페이스에 속하게 하고
					각자가 속한 네임스페이스 내의 자원들만 '볼수???' 있도록하는 기능?
				ㄴ ??? '볼 수 없는 것'이란?
					ㄴ 이해 및 실습을 하지 않아 정확하지는 않지만, 글에서 현상적으로 보았을 때,
						그냥 해당 네임스페이스 안에 있으면 다른 볼 수 없는 네임스페이스(부모나 형제 네임스페이스)의
						자원들(프로세스, 네트워크 인터페이스, 마운트 포인트 등)이 존재하지 않는 것처럼 동작함. 인식이 안됨.
				ㄴ PaaS 등에서 컨테이너로서 사용되고,
					같은 os kernel 자원을 사용하고 있지만 마치 별도의 vm 위에 있는 것처럼 ns별로 독립적으로 할당받은 자원을 사용하는 것.
				ㄴ ???컨테이너 처럼 가두거나 할때 쓰이고?
				ㄴ ns는 프로세스당 최대 하나 할당 가능.
				ㄴ linux에서 보통 /proc/(*pid*)/ns 에 네임스페이스가 있다.
				ㄴ 새 프로세스 생성시, 모든 네임스페이스가 상속된다.
				ㄴ clone 또는 unshare syscall로 ns 생성 가능.
					ㄴ clone 사용시, 새로운 ns를 가진 프로세스 생성.
					ㄴ unshare 사용시, 새로운 ns를 생성하고 현재 프로세스를 이 ns로 이동.
				ㄴ 종류
					ㄴ PID namespace
						ㄴ process tree를 고립시킨다.
						* 리눅스 프로세스들은 계층형 트리 구조를 가진다.
							예전엔 리눅스는 단 하나의 프로세스 트리를 가졌다.
							이 프로세스 트리는 procfs라는 파일시스템에 의해 관리.
							pid 1번이 보통 프로세스 트리에서 root 프로세스가 되며, systemd인 경우가 많다.
						ㄴ pid namespace를 통하여 중첩 process tree 생성 가능.
							ㄴ 각 중첩 프로세스 트리의 루트 프로세스는 자신을 루트 프로세스로 인식 가능하며, 중첩 트리 안에서 pid=1
							ㄴ 중첩 프로세스 트리 내 다른 프로세스들도 중첩 프로세스 트리에 해당하는 pid들을 각각 가짐.
								즉, 한 프로세스가 여러개의 pid를 가질 수 있음.
							ㄴ 부모 pid namespace에선 루트 프로세스로부터 뻗어간 프로세스 트리가 모두 보이나,
								특정 pid namespace에선 해당 프로세스 트리 밖에 보이지 않으므로 보이지 않는 프로세스들과 상호작용할 수 없음.
						ㄴ ??? 다른 ns 종류들과 다르게, clone(), fork()를 통하여 새 프로세스가 생성될 때에만 생성가능.
					ㄴ mount namespace
					ㄴ network namespace
					ㄴ ~~~
				ㄴ 각 namespace 종류들에 대한 설명 및 실습 참고
					ㄴ https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504
					ㄴ https://blog.quarkslab.com/digging-into-linux-namespaces-part-1.html
					ㄴ google 검색 키워드 : "how to work linux namespace"

            ㅇ SELinux
                ㅡ

            ㅇ RPM, RPM Package manger, Red Hat Package Manger
                ㅡ free opensource package 관리 시스템.
                ㅡ 파일 포멧 : .rpm
                ㅡ linux 배포판들에서 사용.
                ㅡ ~~~
                ㅡ front end
                    ㄴ yum
                        ㄴ Fedora Linux, Centos 5 이상, Red Hat Enterprise Linux 5 이상, Scientific Linux, Yellow Dog Linux, Oracle Linux 에서 사용.
                        ㄴ ~~~
                    ㄴ DNF
                        ㄴ Fedora Linux 18 이상, Red Hat Enterprise 8 이상, AlmaLinux 8, CentOS Linux 8 에서 사용.
                        ㄴ ~~~

			Centos 7<button>펼치기</button>
			<pre>
				...

				ㅇ 기본 명령어들 )
					ㅡ cp )
						ㄴ 복사 명령어
						ㄴ cp (*복사대상파일*) (*파일이름*) : 복사대상을 복사하여 두번째인자인 파일을 만든다.
						ㄴ cp (*복사대상파일*) (*디렉토리*) : 복사대상파일을 해당 디렉토리로 복사한다. (복사대상을 여러개 선택할수있다) ex) cp file1 file2 file3 (*디렉토리*)
					ㅡ rm )
						ㄴ 삭제명령어
						ㄴ rm (*파일*) : 해당 파일 삭제
							ㄴ ex) rm *.dat :  .dat으로 끝나는 모든 파일 삭제.
							ㄴ rm * : 모든파일삭제.
						ㄴ rm -r (*디렉토리*) : 디렉토리삭제. 안에파일이 있어도 삭제함.
					ㅡ pwd : print working directory. 현재 작업중인 디렉토리 위치 출력.
                    ㅡ ??? route )
                        ㄴ 라우팅 테이블 확인.
                        ㄴ ex )
                            Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
                            default         gateway         0.0.0.0         UG    100    0        0 em4  # 디폴트 게이트웨이???
                            192.168.0.0     0.0.0.0         255.255.255.0   U     100    0        0 em4

				ㅇ rpm
					ㅡ Redhat사에서 개발한 패키지 관리 프로그램.
					ㅡ Maven처럼 프로그램설치시 필요한 의존성이 있으면 자동으로 필요한 패키지들을 함께 설치해 준다.
					ㅡ ~~.rpm 형식의 파일이름을 가지며, 이름부분에는 정해진 규칙을 따르는 패키지명을 가진다.
						ㄴ (*패키지이름*)-(*소스버전*)-(*릴리즈버전*).(*배포관리버전*).(*아키텍쳐*).rpm
						ㄴ ex) mysql-connector-java-5.1.25-3.el7.noarch.rpm
					ㅡ 명령어 )
						ㄴ 기본형태 )  rpm [옵션] [rpm 패키지파일 또는 rpm 패키지이름]
						ㄴ 패키지 설치여부 조회 )
							ㄴ rpm -qa :
							ㄴ rpm -qa (*패키지이름*) : 해당 패키지 조회
							ㄴ rpm -qa | grep : 좀더 세밀한 조회
						ㄴ 설치명령어 )
							ㄴ rpm -Uvh (*패키지파일*) : 해당 패키지파일 설치명령어. -Uvh는 옵션. U는 패키지가 이미설치되어있으면 upgrade를 진행, v는 설치과정 출력, h는 진행률 출력.
						ㄴ 패키지 삭제 )
							ㄴ rpm -e (*패키지파일*)

				ㅇ yum
					ㅡ rpm의 대용으로 나온 패키지 관리 프로그램.
					ㅡ 명령어 )
						ㄴ yum install (*패키지명*)
						ㄴ yum groupinstall (*그룹명*)
						ㄴ yum check-update : 업데이트가 되어있는 패키지목록 확인
						ㄴ yum update : 설치된 패키지들을 최신버전으로 업데이트
						ㄴ yum update (*패키지명*) : 해당 패키지를 업데이트
						ㄴ yum list installed : 설치된 패키지 확인
						ㄴ yum list : 설치가능한 패키지 목록 확인
						ㄴ yum info (*패키지명*) : 패키지 정보보기
						ㄴ yum localinstall : local에 있는 rpm파일을 설치할때 사용된다.

				ㅇ inetd, xinetd
					ㅡ 개인적 개요 )
						ㄴ 리눅스의 인터넷 데몬같은것?
					ㅡ xinetd : extended inetd
					ㅡ 인터넷 서비스를 제공해주는 프로그램을 실행시킨다.
					ㅡ conf파일에 설정되어있는 모든 포트에 대해 listen을 하고 있다가 request가 도착하면 이에 맞는 적절한 서버를 실행시켜준다.
					ㅡ 'super server'라고도 불린다.

				ㅇ inetd 모드, standalone 모드
					ㅡ inetd 모드 : inetd를 통해서 서비스가 실행되는 모드를 말한다.
					ㅡ standalone 모드 : inetd없이도 혼자서 서비스가 실행되는 모드를 말한다.

				ㅇ vsftpd
					ㅡ ftp서버 프로그램.
					ㅡ ...
					ㅡ 사용법 )
						ㄴ  vsftpd.conf )
							ㄴ vsftpd에 관한 설정파일. https://linux.die.net/man/5/vsftpd.conf 참조.
							ㄴ anon_upload_enable : wirte_enable항목이 YES일때만 효과가 적용되며, 익명사용자가 업로드를 할수있게하는 항목.
							ㄴ write_enable :
							ㄴ userlist_file : userlist_enable항목이 활성화되어있을때 사용된다. 여기에 적힌 파일로부터 username list를 가져온게된다.
								디폴트는 /etc/vsftpd/user_list.
							ㄴ userlist_enable : 활성화되면, userlist_file에 적힌 파일로부터 user list를 가져와 이들이 로그인하는걸 막는다.
								(비번을 요구하기전에 거부된다). 디폴트는 NO이다.
							ㄴ userlist_deny : userlist_enable이 활성화되어있을때 사용된다. NO이면 userlist_file에 있는 유저만 접근이 가능하다.
								yes인경우 userlist_file에 있는 유저들의 접근을 거부한다. (비번을 요구하기전에 거부된다) 디폴트는 YES이다.

				ㅇ firewall 방화벽
					ㅡ iptables 명령어를 이용한 설정 : 이전버전에서 사용되었고 사용이 어렵다는 단점이 있다.
					ㅡ firewall-cmd, firewall-config
						ㄴ 새롭게 방화벽설정에 사용되는 명령어. 전자가 cmd환경에서, 후자가 gui환경에서 사용가능하다.
						ㄴ --permanent 옵션 )
							ㄴ firewall-cmd 명령어에 --permanent 옵션을 붙일 수 있다.
							ㄴ 이는 해당명령의 정책을 영구적으로 적용하라는 의미이다.
							ㄴ 이 옵션으로 정책설정후, firewall-cmd --reload 명령어를 입력하거나 재부팅을 해야 적용이된다. 그전엔 적용안됨.
							ㄴ 이게 없을시, 영구적용이 아닌 임시로 적용하게되며, 재부팅 또는 firewall-cmd --reload 명령시 리셋된다.
					ㅡ 사용법 )
						ㄴ firewall이 구동중인지 확인 : firewall-cmd --state
						ㄴ 설치 : yum install firewalld
						ㄴ firewall이 실행되도록 설정 )
							 systemctl enable firewalld
							 systemctl start firewalld
						ㄴ 특정 포트 및 서비스 방화벽 허용 )
							firewall-cmd --permanent --add-port=80/tcp
							firewall-cmd --permanent --add-service=http
							ㄴ --zone=(*zone이름*) 을 추가하여 네트워크zone을 설정할수도있다. 없으면 디폴트설정된걸로 설정.
						ㄴ 허용하고있는 port확인 )
							firewall-cmd --list-ports

				ㅇ centos7 mysql 설치 및 실행
					ㅡ 설치 )
						ㄴ rpm파일을 다운받는다.
						ㄴ yum install mysql-community-server로 mysql을 설치한다.
						ㄴ mysql을 실행한다. systemctl start mysqld
						ㄴ mysql을 처음설치하면 /var/log/mysqld.log안에 temporary password가 존재한다. 이를 이용하여 맨 처음 mysql에 접속할 수 있다.
							ㄴ 처음 접속한 뒤, 반드시 비밀번호를 변경해주어야한다. 안하면 아무 명령도 실행안됨.
							ㄴ  alter user 'root'@'localhost' identified by '(*새 비밀번호*)';
						ㄴ mysql에 접속한다. mysql -u root -p
							ㄴ 이거치면 비번입력하라뜨고 위의 temporary password로 입력하고 비번바꿔주면된다.
						ㄴ 이후 mysql을 사용하면된다.
					ㅡ 설정 )
						ㄴ centos에서는 mysql설정이 명령어 또는 전용 설정파일에서 가능하다.
						ㄴ 전용 설정파일은 여러종류가 있는듯하고 각각 적용범위에 차이가 있는듯하다.
						ㄴ my.cnf 설정 )
							ㄴ 전용 설정 파일들중 하나이다.
							ㄴ (*프로퍼티*) = (*값*) 형태로 설정내용들을 적는다.
							ㄴ 세세한 프로퍼티들은 다음을 참조. https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html

                ㅇ ip 설정<button>more</button>
                <pre>
                    ㅡ ~~~
                    ㅡ 고정 ip 설정<button>more</button>
                    <pre>
                        ㄴ /etc/sysconfig/network-script 위치에 'ifcfg-(*네트워크 인터페이스명?*)'과 같은 형식으로 각 네트워크 인터페이스의 설정파일들이 존재.
                            ㄴ ex) ifcfg-em1
                            ㄴ ex )
                                TYPE="Ethernet"
                                PROXY_METHOD="none"
                                BROWSER_ONLY="no"
                                BOOTPROTO="dhcp"
                                DEFROUTE="yes"
                                IPV4_FAILURE_FATAL="no"
                                IPV6INIT="yes"
                                IPV6_AUTOCONF="yes"
                                IPV6_DEFROUTE="yes"
                                IPV6_FAILURE_FATAL="no"
                                IPV6_ADDR_GEN_MODE="stable-privacy"
                                NAME="em4"
                                UUID="87c24268-dc3a-437f-ba8b-8c758b841ea1"
                                DEVICE="em4"
                                ONBOOT="yes"
                        ㄴ 파일 내의 다음 항목들을 수정하고 systemctl restart network 하여 적용 가능하다.
                            ㄴ BOOTPROTO = "none"  # dhcp값이면 dhcp로 자동할당되므로 수정.
                            ㄴ PIADDR = (*고정할 ip주소*)
                            ㄴ PREFIX = (*넷마스크 prefix*)
                            ㄴ GATEWAY = (*gateway ip*)
                            ㄴ DNS1 = (*dns ip*)
                            ㄴ DNS2 = (*dns ip*)
                            ㄴ ONBOOT = "yes"  # yes 이어야 부트시 네트워크 설정이 진행.
                        ㄴ 또는 nmtui 명령어로 설정 가능.
                            ㄴ systemctl status NetworkManager 로 'NetworkManager'가 실행중인지 확인.
                                ㄴ ??? NetworkManager란?
                            ㄴ nmtui 명령어 입력하면 설정 gui창이 뜨고 ip설정이 가능하다.
                    </pre>
                </pre>

			</pre>

		</pre>

        Package Manager, 패키지 매니저<button>more</button>
        <pre>
            ㅇ
                ㅡ 컴퓨터에서 프로그램을 설치, 업데이트, 설정, 삭제하는 과정을 일관된 방식으로 자동화해주는 소프트웨어의 모음.
                ㅡ archive file의 데이터, 소프트웨어 배포, 패키지를 다룬다.
                    ㄴ 패키지의 메타데이터 안에는 소프트웨어의 이름, 설명, 버전, vendor, checksum, 필요한 의존성 목록 등이 포함.
                ㅡ 소프트웨어 패키지를 서칭, 설치, 관리, 삭제하는 작업을 해준다.
                ㅡ 기능
                    ㄴ 'file archiver'로 패키지 archive 추출.
                    ㄴ checksum, digital certificate를 통한 패키지의 integrity 와 authenticity 보장.
                    ㄴ software repository나 app store로부터 프로그램들을 서칭, 다운로드, 설치, 업데이트.
                    ㄴ ??? 유저 혼란을 줄이기 위한 패키지 그룹화
                    ㄴ 패키지의 의존성 관리.
                ㅡ ~~~

        </pre>

		보안 <button>펼치기</button>
		<pre>
			ㅡ 방화벽이란?
				ㄴ 네트워크상의 트레픽에 대해, 이를 모니터링하고 미리정해둔 규칙에 따라 제어하고 차단하는 시스템.
				ㄴ 소프트웨어 또는 하드웨어 일 수 있다.
			ㅡ 대칭키 암호화 : 하나의 키로 암호화와 복호화가 진행되고 이때의 키를 말한다.
			ㅡ 비대칭키 암호화 )
				ㄴ 대칭키와 다르게 두개의 키로 암호화, 복호화를 진행하는 방식에서 사용되는 키이다.
				ㄴ 키 중에 하나로 암호화를 하면, 다른 하나로 복화하가 가능하고, 그 반대도 가능하다.
				ㄴ 보통 키 중 하나는 여러 곳에 배포하고 다른 하나는 자신만 조심해서 가지고 있기 때문에 전자를 '공개키', 후자를 '개인키'라고 한다.
					ㄴ 하여 비대칭키 암호화를 공개키 암호화 방식이라고도 한다.
				ㄴ 공개키로 암호화를 진행하고 개인키로 복화를 한다.
			ㅡ CORS(Cross-Origin Resource Sharing), SOP(Same-Origin Policy) )
				ㄴ SOP )<button>more</button>
				<pre>
					ㄴ 한 origin에서 나온 document, script, media file들이 다른 origin과 상호작용할 수 없도록 제약하는 정책.
					ㄴ origin이란? )
						ㄴ url의 프로토콜, host(또는 ip), 포트의 조합을 의미.
					ㄴ ????? web 초창기에 단순히 document만을 보여주던 것과 달리, js와 DOM api 등이 나오면서 웹에서 여러 기능이
						가능해졌고, 이와 동시에 이러한 웹에서 CSRF와 같은 공격의 위험이 생겨났다.
						이에 대해 netscape에서 소개한 정책이다.
						ㄴ 고정된 표준이 아닌, 브라우저들이 각자 알아서 적용하는 일반적인 보안 정책.
					ㄴ 위험의 예? )
						ㄴ 페북 사이트를 iframe으로 가지고 있는 악성 웹사이트가 있다고 치면,
							페이크 사이트인 줄 모르고 여기서 페북으로 로그인을 하게되면, 악성 사이트에서 스크립트 등으로 iframe 안의
							페북 사이트에 접근하여 개인 정보 유출 등이 가능하다.
					ㄴ 내용 )
						ㄴ ????? 초기 원문? http://css.csail.mit.edu/6.858/2015/lec/l11-web-security.txt
						ㄴ ????? 이에 대한 해석? https://docs.microsoft.com/ko-kr/archive/blogs/ieinternals/same-origin-policy-part-1-no-peeking
						ㄴ js code, DOM, 쿠키, XmlHTTPRequest에 적용된다.
						ㄴ 모든 자원에 대해 적용되는 게 아니다.
							ㄴ cross origin으로 포함시킬 수 있는 html 태그들은 다음과 같다.
								ㄴ iframe, img, script, video, link, object, embed, form
								ㄴ '포함'시킬 수 있는 것이지, 이러한 cross origin 태그에 대해 읽기 작업은 가능하지 않다.
						ㄴ !!!!! 구체적으로 브라우저별, 또는 공통적으로 어떤 제약 내용이 있는지, 어디에 나와 있는지는 모르겠다.
							ㄴ https://datatracker.ietf.org/doc/html/rfc6454#section-3.4 참고?
						ㄴ 각 페이지들은 각각의 origin을 가진다.
						ㄴ 각 페이지들은 각각의 resource들을 가진다. (쿠키, DOM, js namespace 등)
						ㄴ script는 이것의 원 출처가 아닌, 로드된 origin의 context 안에서 실행된다. 즉, 최종적으로 script가
							실행되는 origin의 context.
						ㄴ 미디어, 이미지 resource들은 'passive resource'?로서, 로드된 origin의 context의 object나 resource에
							접근하지 않는다.
					ㄴ 해체 및 완화 )
						ㄴ js의 document.domain 수정 )
							ㄴ document.domain = "~~~~~"
							ㄴ origin을 직접 수정하여 sop 제약을 해결할 수 있다.
							ㄴ 단, 수정하려는 origin이 현재 origin의 subdomain이어야 한다.
						ㄴ CORS, Cross-Origin Resource Sharing 사용 )
							ㄴ
				</pre>
				ㄴ CORS )<button>more</button>
				<pre>
					ㄴ 교차 출처 리소스 공유 (Cross-Origin Resource Sharing)
					ㄴ 일반적으로는 SOP를 따르기 때문에 불가하지만,
						HTTP 헤더를 사용하여 다른 origin의 자원에 대한 접근 권한을 브라우저가 부여하도록 하는 정책.
						ㄴ origin이란 )
							ㄴ
						ㄴ 특정 조건이란, 요청하려는 다른 origin에서 준 응답 안의 CORS헤더에 현재 요청을 보내는 origin이 포함되어 있어야함.
							ㄴ 응답의 CORS 헤더란,
					ㄴ 이렇게 다른 origin으로 보내는 요청을 'Cross-origin request'라 하고, CORS 정책에 따라 처리된다.
					ㄴ js의 fetch api 등은 이 CORS 정책을 따른다.
					ㄴ 내용 )
						ㄴ 적용 시점 )
							ㄴ XMLHttpRequest, Fetch API 호출시.
							ㄴ ????? 웹 폰트
							ㄴ ????? WebGL 텍스쳐
							ㄴ ????? drawImage()
							ㄴ ????? 이미지로부터 추출하는 CSS Shapes
						ㄴ 동작 방식 세 가지 )
							ㄴ simple request )<button>more</button>
							<pre>
								ㄴ 다음 조건을 만족하는 요청으로서, 'Preflight request' 없이 바로 서버로 전송된다.
									(https://fetch.spec.whatwg.org/#cors-safelisted-request-header 참고)
									ㄴ request method가 GET, POST, HEAD 중 하나.
									ㄴ Fetch 명세에서 'forbidden header name'으로 정의한 헤더와
										'accept', 'accept-language', 'content-language', 'content-type' 이외에
										커스텀 헤더가 없는 경우.
									ㄴ content-type 헤더의 경우, 다음 값 중 하나인 경우.
										ㄴ application/x-www-form-urlencoded
										ㄴ multipart/form-data
										ㄴ text/plain
								ㄴ simple request의 경우, 바로 서버로 전송된다.
								ㄴ 보내면 서버에서 'Access-Control-Allow-Origin' 헤더가 포함된 응답을 주면, 이 헤더 안의 값으로
									현재 origin이 cors요청이 허용되는지 확인할 수 있다. 헤더 값은 없거나, 현재 origin이거나 와일드카드(*)이다.
									현재 origin이 서버에서 허용되면 현재 origin값이 들어있고, 모든 origin에 대해 허용하고 있으면 와일드카드,
									허용 안 하면 값이 없다.
								ㄴ ex )
									http://localhost:8000인 origin에서 다음 요청.
									$.ajax({
										url: "http://dlencdiv.kr/pages/ajax/addCustomSocialKeyword",
										type: "POST",
										data: JSON.stringify({}),
										contentType: "text/plain"
									})
									ㄴ 조건이 simple request에 해당하므로, 바로 요청이 들어가고 다음과 같은 오류가 뜨며 실패. (서버에서 CORS설정 안 해둔 상태)
										ㄴ Access to XMLHttpRequest at 'http://dlencdiv.kr/pages/ajax/addCustomSocialKeyword' from origin 'http://localhost:8001' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
							</pre>
							ㄴ Preflight request )<button>more</button>
							<pre>
								ㄴ simple request의 조건을 만족하는 경우가 아닌 경우에,
									브라우저가 cors요청 전에 서버에게 'OPTION' request 메소드로 여러 정보를 보내어
									본 cors request를 보내기 전에 cors요청이 수용 가능한지 체크한다.
								ㄴ preflight request, response 예 )<button>more</button>
								<pre>
									ㄴ preflight request )
										OPTIONS /resources/post-here/ HTTP/1.1
										Host: bar.other
										User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
										Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
										Accept-Language: en-us,en;q=0.5
										Accept-Encoding: gzip,deflate
										Connection: keep-alive
										Origin: http://foo.example
										Access-Control-Request-Method: POST
										Access-Control-Request-Headers: X-PINGOTHER, Content-Type
										ㄴ 'Access-Control-Request-Method'는 실제 전송 떄, 어떤 메소드로 요청할 것인지를 알려줌.
										ㄴ 'Access-Control-request-Headers'는 실제 전송 떄, 어떤 사용자 정의 헤더가 포함되는지 알려줌.

									ㄴ preflight response )
										HTTP/1.1 204 No Content
										Date: Mon, 01 Dec 2008 01:15:39 GMT
										Server: Apache/2
										Access-Control-Allow-Origin: https://foo.example  // cors요청이 허용된 origin을 나타내는 헤더.
																							// 모든 origin에 대해 cors요청을 허용하면 와일드카드값이고, 현재 요청보내는 origin에 대해 허용시, 현재 요청을보내는 origin이 값이다.
										Access-Control-Allow-Methods: POST, GET, OPTIONS  // 이 메소드들로 요청 가능한 리소스임을 알려줌.
										Access-Control-Allow-Headers: X-PINGOTHER, Content-Type  // 이 헤더들을 커스텀하여 요청할 수 있음을 알려줌.
										Access-Control-Max-Age: 86400  // 이 preflight 요청에 대한 응답을 브라우저가 캐싱해 두어, 다음 요청시 preflight request가 필요 없도록 함. 이 떄 캐싱하는 최대 시간값을 나타냄.
										Vary: Accept-Encoding, Origin
										Keep-Alive: timeout=2, max=100
										Connection: Keep-Alive

									ㄴ 본 request )
										POST /resources/post-here/ HTTP/1.1
										Host: bar.other
										User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0
										Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
										Accept-Language: en-us,en;q=0.5
										Accept-Encoding: gzip,deflate
										Connection: keep-alive
										X-PINGOTHER: pingpong
										Content-Type: text/xml; charset=UTF-8
										Referer: https://foo.example/examples/preflightInvocation.html
										Content-Length: 55
										Origin: https://foo.example  // 요청을 보내는 origin.
										Pragma: no-cache
										Cache-Control: no-cache

										< person>< name>Arun< /name>< /person>

									ㄴ 본 response )
										HTTP/1.1 200 OK
										Date: Mon, 01 Dec 2008 01:15:40 GMT
										Server: Apache/2
										Access-Control-Allow-Origin: https://foo.example
										Vary: Accept-Encoding, Origin
										Content-Encoding: gzip
										Content-Length: 235
										Keep-Alive: timeout=2, max=99
										Connection: Keep-Alive
										Content-Type: text/plain

										[Some GZIP'd payload]
								</pre>
								ㄴ ex )
									http://localhost:8000인 origin에서 다음 요청
									$.ajax({
										url: "http://dlencdiv.kr/pages/ajax/addCustomSocialKeyword",
										type: "POST",
										data: JSON.stringify({}),
										contentType: "text/plain"
									})
									ㄴ 조건이 simple request에 해당되지 않으므로 preflight request로 들어간다.
										OPTIONS메소드로 요청이 먼저 날아가고 다음 에러 뜨며 실패. (서버에서 CORS설정 안 해둔 상태)
										Access to XMLHttpRequest at 'http://dlencdiv.kr/pages/ajax/addCustomSocialKeyword' from origin 'http://localhost:8001' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: Redirect is not allowed for a preflight request.
								ㄴ preflight 후 리다이렉트 이슈 )
									ㄴ ?????
							</pre>
							ㄴ CORS 요청시, credential 정보 포함 )
								ㄴ 기본적으로, cors 요청시, credentail 정보(쿠키, authentication, certificate)를 포함시키지 않는다.
									이를 전달하기 위해선 요청 생성시 특정할 플래그 값을 주어서 이를 포함시킬 수 있다.
								ㄴ XMLHttpRequest의 경우 )
									ㄴ 	const req = new XMLHttpRequest();
										req.open("GET", url, true);
										req.withCredentials = true;  // withCredentials란 값을 true로 하여, 요청시 credential값들을 포함시켜 보낼 수 있다.
										req.onreadystatechange = handler;
										req.send();
								ㄴ 이에 대한 응답 헤더에 'Access-Control-Allow-Credentials': true 가 없을 경우, 브라우저는 이를 실패 취급한다.
								ㄴ preflight request의 경우 )
									ㄴ preflight request는 credential정보를 절대 포함하지 않고, preflight에 대한 응답에서
										"Access-Control-Allow-Credentials": true가 포함된 경우에, 원 요청에서 credential을 포함시킨다.
								ㄴ credential request인 경우, 응답 헤더의 조건 )
									ㄴ 요청이 crednetial request인 경우, 응답 헤더는 다음 조건을 충족해야 한다.
										ㄴ "Access-Control-Allow-Origin"이 와일드 카이이어선 안되고 특정 origin을 명시해야 한다.
										ㄴ "Access-Control-Allow-Headers"가 와일드 카드이어선 안되고 헤더 이름의 목록을 명시해야 한다.
										ㄴ "Access-Control-Allow-Methods"가 와일드 카드이어선 안되고 메소드 명을 명시해야 한다.
									ㄴ 조건을 충족하지 않을 경우, 브라우저는 해당 응답을 실패처리한다.
						ㄴ https://fetch.spec.whatwg.org/#cors-protocol 참고.

					ㄴ 서버가 어떤 origin이 cross origin을 통해 요청을 보낼 수 있을지 결정하게 해준다.
						ㄴ 즉, 알 수 없는 임의의 origin이 마음대로 서버로 요청을 보내어 공격하는 경우(POST, PUT 메소드 요청 등을 통해
							서버에 수정을 가하거나 등)를 어느 정도 방지해 준다.
				</pre>
				ㄴ 정책의 구현 )
					ㄴ 클라이언트 side) 이 정책들에 대한 구현은 브라우저 내부적으로 'XMLHttpRequest'를 통해 구현이 되어있으므로, 프로그래밍적으로 손댈 일은 드물다.
					ㄴ 서버 side ) 사용하는 서버쪽 언어나 프레임워크에 맞게 설정이 필요하다.
				ㄴ 보안적 risk )
					ㄴ 당연하게, 서버단의 access-control-allow-origin은 퍼블릭 api가 아닌 경우 와일드카드가 되어선 안된다.
				ㄴ 참고 )
					ㄴ https://developer.mozilla.org/ko/docs/Web/HTTP/CORS
					ㄴ https://www.netsparker.com/whitepaper-same-origin-policy/
					ㄴ https://www.acunetix.com/blog/web-security-zone/what-is-same-origin-policy/
					ㄴ https://www.codecademy.com/article/what-is-cors
					ㄴ https://www.packetlabs.net/cross-origin-resource-sharing-cors/
					ㄴ https://fetch.spec.whatwg.org/#http-cors-protocol


		</pre>

		인코딩<button>펼치기</button>
		<pre>
			ㅡ 문자셋이란? )
				ㄴ 문자를 이진 숫자로 표현하기위해 문자코드표로 약속한게 UTF-8, EUC-KR 같은 문자셋.
				ㄴ A는 65를 나타내는 11011010...어쩌구로 표현하고 이런식으로 약속.
			ㅡ 인코딩,디코딩이란? )
				ㄴ 이 문자표대로 문자를 이진수로 만드는게 인코딩, 그 이진수를 다시 문자로 만드는게 디코딩.
				ㄴ 문자를 비트화하는걸 인코딩, 이를 다시 문자로 바꾸는게 디코딩.
			ㅡ 문자의 깨짐 현상 )
				ㄴ 인코딩은 UTF-8로했는데 디코딩은 ISO-8859-1로 하면 문자가 깨짐.
				ㄴ 이게 웹상에서 데이터를 주고받는 경우에 자주발생하는 문제. 인코딩과 디코딩의 문자셋이 다름.
			ㅡ 웹에서의 문자 인코딩 )
				ㄴ jsp페이지 지시자에서 pageEncoding은 해당 파일을(jsp페이지 같은) 저장하고 꺼내올때 어떤 charset으로 인코딩하고 디코딩할건지를 정해주는 부분.
				ㄴ contentType에서 charset지정하는게 해당 리소스를 보낼때 인코딩할 문자셋을 지정하는 부분.
					ㄴ '이 리소스를 보낼때 해당 문자셋으로 인코딩했다'는걸 알려주기도 하는 부분.
				ㄴ html의 < meta>태그에서 지정하는것도 동일함. contentType에서지정하는게 우선순위가 있는듯함.
				ㄴ ??? 리소스를 받는쪽(가령 브라우저)에서 항상 이 contentType에 나와있는 문자셋으로 디코딩할 것 같고 그게 상식적일것같지만, 실제로 그런지는 모르겠음.
				ㄴ 브라우저에서 해당 jsp파일에서 요청을 보내게되면 contentType에 나와있는 문자셋으로 요청을 인코딩하여 보낸다고함.
				ㄴ 서버에서는 들어온 요청을 어떤 문자셋으로 디코딩할지 정할 수 있으며, GET방식 요청과 POST방식 요청에 대한 디코딩 방식 설정 방법이 다르다. POST는 아래와 같다.
					ㄴ 톰캣같은경우 디폴트로 iso-8859-1?로 디코딩한다함.
					ㄴ 이를 명시적으로 지정하는게 request.setCharacterSet() 메소드이다.
						ㄴ 근데 왜인진모르겟으나 스프링에서 했을땐 안먹힘.계속 iso-8859-1로 디코딩함.
					ㄴ 또다른방법은 웹어플의 web.xml에 < filter>를 선언해주는 것.
						ㄴ ex)
							< filter>
								< filter-name>encodingFilter< /filter-name>
								< filter-class>org.springframework.web.filter.CharacterEncodingFilter< /filter-class>
								< init-param>
									< param-name>encoding< /param-name>
									< param-value>UTF-8< /param-value>
								< /init-param>
							< /filter>
							< filter-mapping>
								< filter-name>encodingFilter< /filter-name>
								< url-pattern>/*< /url-pattern>
							< /filter-mapping>
							ㄴ < filter-mapping>부분도 꼭해주어야한다.
					ㄴ get방식의 요청파라미터 디코딩은 server.xml에서 < Connector>의 속성값으로 URIEncoding= " (*문자셋*) "을 부여하면된다.
						ㄴ get방식은 url에 요청파라미터를 붙이므로 이부분의 문자셋을 지정함으로서 설정가능하다.
			ㅡ 이클립스에서 window - preference - encoding검색 을통해 파일들에 대해 기본 문자셋을 지정할 수 있다.
			ㅡ 다음은 문자가 깨질때 어떻게 깨지게 되었는지 확인할 수 있는 간단한 코드이다.
				ㄴ 이후에 나오는게 원래 어떤 문자셋으로 인코딩 되었었는지를 나태내고 앞서나오는게 그 문자를 다른 어떤 문자셋으로 디코딩해서 문자가 깨지게 되었느지를 나타낸다.
					String kor_str = "ìëíì¸ì";	//깨진문자.

					String[] ary = {"euc-kr","utf-8","iso-8859-1","ksc5601","x-windows-949"};
					for( int i =0 ; i < ary.length; i++){
						for(int j=0; j < ary.length ; j++){
							if( i != j){
							System.out.println( ary[i]+"=>"+ ary[j]+ " \r\n ==> " +new String(kor_str.getBytes(ary[i]),ary[j]));
							}
						}
					}

		</pre>

		자료구조, 알고리즘<button>펼치기</button>
		<pre>
			ㅇ 자료구조란 ?
				ㅡ 데이터에 대한 처리를 효율적으로 하기위해서, 데이터들의 조직화, 구조화한 방식을 말함.
			* 자료구조와 알고리즘은 강한 연관성을 가진다.

			ㅇ 알고리즘
				ㅡ 책 '종만북'에선, 알고리즘 문제 해결 단계가 다음과 같다고 한다
					1. 문제를 이해한다
						ㄴ 급한 마음에 대충 보지 말고 문제를 정확하게 이해하는 것이 중요. 시작 단추이기 때문에 잘못 됐을 때 대가가 크다.
					2. 문제를 익숙한 용어로 재정의한다
						ㄴ ???
					3. 어떻게 해결할지 계획을 세운다
						ㄴ 어떻게 해결할지, 어떤 알고리즘, 자료구조를 사용할지 등을 결정.
					4. 계획을 검증한다
						ㄴ 3번에서 생각한 방법이 문제의 조건을 모두 만족하는지 증명하고 시간과 메모리를 고려.
					5. 프로그램으로 구현한다
						ㄴ 고안한 알고리즘을 정확히 구현.
					6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
						ㄴ 해당 문제엔 영향이 없지만 장기적으로 가장 중요하다함.
							풀때 당시의 사고 과정을 되돌하보며 피드백하거나 다시 풀어보는 것을 통해 배울 수 있는 것들이 많다.
							또는 타인의 코드를 보고 배울 수 있는 부분이 있다.
				ㅡ 문제 해결 방법 떠올리기
					ㄴ 해결할만한 문제의 경우 '직관'적으로 어떤 방식으로 풀어야 겠다는게 떠오른다.
					ㄴ 이게 아닌 어렵고 막막한 경우 다음의 질문들을 통해 방법을 떠올리는데 도움을 받을 수 있다
						ㄴ 비슷한 문제 푼적 있었는지
						ㄴ 단순한 방법으로 시작 가능한지
							ㄴ 이 질문을 통해, 단순하게 풀 수 있음에도 복잡하게 생각하여 막히는 경우를 해결할 수 있다.
							ㄴ 또는 해답 알고리즘이 근본적으로는 단순한 방법에 기반을 두고, 이 위에 최적화나 적절한 자료구조 선택 정도만
								필요로 하는 경우일 수 있다. (단순한 방법에서 점진적 개선하는 것)
							ㄴ 알고리즘 효율성의 기준선을 잡는데 도움을 줄 수 있다. 가장 단순한 방법이니 이를 효율성의 기준선으로 잡는 것.
						ㄴ ??? 문제를 푸는 과정을 수식화할 수 있을까?
						ㄴ 문제를 단순화시킬 수 있나?
							ㄴ 원래 문제를 좀 더 단순한 형태로 변경하여 풀어보고 이 단순화된 형태의 풀이 방식이 원래 문제 풀이법에 대한
								영감을 줄 수 있다.
							ㄴ 단순화를 어떤식으로 할지는 문제마다 잘 생각해 적용해 봐야 한다.
								조건을 일부 없애보거나 변수를 줄여보거나 다차원을 1차원으로 줄여보거나 표현을 단순화해보거나 등.
								좀 추상적이긴 하다.
						ㄴ 그림을 그려볼 수 있나
							ㄴ 문제와 관련된 내용을 그림으로 그려보아 직관을 얻을 수 있는 경우가 있다.
						ㄴ 수식으로 표현할 수 있나
							ㄴ 문제와 관련된 내용을 수학적 수식으로 표현해보아 직관을 얻을 수도 있다.
						ㄴ ??? 문제를 분해할 수 있나?
						ㄴ 뒤에서부터 생각해서 문제를 풀 수 있나?
							ㄴ ~~~
						ㄴ 순서를 강제할 수 있나?
							ㄴ ~~~
						ㄴ 특정 형태의 답만을 고려할 수 있나?
							ㄴ ~~~
				ㅡ 알고리즘 문제 풀이시, 코딩 팁
					ㄴ 코드를 간결하게
					ㄴ 중복되는 코드는 모듈화하여 재사용
					ㄴ 표준 라이브러리 사용
					ㄴ 명료한 변수명
					ㄴ 자료를 일관된 형태로 사용. ex ) 날짜는 iso로, 문자열은 utf-8 인코딩으로 등.
				ㅡ 알고리즘 문제 풀이시, 자주하는 실수
					ㄴ 산술 오버플로우. 변수의 표현 범위를 벗어나는 것.
					ㄴ 배열 out of index
					ㄴ 일관되지 않은 범위 표현 방식.
						ㄴ 가령 substring( 2, 6 ) 라치면, 잘려나오는 문자열의 인덱스는
							2 < i < 6 인지,
							2 <= i < 6 인지,
							2 <= i <= 6 인지 등.
						ㄴ 프로그램 내에서 이를 일관되게 표현하여야 헷갈리지 않아 buggy하지 않다.
						ㄴ 선택에 팁을 주자면..
							첫번째 방식은 처음과 마지막 idx를 포함시키려면 idx범위를 벗어나는 가상의 idx를 범위값으로 사용해야한다는 단점.
							ex ) len(arr)=10인 arr의 idx 0~9까지를 표현하려면, -1 < idx < 10 으로 표현해야함.
							세번째 방식은 공집합 표현이 어렵다는 단점.
							ex ) len(arr)=10인 arr에 대해 범위로 공집합을 표현이 어렵. 0 <= idx <= 0 이라 쳐도 0이 포함되므로.
							두번째 방식 추천?
					ㄴ off-by-one 오류?
						ㄴ 계산에서 하나를 빼먹거나 하나를 잘못 추가하는 경우.
							ex ) arr[i] ~ arr[j] 사이의 평균값 구한다칠때, 몇으로 나누나? j-i 가 아닌 j-i+1
								길이 100미터인 담장에 10미터 간격으로 기둥 박을 때 필요한 기둥 개수? 10개 아닌 11개.
					ㄴ 상수 오타
						ㄴ 문자열 잘못 쓰거나, 사용되는 상수 숫자를 잘못 입력하거나.
					ㄴ 스택 오버플로우
					ㄴ 다차원 배열 인덱스 실수
					ㄴ ??? 잘못된 비교 함수 작성
					ㄴ 최대, 최소 범위에서의 예외 케이스 놓침.
					ㄴ 연산자 우선순위 실수.
					ㄴ 느린 입출력 방식 사용.
					ㄴ 변수 초기화 안함.
					ㄴ ~~~

				ㅡ 수행 시간 측정
					ㄴ 같은 알고리즘이어도 입력값에 따라 환경에 따라 수행시간이 다름을 고려해야함.
						ㄴ 시간복잡도 O()는 최고차항을 제외한 나머지를 모두 제거한 것이므로 실제 수행시간은 제거된 항들도 모두 고려해야함
						ㄴ 반복문 내부가 복잡한 경우, 수행시간이 생각보다 늘어남
						ㄴ 메모리 사용 패턴???
						ㄴ 언어와 컴파일러 차이
						ㄴ 구형 컴퓨터
					ㄴ 대략 좀 보수적으로, O() 시간복잡도가 1억을 넘으면 실패한다고 본다고함.

				ㅡ P, NP, NP-완비 ???
					ㄴ ~~~

				ㅡ 정당성 증명 )
					ㄴ ~~~

				ㅡ 패러다임 )
					ㄴ 무식하게 풀기 )
						ㄴ 경우를 일일이 나열하면서 답을 찾는 방식. '완전탐색' 이라고도 불림.
						ㄴ 가장 단순한 해결책으로 컴퓨터의 속도가 빠르다는 것으로 문제를 푸는 것.
					ㄴ 재귀 호출 )
						ㄴ
					ㄴ 분할 정복 )
						ㄴ



			ㅇ 복잡도
				ㅡ 시간복잡도 : 프로그램이 실행될때 필요한 실행문의 실행횟수.
					ㄴ 실행문마다 실행시간이 다르므로 정확하게 예측하기가 어려움. 그래서 나온게 대락적인 수행시간을 예측하는 '점근 표기법'
					ㄴ 점근 표기법 )
						ㄴ 실행문의 수행시간을 정확하게 예측하는것이 아니라 대략적인 예측만 하는 방법.
						ㄴ '빅오', '오메가', '세타' 방식이 잇다.
						ㄴ 빅오 표기법 ) 실행시간의 최악의 경우. 즉 가장 오래걸리는 경우를 측정하는 방법. ex) O(n), O(logn)
						ㄴ 오메가 ) 실행시간이 가장 적게 걸리는 경우를 측정. ex) Ω(n)
						ㄴ 세타 ) 실행시간이 어떤 범위안에 있는지를 측정. ex) Θ(n)
					ㄴ 빅오 표기법 )
						ㄴ 가장 많이 쓰이는 점근표기법.
						ㄴ 대표적 빅오 함수와 이들의 실행시간 차이)
							ㄴ O(1) > O(log n) > O(n) > O(n^2) > O(n^3) > O(2^n)
				ㅡ 공간복잡도 : 필요한 공간의 크기.
			ㅇ 성능 평가
				ㅡ 성능 분석 : 사전예측. 시간복잡도와 공간복잡도가 있다.
				ㅡ 성능 측정 : 사후검사.
			ㅇ ADT, 추상 자료형
				ㅡ 일종의 수학적, 논리적 모델이다.
				ㅡ 이 자료형이 어떻게 동작하는지, 의미적인, 기능적인 측면에서 정의된다. 구체적인 구현방법이 아니라.
				ㅡ 스텍, 큐, 트리, 등등을 말한다.
				ㅡ data structure와 비교된다.
					ㄴ data structure은 자료구조란 의미니까 일반적으론 스텍, 큐 등의 ADT까지 다 포함해서 사용하고있기는 한데
					ㄴ 배열, 연결리스트, 객체 등과 같이 실제로 데이터를 저장하는 구현체를 말하고
					ㄴ 이것들을 기반으로 ADT가 구현된다.
			ㅇ 스택
				ㅡ 한쪽 끝에서 삽입과 삭제가 일어나는 리스트.
			ㅇ 큐
				ㅡ 한쪽끝에서 삽입, 다른쪽 끝에서 삭제가 일어나는 리스트.
				ㅡ 구현 )
					ㄴ 선형인 '단순큐'는 끝에 도달하면 더이상 사용이 안되므로 '원형큐'를 사용한다.
					ㄴ 배열로 구현할경우, 배열의 최대 인덱스에 도달하면 다시 처음인덱스로 설정해줌으로서 원형큐구현.
			ㅇ 연결 리스트, 배열<button>more</button>
			<pre>
				ㅡ 연결리스트
					ㅡ 포인터를 사용하여 리스트를 표현한것.
					ㅡ 노드가 데이터와 다음 노드를 가리키는 포인터로 이루어져있다.
					ㅡ 시간복잡도 )
						ㄴ 삽입과 삭제가 포인터의 값만 변경해주면 되므로 상수시간복잡도가 걸린다.
						ㄴ 임의 노드 접근시 배열과 같이 인덱스가 없고 순차접근해야 하므로 O(n)을 가진다.
							ㄴ 따라서 맨 끝 노드 뒤에 노드 삽입 등의 경우, 맨 끝 노드 접근에 O(n), 삽입에 O(1)이 걸리는셈.
					ㅡ 구현 )
						ㄴ 노드를 나타내는 클래스가 있고, 첫번째 노드클래스를 가리키는 포인터를 가지는 클래스를 만들면 이게 연결리스트 클래스가 된다.
							ㄴ ex)
								class Node{
									char data;
									Node *nextNode;
								}
								class LinkedList{
									Node *firstNode;
									~~~	=>연결리스트 조작 메소드들
								}
								ㄴ 마지막을 가리키는 포인터를 추가하여 삽입등의 리스트 조작이 용이하게한다.
				ㅡ 배열
					ㄴ ~~~
					ㄴ 시간복잡도 )
						ㄴ 삽입,삭제시, 삽입,삭제하려는 위치가 맨 끝이고 공간이 남아있다면 O(1)
							맨 끝이 아니라면 원소를 한칸씩 움직여야하므로 O(n)
						ㄴ 임의 노드 접근은 인덱스가 있으므로 O(1)
				ㅡ 배열 vs 연결리스트 )
					ㄴ 시간복잡도로부터 성능상
						삽입, 삭제가 빈번하면 연결리스트, 원소 접근이 빈번하면 배열이 유리함을 알 수 있다.
			</pre>

			ㅇ 그래프 graph<button>펼치기</button>
			<pre>
				ㅡ 일반적인 그래프 <button>펼치기</button>
				<pre>
					ㅡ 개요 )
						ㄴ 한 노드와 이 노드와 연결된 간선으로 이루어진 자료구조.
						ㄴ 연결돼있는 객체간의 관계를 표현 할수있는 자료구조이다.
						ㄴ 정점(vertex)와 간선(edge)들의 유한집합.
					ㅡ 무방향 그래프, 방향 그래프
						ㄴ 간선이 방향을 가지고있는걸 방향그래프, 없는걸 무방향 그래프라고 한다.
						ㄴ 표현 )
							ㄴ 무방향 그래프의 간선 : ex) (0,1), (1,2)		=>정점 0과1을 잇는 간선, 정점 1과2를 잇는 간선
							ㄴ 방향 그래프의 간선 : ex) <0,1>, <1,0>	=>정점 0에서1로의 방향인 간선, 정점 1에서 0으로의 방향인 간선.
					ㅡ 일반적으로 그래프는 자기자신과연결된 간선이나 두 정점 사이의 여러개의 중복된 간선의 경우는 다루지 않는다.
					ㅡ n개의 정점을 갖는 무방향 그래프에서 간선의 최대개수 : n(n-1)/2
					ㅡ 완전그래프 : 최대개수의 간선을 가지는 그래프.
					ㅡ 인접과 부속 )
						ㄴ 간선 (u,v)가 있으면, u와 v는 '인접한다(adjacent)'라고 하며, 간선 (u,v)는 정점 u,v에 '부속된다(incidnet)'고 한다.
						ㄴ 방향그래프의 경우, < u,v>일때, u는 v에 인접한다고하고 v는 u로부터 인접한다고 한다. 부속된다는 동일.
					ㅡ 부분그래프 )
						ㄴ 어떤 그래프의 간선과 정점들 중 일부로 이루어진 그래프.
							ㄴ 부분 그래프의 정점과 간선이 원래 그래프 안에 포함되기만 하면 된다.
						ㄴ <img src="image/부분그래프.png" height="300px" width="auto"/>
					ㅡ 경로 Path )
						ㄴ 그래프상에 정점들을 잇는 간선들이 쭉연결되어있을때 이 간선들을 하나의 '경로'라고 한다.
						ㄴ 종류 )
							ㄴ 단순 경로 : 처음과 마지막 정점을 제외한 정점들이 서로 다른 경로.
								(간단히, 처음과 마지막을 제외하고는 한번갔던 정점을 다시 안가는 경로)
							ㄴ 싸이클 : '단순 경로' 중 처음과 마지막이 같은 경로
					ㅡ 연결 그래프 )
						ㄴ '무방향 그래프'에서 정점 u로부터 v까지의 '경로'가 있으면, u와 v는 '연결되었다'고 한다.
						ㄴ 그래프가 임의의 두 정점 사이에 '경로'가 존재하면 이 그래프를 '연결그래프'라 한다.
							(간단히 말해, 모든 정점이 연결되어있는 그래프)
					ㅡ 연결 요소 : '무방향 그래프'에서 최대로 연결된 '부분 그래프'
					ㅡ 강력 연결 : '방향 그래프'에서 두 정점 u,v에 대해 < u,v>, < v,u> 경로가 모두 있으면 u와 v는 '강력 연결되었다'고 한다.
					ㅡ 강력 연결 그래프 : '방향 그래프'에서 임의의 두 정점이 '강력연결'되어있다면 이 그래프를 '강력 연결 그래프'라 한다.
					ㅡ 강력 연결 요소 : '방향그래프'에서 최대로 '강력 연결된' '부분 그래프'
					ㅡ 정점의 차수 )
						ㄴ 정점에 '부속'한 간선들의 수
						ㄴ '방향 그래프'에서는 '진입차수(indegree)'와 '진출 차수(outdegree)'로 부름.
						ㄴ 총 간선의 수를 e라 할때, '모든 정점의 차수의 합'은 2*e이다.
					ㅡ 그래프 표현법 )
						ㄴ 인접행렬 )
							ㄴ 그래프를 n x n의 이차원 배열로 나타내는 방식.
							ㄴ <img src="image/자료구조_그래프_인접행렬.png" height="326"/>
								ㄴ 행과 열 각각은 정점들을 나타내며, 두 정점 사이에 간선이 있으면 배열의 값을 1로 표현, 없으면 0으로 표현하는 식.
							ㄴ 무방향 그래프는 대각선을 기준으로 대칭을 띄게됨.
							ㄴ 방향 그래프에선 arr[i][j] 라 하면, i가 출발정점, j가 도착정점을 나타낸다.
							ㄴ 무방향 그래프에서, 한 행 또는 열의 값을 모두 더한건 그 행 또는 열에 해당하는 정점의 차수를 의미한다.
							ㄴ 방향 그래프에선 한 행의 값을 모두 더한건 그 행에 해당하는 정점의 진출차수, 한 열의 값을 모두 더한건 그 열에 해당하는 정점의 진입차수를
								의미한다.
						ㄴ 인접 리스트 )
							ㄴ 연결 리스트를 이용해 표현하는 방식.
							<img src="image/자료구조_그래프_인접리스트.jpeg" height="300px" width="auto"/>
								ㄴ 정점이 n개면 n크기의 리스트 배열을 만들고 각 정점에 연결된 정점들을 리스트에 추가하는 식.
								ㄴ 한 정점에 연결된 정점들을 리스트에 추가할때 순서는 상관 없다.
								ㄴ 인접행렬과 달리 간선이 없는 경우에 대해 공간을 낭비하지 않음.
							ㄴ 무방향 그래프일 경우 추가된 노드의 개수는 2*e개이다. (e는 간선의 개수)
						ㄴ 비교 )
							ㄴ 인접행렬을 사용하게되면 행렬 내의 n^2-n개의 모든 항들을 조사해야하므로 O(n^2)이다.
							ㄴ 인접리스트의 경우 n개의 헤드노드와 2e개의 리스트노드를 조사하므로 O(n+e)이다. (e는 간선 수)
					ㅡ  가중치 그래프
						ㄴ 간선에 '비용이나 가중치'를 부여한 '그래프'
						ㄴ 표현 방법 )
							ㄴ 인접행렬 : 배열의 값에 1대신 '가중치' 값을 사용하므로서 표현.
							ㄴ 인접 리스트 : 각 노드에 '가중치'를 나타내는 프로퍼티 추가.
					ㅡ 그래프의 탐색 )<button>펼치기</button>
					<pre>
						ㄴ '연결 그래프'에 대해 모든 정점을 조회하며 탐색하는 방법으로, 대표적으로 DFS, BFS가 있다.
						ㄴ 깊이 우선 탐색, DFS, Depth first search )
							ㄴ 개요 )
								ㄴ 인접한 정점 중 방문이 안된 정점으로 계속 방문하며 깊게 들어감. 모든 인접한 정점이 방문되어 있으면 되돌아감.
									이를 반복하다가 출발정점으로 되돌아가게되면 모두 방문한것.
							ㄴ 구현 )
								ㄴ 정점이 방문되었는지 아닌지를 확인해주는데 쓰이는 방문확인배열을 하나 두고,
								ㄴ DFS함수를 한 정점을 인자로 넘겨 호출하면, 그 정점을 방문확인배열에서 방문함으로 변경하고, 그 정점의 인접한 정점들에 대해
									방문이 안되어있으면 재귀함수(DFS함수)를 호출.
								ㄴ 그러면 인접정점들중 방문 안된 정점으로 가서 거기서 또 방문안된 정점으로 들어가는 식으로 깊게들어가며 탐색을 함. 방문안된
									인접정점이  없으면 그 정점에 대한 DFS재귀함수가 종료되며 다음 인접정점중 방문안된 정점으로 DFS해서 들어감.
									이렇게 계속하다가 처음 시작한 정점에 대한 DFS함수가 종료되면 깊이우선탐색이 끝난것.
								ㄴ ex)
									void Graph::DFS(){
										visited = new bool[n];

										for(int i=0; i< n; i++){
											DFS(0);
											delete[] visited;
										}
									}
									void Graph::DFS(const int v){
										visited[v]=true;
										for(v에 인접한 각 정점w에 대해){
											if(!visited[w]) DFS(w);
										}
									}
							ㄴ 시간복잡도 )
								ㄴ 인접리스트 사용시 : ('정점'이 아닌) '리스트 노드'를 한번씩 조사해야하고, 리스트 노드의 수는 2*e이므로 O(e)
								ㄴ 인접행렬 사용시 : 한 정점에 대한 인접정점들 조사를 위해서 O(n)이 필요하므로 전체 정점에 대해 조사하면 O(n^2)가 된다.
						ㄴ 너비 우선 탐색, BFS, Breadth First Search
							ㄴ 정점하나 방문하고 그 정점과 인접한 정점들 중 방문이 안된 것 모두 방문. 그리고 모두 큐에 삽입. 그 다음 큐에서 하나 삭제한 후
								삭제된 정점에 대해 같은 과정을 반복. 방문 안된 인접정점이 없으면 그냥 삭제. 큐가 비게되면 탐색 종료.
							ㄴ 구현 )
								ㄴ 정점이 방문되었는지를 확인하는 방문확인배열을 만들고
								ㄴ ~~~
							ㄴ 시간복잡도 )
								ㄴ DFS와 동일.
					</pre>
					ㅡ 탐색을 이용한 연결 요소 찾기)
						ㄴ DFS나 BFS는 연결된 정점들을 따라서 탐색하므로 이를 사용하여 '연결요소'들을 찾는것.
						ㄴ 연결요소 찾는 알고리즘 )
							ㄴ 그래프의 모든 정점에 반복, 그 정점이 방문이 안되었으면 DFS나 BFS를 호출.
							ㄴ 시간복잡도 )
								ㄴ 인접 리스트 사용시 : 탐색에서 모든 노드를 한번씩 방문하므로 O(e),
									거기다가 모든 정점에 대해 반복하므로 O(n)을 더하여 O(n+e)
								ㄴ 인접 행렬 사용시 : O(n^2)
					ㅡ 신장 트리 )<button>펼치기</button>
					<pre>
						ㄴ 개요)
							ㄴ '연결 그래프' 중에서 '모든 정점을 포함'하면서, '트리'인 '부분 그래프'
							<img src="image/자료구조_그래프_신장트리.png" height="300px" width="auto"/>
							ㄴ DFS또는  BFS로 탐색하는 '과정 중에서', 정점v에서 인접하며 방문되지 않은 정점w가 있을때,
                                간선(v,w)의 집합이 신장트리의 경로이다.
								ㄴ 따라서 DFS를 이용한 신장트리와 BFS를 이용한 신장트리가 따로잇다.
							ㄴ 사용 )
								ㄴ 최단 경로 탐색, 최소 가중치 경로 탐색, 싸이클 없는 경로 탐색 등.
						ㄴ 최소비용 신장 트리, MST, minimum cost spanning tree )<button>more</button>
						<pre>
							ㄴ 개요 )
								ㄴ '가중치 무방향 그래프'에서 '신장트리의 비용'은 신장 트리에 포함된 '간선들의 비용의 총합'이며,
                                    '최소비용 신장 트리'는
									최소의 '신장트리의 비용'을 가지는 신장트리이다.
								ㄴ 그래프 내의 간선들만 사용해야 한다.
								ㄴ n-1개의 간선만을 포함해야 한다.
								ㄴ '사이클'을 포함하지 않는다. (트리이기때문)
							ㄴ MST를 구하는 알고리즘 )
								ㄴ Kruskal, Prim, Sollin 알고리즘이 있다.
								ㄴ 증명은 패쓰. 똑똑하신분들이 귀납적으로 증명하여 이 알고리즘을 사용하면 MST가 나온다고 알려주심.
								ㄴ Kruskal 알고리즘 (크루스칼)
									ㄴ 방법 )
										ㄴ 그래프의 모든 간선들 중에서 가장 비용이 작은 간선순서로 선택. 그 선택된 간선이 이미 저장된 간선들과
											'사이클'을 형성하지 않으면 저장, 형성하면 버리고 다음 간선 선택.
										ㄴ 위 과정을 더이상 선택할 간선이 없어질때까지나, 저장된 간선의 수가 n-1개이면 break.(n은 노드수)
										ㄴ MST완성.
									ㄴ 위키에 나온 수도 코드 )
										algorithm Kruskal(G) is
											F:= ∅
											for each v ∈ G.V do  // 모든 정점에 대해, 각 정점을 set으로서 만듦.
												MAKE-SET(v)
											for each (u, v) in G.E ordered by weight(u, v), increasing do  // 모든 간선에 대해,
												// 간선 양 끝 정점이 속한 set을 찾고, 이들이 같은 set임을 확인(싸이클을 형성하는지 확인하는 것)
												if FIND-SET(u) ≠ FIND-SET(v) then
													// 같은 set에 속하지 않다면 두 set을 합집합. (해당 간선을 MST에 포함시키는 것)
													F:= F ∪ {(u, v)} ∪ {(v, u)}
													UNION(FIND-SET(u), FIND-SET(v))
											return F
									ㄴ ??? 시간 복잡도 )
										ㄴ 간선 수 E, 정점 수 V라 할 때.
										ㄴ 일단 간선들을 가중치에 따라 정렬. O(E*logE)
										ㄴ 정점들을 각각의 set으로 만듦. O(V)
										ㄴ ??? 모든 간선들에 대해 set 탐색 연산 및 합집합 연산.
										ㄴ 결과적으로, O(E*logE) 또는 O(E*logV)

								ㄴ Prim 알고리즘 (프림) )
									ㄴ 방법 )
										ㄴ 크루스칼과 비교하면, 프림알고리즘은 처음 선택할때부터 '사이클'을 형성하지 않는 것들만 선택하는 방식.
										ㄴ 그래프의 간선들중에서 이미 저장된 간선들과 '사이클'을 형성하지 않으면서, 가장 비용이 작은 간선을 저장.
											ㄴ 저장된 간선들의 정점 집합을 하나 두어서, 어떤 간선
										ㄴ 위 과정을 n-1개의 간선이 저장될 때까지 반복.
									ㄴ 시간 복잡도 )
										ㄴ 그래프에 사용되는 데이터 구조와 간선 가중치 정렬에 사용되는 데이터 구조에 따라 달라진다.
										ㄴ 위키에 따르면..
											ㄴ 인접행렬, 단순 선형 탐색 사용시, O(v^2)
											ㄴ 인접리스트, binary heap 사용시, O(E*logV)
											ㄴ 인접리스트, 피보나치 힙 사용시, O(E + V*logV)
										ㄴ ???
						</pre>
					</pre>

					ㅡ 최단 경로 )<button>펼치기</button>
					<pre>
						ㄴ 가중치 그래프, 방향 그래프인 경우에 한 정점에서 다른 정점으로 가는 경로의 가중치가 최소로 되는 경로를 말함.
						ㄴ 두가지 유형이 있다.
							ㄴ 단일 출발점으로부터 모든 종점까지의 최단경로를 구하는 것. (단, 간선의 길이가 '양수'이어야 한다)
							ㄴ 모든 정점쌍의 최단경로를 다 구하는 것.
								ㄴ 첫번째 유형구하는 방식으로도 구할 수 있으나 다른 더 효율적인 방법이 있다.
						ㄴ 단일 출발점, 모든 종점 )
							ㄴ Dijkstra 알고리즘 )
								ㄴ 개요 )
									ㄴ '방향 그래프'이면서, '가중치'가 양수인 '가중치 그래프'에서 단일 출발정점으로부터 모든 종점까지의
										최단경로 비용을 구하는 알고리즘.
								ㄴ 구현 )
									ㄴ1. '방향 그래프'를 인접행렬로 나타낸다. 경로가 없는 경우는 '무한대'를 의미하는 충분히 큰값으로 나타낸다.
										자기자신과의 경로부분은 0으로 나타낸다.
									ㄴ2. 출발정점v로부터 모든 정점 사이의 최단거리비용을 나타내는 배열 dist[]를 만든다.
										dist[w]는 v로부터 w로 가는 최단거리 비용을 나타낸다.
									ㄴ3. 출발정점v로부터의 최단경로 비용을 구한 정점의 집합 S를 만든다.
										S에 속하는 정점은 v로부터 해당정점까지의 최단거리 비용을 구한 정점이다.
									ㄴ4. 맨 처음 dist[]의 값은 출발정점v에서 각 정점과 연결된 경로들의 가중치이다.
									ㄴ5. 그다음 dist[]에서 가장 작은 값을 선택하고 그에 해당하는 정점(u라 가정)을 S에 넣는다.
										(v와 u사이의 최단 경로 비용을 확정지음)
									ㄴ6. dist[]의 나머지 값들을 갱신한다.
										ㄴ S에 속하지 않은 정점(x라 가정)들에 대해, '기존 dist[x]값'과 'v->u 가중치 + u->x 가중치'를
											비교하여 더 작은 값으로 dist[x]를 갱신.
									ㄴ7. S에 모든 정점이 포함될 때까지 5,6번을 반복.
								ㄴ 최단 경로 구하기 )
									ㄴ path[]을 하나 만들어서, 위 6단계에서 dist[]를 갱신시마다, dist[x]에 u값을 넣는다.
									ㄴ path[]를 역추적하여 정점a->b로 가는 최단경로를 구한다.
										ㄴ ex ) 정점 0 -> 1 의 최단경로
												path[] = 0, 4, 0, 0, 3, 0 이라 하면,
												우선 최단경로에 1 추가,
												path[1] = 4, 최단경로에 4 추가,
												path[4] = 3, 최단경로에 3 추가,
												path[3] = 0  최단경로에 0 추가, 최단경로에 추가된 값들은 1 4 3 0. 이를 역순을 하면
																최단경로가 된다. 0 -> 3 -> 4 -> 1
								ㄴ 시간복잡도 )
									ㄴ 위 과정에서,
										5,6번 반복이 n-1번 반복,
										5번에서 dist[]에서 가장 작은 값 탐색이 최대 n + 6번에서 정점들에 대해 가중치 비교 및 갱신이 최대 n
										따라서 O( (n-1) * (n + n) ) = O(n^2)

						ㄴ 모든 쌍들의 최단경로 )
							ㄴ 일단 방법 2가지 존재
								ㄴ Dijkstra를 모든 정점에 대해 적용(n번 적용)
								ㄴ Ford 알고리즘
							ㄴ 둘다 O(n^3)
								단, 실제론 Ford가 훨씬 빠르다함.
							ㄴ Ford 알고리즘 )
								ㄴ 기본 원리
									ㄴ 그래프상에서 임의의 i, j정점에 대해,
										i, j 사이의 최단경로가 있다하면, 그 최단 경로 위에 있는 정점 k에 대해,
										최단경로의 i에서 k까지의 경로와 k에서 j까지의 경로도 마찬가지로 최단경로이어야 한다는 것.
										아니라면 i,j최단경로는 최단경로가 아닐 것이기 때문에.
								ㄴ ??? ~~~
					</pre>

				</pre>

				ㅡ 트리<button>펼치기</button>
				<pre>
					<img src="image/자료구조_트리.jpeg" height="300px" width="auto"/>
					ㅡ 개요 )
						ㄴ '그래프'의 일종.
						ㄴ 정의, 특징 )
							ㄴ 그래프에서, 임의의 두 정점이 딱 하나의 간선에 의해서만 연결된 그래프.
							ㄴ 즉, 연결 그래프이면서 싸이클을 형성하지 않는 그래프
							ㄴ 배열, 리스트, 스택 등의 선형 자료구조가 아닌 '비선형' 자료구조이다.
							ㄴ '싸이클'이 있어선 안된다.
							ㄴ 부모 노드가 2개 이상이어선 안된다. 즉, 여러노드가 한노드를 가리킬 수 없다.
							ㄴ 노드들이 모두연결되어 있어야 한다.
						ㄴ 보통 계층적인 관계의 자료를 표현할 때 많이 쓰인다.
					ㅡ 용어 )
						ㄴ 서브트리 : 트리 내부에 있는 트리. 그림에서 E,K,L로 이루어진 트리는 전체 트리의 서브트리라고 할 수 있다.
						ㄴ 노드의 차수 : 어떤 노드의 서브트리의 수. 그림에서 A의 차수는 A바로아래로 서브트리가 B,C,D로 세개있으므로 3이된다.
						ㄴ 단말노드, leaf : 차수가 0인 노드. 맨끝에있는 노드. 그림에서 K,L,F,G..등
						ㄴ 비단말노드 : 단말노드가 아닌것들
						ㄴ 부모,자식,조상,자손
						ㄴ 레벨 : root노드의 레벨이 1, 그아래로 갈수록 레벨이 1씩 높아진다.
						ㄴ 트리의 깊이, 높이 : 트리에 속한 노드들 중 가장 높은 레벨.

					ㅡ 이진 트리 )
						ㄴ 모든 노드의 차수가 2이하인 트리.
						ㄴ 종류 )
							ㄴ 편향 트리 : 모든 노드들이 왼쪽자식노드로 이루어져있거나 오른쪽자식노드로 이루어진 트리.
									왼쪽 또는 오른쪽으로 일렬로 되어있는 형태.
							ㄴ 완전이진트리 : 마지막 레벨을 제외하고는 모든 레벨에서 최대노드개수를 가져야하며 마지막 레벨은 왼쪽부터 차곡차곡 차있어야함.
							ㄴ 포화이진트리 : 모든 레벨이 최대노드개수를 가지는 트리.
						ㄴ 성질 )
							ㄴ 레벨당 최대 노드 개수 : 레벨이 i일때, 2^(i-1)개  (i>=1)
							ㄴ 깊이가 k인 이진트리의 총 최대 노드 개수 : 2^k - 1 (k>=1)
								ㄴ n레벨에서의 최대노드개수를 1레벨부터 k레벨까지 더한것. (시그마)
							ㄴ 모든 노드의 개수가 n, 차수가 0인 노드의 개수가 n0, 차수가 1인게 n1, 2인게 n2라고할때,
								n = n0 + n1 + n2
								n = B + 1 (B는 총 가지의 수. 루트노드를 제외한 모든 노드는 가지를 하나씩 가지므로)
								B = n1 + 2*n2
								위를 종합해, n0 = n2 + 1
							ㄴ 완전 이진트리의 높이 : 'log2 (n+1)'의 소수점 올림  (2는 밑)
						ㄴ 완전이진트리 <button>펼치기</button>
						<pre>
							ㄴ 표현 )
								ㄴ 배열 표현 )
									ㄴ n개의 노드를 가지는 트리에 대하여, 부모의 index가 i이면 왼쪽 자식은 2*i, 오른쪽 자식은 2*i+1
									ㄴ i=1은 루트노드, 0은 사용안함
									ㄴ 2*n, 2*n+1은 n보다 작아야함.
								ㄴ 링크 표현 )
									ㄴ 객체로 만들며, 내부에 데이터값과 왼쪽자식노드, 오른쪽 자식노드를 가리키는 포인터를 프로퍼티로 가진다.
							ㄴ 순회 )
								ㄴ 트리에 있는 모든 노드를 한번씩 방문하는 방법을 말함.
								ㄴ 중위, 전위, 후위 순회가 있다.
									ㄴ 전위 순회 : root, 왼쪽서브트리, 오른쪽 서브트리 순서로 순회
									ㄴ 중위 순회 : 왼쪽 서브트리, root, 오른쪽 서브트리 순서로 순회
									ㄴ 후위 순회 : 왼쪽 서브트리, 오른쪽 서브트리, root순서로 순회.
								ㄴ 구현 )
									ㄴ 재귀함수 이용 )
										ㄴ 순회함수를 재귀함수로 사용하여 구현
										ㄴ ex) 중위순회 함수 예
											void inorder(Node *currentNode){
												if(currentNode){
													inorder(currentNode->leftChild);	=>중위순회는 왼쪽 서브트리,root,오른쪽서브트리 순서이므로 왼쪽
													cout<< currentNode->data;			서브트리에 대해서 함수를 재귀적으로 호출
													inorder(currentNode->rightChild);
												}
											}
									ㄴ 스택 이용 )
										ㄴ
										ㄴ 복잡도 )
											ㄴ 시간복잡도 : 모든 노드에 대해 삽입,삭제가 한번씩 일어나므로 노드수 n이라하면 O(2n)이니까 시간복잡도는 O(n).
											ㄴ 공간복잡도 : 스텍의 크기와 일치하며, 노드수가n일때 최악의 경우로 편향트리일경우 공간복잡도는 O(n)
							ㅇ 히프, heap<button>펼치기</button>
							<pre>
								* 우선순위 큐 : 삽입은 일반적인 큐와 같으나 삭제시 가장 우선순위가 높은 것이 먼저 삭제되는 큐.
								ㅡ 최대,최소 히프 )
									ㄴ 알아두어야할것 )
										ㄴ 최대 트리 : 각 노드의 키값이 그 자식의 키값보다 작지 않은 트리. 부모쪽이 더큰거.
										ㄴ 최소 트리 : 그 반대
										ㄴ 최대 히프 : 최대 트리이면서 완전이진트리.
										ㄴ 최소 히프 : 그 반대.
										ㄴ 최대,최소 히프는 최대,최소 우선순위 큐를 구현하는데 쓰인다.
								ㅡ 개요 )
									ㄴ 최대값과 최소값을 빠르게 찾기 위해 고안된 완전이진트리 형태의 자료구조.
									ㄴ 부모자식간에만 대소가 적용되고 형제간에는 적용되지 않는다.
								ㅡ 구현 )
									ㄴ 완전이진트리이므로 배열을 사용.
									ㄴ 여기선 우선 최대 히프를 구현한다.
									ㄴ 삽입 )
										ㄴ 개념 : 이진트리의 맨끝에 삽입 노드를 추가해주고, 부모 노드와 값을 비교하여 부모의 값이 더 클때까지 부모노드와 위치를 바꿔가며
												 계속 올라간다. 부모노드의 값이 더 크거나, 루트노드에 도달하면 그곳이 삽입된 노드의 위치가된다.
										ㄴ 시간복잡도 : 최악의 경우 트리의 높이만큼 반복하므로, 이진트리의 높이인 log(2) (n+1) (2는 밑)을 사용하여 O(log(2) n) 이다.
									ㄴ 삭제 )
										ㄴ 루트노드위치에 항상 가장 큰 값을가지느 노드가 있으므로 이를 삭제해주고 최대 히프를 유지해주는 로직이 들어간다.
										ㄴ 루트 노드를 삭제하고 맨 마지막 노드를 루트노드위치로 올리고 두 자식노드와 비교해서 자식노드보다 값이 클때까지 위치를 바꿔주며 내려보낸다.
										ㄴ 시간복잡도 : 삽입과 마찬가지.
							</pre>
						</pre>
						ㄴ 이진 탐색 트리 <button>펼치기</button>
						<pre>
							ㄴ 개요 )
								ㄴ '이진 탐색'과 '이진트리'를 결합한 자료구조
								ㄴ 이진탐색의 효율적인 탐색과 빈번한 입력과 삭제에 용이함.
								* 이진 탐색
									ㅡ 한번 서치할때마다 탐색범위가 절반으로 줄어드는 탐색기법.
									ㅡ 정렬된 데이터를 대상으로한다.
									ㅡ 중간값을 확인하여 찾는값인지 확인하고 아닐경우 찾는값이 중간값보다 작으면 중간값의 왼쪽을 탐색하고 반대면 오른쪽을 탐색하는 기법.
							ㄴ 정의 )
								ㄴ 모든 원소는 키를 가지며, 동일한 키가 없다.
								ㄴ 키값의 크기 : (*왼쪽 서브트리의 노드들의 키값*) < (*루트의 키값*) < (*오른쪽 서브트리의 노드들의 키값*)
								ㄴ 왼쪽, 오른쪽 서브트리도 이진 탐색 트리이다.
							ㄴ 임의의 한 노드를 삽입, 삭제, 탐색하는데 용이하다.
							ㄴ 이진탐색트리의 높이 )
								ㄴ 이진탐색트리는 완전이진트리가 아니기때문에, 삽입, 삭제시의 값에 따라 트리의 모양이 바뀌며 높이도 계속 바뀐다.
								ㄴ 최악의 경우 '편향 트리'로서, 왼쪽 자식만 쭉 있거나, 오른쪽 자식만 쭉 있는 형태.
								ㄴ 평균적인 경우, O(log n)
								ㄴ 균형 탐색 트리(balanced search tree)
									ㄴ 왼쪽, 오른쪽의 서브트리 사이의 높이차를 1로 맞춤으로서 최악의 경우가 나오지 않게 하는 이진탐색트리.
							ㄴ 탐색 )
								ㄴ 찾는 키값을 루트값과 비교하여 같으면 찾은것, 루트값이 더 크면 왼쪽 서브트리 서치, 더 작으면 오른쪽서브트리 서치하는 방식.
								ㄴ 방식 )
									루트부터 시작해서,
									1. 찾는 키값과 루트의 키값이 같으면 탐색 완료,
									2. 찾는 키값이 루트보다 작으면 왼쪽 서브트리 탐색,
									3. 찾는 키값이 루트보다 크면면 오른쪽 서브트리 탐색,
									위 세 단계를 반복.
									왼쪽 또는 오른쪽 서브트리를 탐색하려는데 없어서 null이면 해당 키값은 없는 것.
							ㄴ 삽입 )
								ㄴ 동일한 키값을 가지는 원소가 있는지 확인하고, 없으면 이진탐색트리 규칙에 따라 맞는 위치에 삽입시켜준다.
								ㄴ 방식 )
									ㄴ '탐색'과 유사한 방식.
									ㄴ 루트부터 시작해서,
										1. 삽입할 값과 루트의 키값이 같으면, 이미 값이 존재하므로 false반환.
										2. 삽입할 값이 루트의 키값보다 작으면 왼쪽 서브트리로 이동, 크면 오른쪽 서브트리로 이동.
										위를 반복하다가 말단노드 위치에 오면 해당 위치에 값 삽입.
							ㄴ 삭제 )
								ㄴ 똑같은 방식으로 찾고 찾은 해당노드에 대해 세가지 경우로 나누어 처리. (자식노드가 없는경우, 하나인경우, 두개인 경우)
									ㄴ 자식노드가 없는경우 : 그 삭제하려는 노드의 부모노드의 자식필드 값을 0으로 만듦.
									ㄴ 하나인 경우 : 삭제하려는노드와 자식노드의 위치를 바꿈.
									ㄴ 두개인 경우 : 삭제하려는 노드의 왼쪽 서브트리에서 가장 큰 노드와 위치를 바꾸거나 오른쪽 서브트리에서 가장 작은 노드와 위치를 바꿈.
										ㄴ 왼쪽 서브트리에서 가장 큰 노드는 왼쪽 서브트리에서 오른쪽 자식쪽으로만 쭉내려가다가 오른쪽 자식노드가 없는 노드이다.
										ㄴ 오른쪽 서브트리에서 가장 작은 노드는 오른쪽 서브트리에서 왼쪽 자식쪽으로만 쭉내려가다가 왼쪽 자식노드가 없는 노드이다.
							ㄴ 시간복잡도 : 삽입, 삭제, 탐색의 시간복잡도는 트리의 높이를 h라 할때, O(h)
								ㄴ 이진탐색트리가 편향트리이 가까울수록 h는 최대인 n(노드수)에 가까워지며 효율이 안좋아진다.

							ㄴ 최적 이진 탐색 트리, Optimal binary search tree, OBST
								ㄴ 가중치 또는 확률이 있는 '이진 탐색 트리'에서 '탐색'을 하는 경우, '평균'적으로 가장 탐색하는 시간이 짧은 이진탐색트리를
									'최적 이진 탐색 트리'라고 한다.
								ㄴ ~~~~~~~~~~~~~~~~~~~~~~~~~~
								ㄴ 이러이러하면 결과적으로
									ㄴ 모든 노드가 확률이 동일할 경우, 트리가 '완전 이진 트리'에 가까울 수록 OBST에 가까워진다.
									ㄴ 각 노드의 확률이 다를 경우, 확률이 큰 노드가 루트에 가가울수록 OBST에 가까워진다.

							ㄴ AVL 트리
								ㄴ '이진 탐색 트리'가 삽입과 삭제가 일어나는 데이터셋을 표현하는데 쓰일경우, 입력되거나 삭제되는 데이터의 순서에 따라 모양이 달라지며,
									이에따라 동작에 평균 시간이 달라진다.
								ㄴ '이진 탐색 트리'의 삽입, 삭제, 탐색이 모두 O(log n)이다.
								ㄴ 정의 ) 트리 안에 어떤 노드를 기준으로 하든, 그 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이차가 1이하이면 AVL트리이다.
									(높이차가 1이하인것을 높이균형을 이루었다고함)
								ㄴ AVL의 삽입, 삭제, 탐색 )
									ㄴ 탐색 ) '이진탐색트리'와 동일하다.
									ㄴ 삽입, 삭제 )
										ㄴ 이진탐색트리의 삽입, 삭제와 동일한 방법인데 거기에다가, 삽입,삭제 이후에 '높이 불균형'이 일어나면 4가지 형태의 '회전'을
											실시하여 높이균형을 유지함.
										ㄴ LL
										ㄴ RR
										ㄴ LR
										ㄴ RL
						</pre>

				</pre>

			</pre>

			ㅇ 정렬 <button>펼치기</button>
			<pre>
				ㅡ 탐색 )
					ㄴ 순차탐색 )
						ㄴ 맨끝부터 다른쪽 맨끝까지 순서대로 쭉 탐색하는 방법. (배열 0부터 n까지 확인하듯이)
						ㄴ 탐색대상이 정렬되어있을 필요가 없다.
						ㄴ 시간복잡도 O(n)
					ㄴ 이진탐색 )
						ㄴ 탐색 대상이 순서에 따라 정렬되어 있어야함.
						ㄴ 탐색 대상의 중간을 확인해, 찾는값이 확인한 중간값보다 크면 중간의 오른쪽을, 작으면 중간의 왼쪽으로 범위를
							좁혀서 탐색해 나가는 방법.
						ㄴ 구현 )
							ㄴ 탐색 대상 범위를 나타내는 left, right를 두고 범위가 좁혀질때마다 left에 중간값+1을 하던지
								right에 중간값-1을 하다가, left>right되는 시점이 탐색끝났을때.
						ㄴ 시간복잡도 O(log n)
				ㅡ 정렬 )
					ㄴ 일련의 데이터들을 크기순(오름차순또는 내림차순)으로 정렬하는 것.
					ㄴ 삽입정렬 )
						ㄴ 개요 )
							ㄴ 일련의 데이터들을 앞에서부터 차례대로 알맞은 위치에 삽입시키는 정렬.
							ㄴ 앞쪽에서부터 하나씩 선택하여 그 원소를 삽입정렬하며, 선택한 원소기준으로 앞쪽을 정렬된곳,
								뒤쪽을 아직 정렬 안된곳으로 분류.
							ㄴ 선택한 원소를 앞쪽 정렬된 부분 안에서, 한쪽에서부터 하나씩 크기비교를 해가며 알맞은 위치를 찾고 그 위치에 삽입시킴.
						ㄴ 시간복잡도 )
							ㄴ 하나의 원소를 선택하고 이를 알맞은 위치에 삽입하는 과정의 시간복잡도는,
								이 원소가 i번째 원소라 할떄(즉, i-1개가 정렬된상태), 최악의 경우 약 i번 비교한다.
							ㄴ 위와같은 삽입작업이 i가 1일때부터 n-1일때까지 더해지므로 시그마 i=1부터 n-1까지 (i+1)해서 계산하면 O(n^2)
					ㄴ 퀵정렬 )
						ㄴ 방법 )
							1. 일련의 데이터 중 맨 앞의 값을 'pivot'이라고 정한다.
							2. pivot 바로 다음 부분을 'left', 반대편 맨끝을 'right'으로 정한다.
							3. left를 한칸씩 오른쪽으로 이동시키며 pivot보다 큰값이 있을때 멈춘다. 마찬가지로 right를 한칸씩 왼쪽으로 이동시키며
								 pivot보다 작은값을 만나면 멈춘다.
							4. left,right가 둘다 멈추면 두 값을 서로 바꿔준다. (단, 멈췄을때 left< right이어야 한다.
								즉, left,right가 한칸씩움직이다 서로 교차하면 반복을 멈춘다)
							5. left, right가 교차할때까지 3,4번을 반복한다.
							6. 반복이 끝나면 right와 pivot의 값을 바꿔준다. 이렇게되면 pivot을 기준으로 오른쪽은 pivot보다 큰값,
								왼쪽은 pivot보다 작은값이 오게된다.
							7. 재귀함수를 이용해 pivot을 기준으로 오른쪽부분, 왼쪽부분에 대해 1~6번 과정을 반복해준다.
								각 부분의 원소가 2개 이상이어야 진행한다.
						ㄴ 시간복잡도 )
							ㄴ 데이터들이 이미 정렬되어 있는 경우가 최악의 경우이며 O(n^2)
								ㄴ 맨 왼쪽을 pivot으로 잡고 시작시 이미 정렬되어 있으므로 left는 첫번째에서 멈추고
									right는 pivot보다 큰 값을 찾지 못해 맨 오른쪽에서 끝까지옴(n번)
								ㄴ 다음 pivot은 이전 pivot바로 오른쪽이 되고 위 과정을 반복. n-1번
								ㄴ 이렇게 n, n-1, n-2, ..., 1 번 반복하여 O(n^2)
							ㄴ 하지만 평균적으로는 O(n*log n)이 나온다고 한다.
							ㄴ 최악의 경우를 피하는 방법으로 pivot을 선택할때, 무조건 맨앞의 값이 아닌 적절하게 중간값을 선택하는 방법이 있다.
								ㄴ 일련의 데이터에서 맨앞, 중간, 마지막 값중에 중간크기의 값을 pivot으로 선택하여 맨 앞으로 보내고 정렬하는 것.
					ㄴ 합병 정렬 )<button>more</button>
					<pre>
						ㄴ 기본 작업 단계 : 합병 )
							ㄴ 이미 정렬된 2개의 리스트를 1개의 정렬된 리스트로 만드는 것.
							ㄴ 방법 ) i1, i2를 각 리스트의 맨 처음에 두고 값 비교. 더 작은 값을 iResult에 복사.(iResult는 합친결과 리스트)
								더작은 값에 해당하는 i1또는 i2를 1증가. i1,i2가 각각 끝지점인 m,n을 넘어서지 않을때까지 반복.
								한쪽이 넘어서 반복이 끝나면 다른 한쪽 리스트의 나머지부분을 다 복사해서 iResult에 넣음.
							ㄴ 시간복잡도 : 합병하려는 원소들을 한번씩 복사하는 과정이므로 합병 대상 원소 수만큼의 시간복잡도가 걸린다.
						ㄴ 반복 합병 정렬 )
							<img src="image/합병정렬.png"/>
							ㄴ 위의 기본 작업단계 '합병'을 이용하여 데이터를 정렬하는 방법.
							ㄴ 방법 )
								ㄴ 일련의 데이터에서 데이터 각각을 정렬이 된 하나짜리 리스트 취급하여 이 하나짜리들을 옆에것과 '합병'.
									ㄴ 그 다음 합쳐진 두개짜리들을 옆에것과 '합병'
								ㄴ 이런식으로 length=1부터 시작하여 특정 길이 length 단위로 배열을 나누어 각각 '합병' 진행.
								ㄴ 해당 단계의 길이로 리스트 짝들을 묶은 뒤, 짝이 안 맞는 남는 것들은 그냥 복사.
								ㄴ 하나로 합쳐질때까지 반복.
						ㄴ 시간복잡도 )
							ㄴ 기본 작업 단계 '합병'의 경우, 결과적으로 모든 원소 한번씩 확인하여 복사하므로 원소 개수 O(n).
							ㄴ 특정 length 단위로 합병 진행시에도 결과적으로 모든 원소를 한번씩 확인하고 복사하므로 O(n).
							ㄴ 이를 배열이 하나로 합쳐질 때까지 반복.
								ㄴ length는 특정 길이 length에 대해 합병단계를 진행하는 횟수를 i라 할때,
									2^(i-1)를 따르고, length는 배열의 길이 n을 넘으면 안되므로 2^(i-1) < n
									양변에 log를 취하면 i-1 < log(2) n (밑이 2인 로그)
									하여 진행해야할 합병단계 최대 횟수는 log(2) n
								ㄴ O(n) * O(log(2) n) 이므로, 시간복잡도는 O(n*log(2) n)
							ㄴ 정렬하려는 길이n인 배열이 있을 때, 이런 '합병' 단계를 특정 길이 length로 나누어 합병해도
								모든 원소에 대해 한번씩 확인하고 복사하므로 O(n)
							ㄴ 즉, O(n) * (**)
					</pre>
					ㄴ 히프 정렬 )<button>more</button>
					<pre>
						ㄴ 개요)
							ㄴ '최대 또는 최소 히프'를 이용해 정렬하는 방법.
							ㄴ 최대 히프에서 가장 큰값인 root를 빼서 result에 저장하는 방식을 반복함으로서 정렬한다.
						ㄴ 방식 )
							ㄴ 정렬할 원소들이 있는 배열 arr을 논리적으로 완전이진트리로 바라보고 진행.
							1. arr을 최대(최소)힙으로 만듦.
								1.1 가장 마지막 노드의 부모 노드부터 루트 노트까지의 노드에 대해 '조정'
									'조정'이란, 특정 부분트리를 최대 히프로 만드는 과정.
									1.1.0 부분트리의 왼쪽, 오른쪽 서브트리가 최대히프 상태라는 전제하에,
									1.1.1 루트 노드의 두 자식노드 중 큰 것을 선택,
									1.1.2 하나이거나 없다면 종료.
									1.1.3 있다면 이 더 큰 노드보다 루트 노드가 더 크면 종료.
									1.1.4 작으면 자리를 바꿔준다.
									1.1.5 자리가 바뀌어 내려간 루트 노드에 대해 위 과정(1.1.1~1.1.4)을 반복해준다.
							2. 마지막 노드와 루트 노드의 자리를 바꿈. 루트노드가 내려간 마지막 자리는 배열에서 없는 것으로 취급.
								(이 부분은 정렬된 것으로 취급)
							3. 마지막 노드 이전 노드부터 루트 노드까지에 대해 '조정' 수행.
							4. 2,3번을 n-1번 반복.
							ㄴ arr에 원소들이 정렬된 상태가 된다.
						ㄴ 시간복잡도 )
							ㄴ 초기 배열을 완전이진트리로 보고 최대(최소)힙으로 만드는 과정 )
								idx n/2부터 1번까지 '조정'을 수행. '조정'은 최악의 경우 트리의 높이만큼 연산하므로 O(log n)
								따라서 O(n * log n)
								ㄴ ??? 더 정확히는 O(n)이라함.
							ㄴ 최대(최소)힙에 대해 히프정렬 과정 )
								n-1번 반복, 각 반복마다 '조정' 한번씩 수행하므로
								O(n * log n)
							ㄴ 시간복잡도는 O(n * log n)

						ㄴ 구현 )
							ㄴ 정렬된 데이터를 저장할 result를 따로만들고
							ㄴ 맨처음 일련의 데이터들을 최대히프로 만들어준다.
							ㄴ 최대히프에서 root값을 빼서 result에 저장, 이후 뺀값을 최대히프에서 삭제.
							ㄴ 최대히프에서 가장 마지막노드를 root자리에 위치시키고 최대히프구조를 유지시키기위해 정렬.
								(최대히프에서 삭제연산과 방식이 비슷하다)
								ㄴ 왼쪽과 오른쪽 자식중 큰값을 찾아서 이를 자신과 비교하고 자신이 더 크면 거기에 위치시키고 더 작으면
									그 자식과 자리를 바꾸고 이를 반복.
							ㄴ 최대히프가 빌때까지 반복.
						ㄴ ??? 여러 키에 의한 정렬?
						ㄴ ??? 기수정렬?
					</pre>
			</pre>

			ㅇ 해시, hash <button>펼치기</button>
			<pre>
				ㅡ 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수.
				ㅡ 해시 함수에 의해 반환된 값을 '해시값', '해시', '해시코드' 등으로 부른다.
				ㅡ 해시값은 '해시 테이블'이라는 고정된 크기의 테이블을 인덱싱하는데 사용된다.
					이렇게 해시함수를 사용하는 것을 '해싱', 'scatter storage addressing' 라고 부른다.
				ㅡ 데이터 저장과 검색에 쓰인다. 검색시 거의 상수 시간 안에 검색이 가능하다.
				ㅡ ??? ~~~
				ㅡ 해시함수는 checksum, check digit, fingerprint, lossy compression, randomization,
					error-correcting code, cipher 등과 관련이 깊다.
					ㄴ 겹치는 부분이 많긴 하지만,
						??? 이들은 각각의 요구사항과 사용방식이 있고,
				ㅡ ~~~~~~
				ㅡ 해쉬함수 정의 방법 )
					ㄴ 자릿수 선택 )
						ㄴ 키값에서 보통 중복이 많이 되는 부분을 제외한 나머지 부분들로 해쉬값을 만드는 것. 당연한 방법이다.
						ㄴ 비트 추출 방법
					ㄴ 자릿수 폴딩 )
						ㄴ 자릿수를 '접는다'는 뜻으로,
						ㄴ 키 값을 자릿수기준으로 일정하기 분할한다음, 그 나눠진 수들을 가지고 더하든지 XOR연산을 하든지해서 해쉬값을 만드는 방식이다.
						ㄴ ex)	273419라는 키값이 있을때, 이를 삼등분하여 27, 34, 19로 나누고 이들을 더한 80을 해쉬값으로 만드는 것.
					ㄴ 키를 제곱하여 이 중 일부를 추출
					ㄴ 등등 다양하다.
				ㅡ 충돌 문제 해결책 )
					ㄴ '열린 어드레싱 방법(open addressing method)'와 '닫힌 어드레싱 방법(closed addressing method)'가 있다.
					ㄴ '열린 어드레싱 방법 )
						ㄴ '충돌'이 발생하면 그 지점이 아닌 다른 지점에 저장하는 방식.
						ㄴ '선형 조사법'과 '이차 조사법'이 있다.
						ㄴ 선형 조사법 )
							ㄴ 간단히 말해, '충돌'이 발생하면 한칸 옆에있는 자리를 보고 비어잇으면 그곳에 저장한다.
							ㄴ 한칸 옆자리도 비어있지않으면 그 옆칸을 확인한다.
							ㄴ 이런식으로 '충돌'이 일어난 지점으로부터 'n칸' 옆자리를 확인하여 비어있으면 이곳에 저장하는 방식이다.
						ㄴ 이차 조사법 )
							ㄴ '선형 조사법'과 달리 충돌지점으로부터 n칸 옆자리가 아닌 'n^2'칸 옆자리를 확인하여 비어잇으면 저장하는 방식이다.
							ㄴ '선형조사법'은 '충돌'의 횟수가 증가함에 따라 데이터가 특정 지점에 몰리는 문제점이 있다. 이를 '클러스터(cluster) 현상'이라고 한다.
							ㄴ 이를 해결하기 위해 n에 제곱을 한만큼 떨어진 곳을 확인하여 비어잇을때 저장하는 방법을 쓰는것.
							ㄴ ex)	1^2=1칸 옆자리를 확인, 데이터가 들어있으면 2^2=4칸 옆자리를 확인, 데이터가 들어있으면 3^2=9칸 옆자리를 확인...
						ㄴ 이중 해쉬 )
							ㄴ 이차조사법 역시 문제점이 있다. 해쉬값이 같은 경우, 충돌 발생시 빈슬롯을 찾기위해 접근하는 위치가 늘 동일하여 이들을 주위로
								클러스터 현상이 발생한다는 것.
							ㄴ 이를 해결하기 위해, 충돌발생시 '이차 조사법'처럼 늘 같은 방식으로 빈 슬롯을 찾는게 아니라 매번 다른 방식으로 찾는 방식이 '이중 해쉬'이다.
							ㄴ 방법 ) '1차 해쉬 함수'와 '2차 해쉬 함수'를 두어서, 1차는 해쉬값을 만드는데 사용하고, 2차는 충돌발생시 얼만큼 떨어진 위치에서
								빈슬롯을 찾을지를 결정하는데 사용한다. '충돌' 발생시, 2차 해쉬함수에서 나온 값만큼 건너뛰면서 빈 슬롯을 찾게된다.
							ㄴ ex)
								1차 해쉬함수 : h1(k) = k%15 ,    2차 해쉬 함수 : h2(k) = 1+(k%7)
							ㄴ 2차 해쉬함수 형식 )
								ㄴ 필수는 아니지만 일반적으로 쓰이는 2차해쉬함수 형식이 있다고 한다.
								ㄴ h2(k) = 1 + (k%c)
									ㄴ 1을 더하는 이유는 2차 해쉬함수가 충돌발생시 몇칸 떨어진 위치에서 빈슬롯을 찾을지를 결정하는 함수인데 0이 나와버리면
										'0칸 떨어진곳에서 빈슬롯을 찾는다'와 같은 결과가 나오므로 이를방지하기 위해 1을 더한다.
									ㄴ c는 1차 해쉬함수에서 나오는 값의 범위보다 작으면서 '소수'를 선택한다.
										ㄴ 1차 해쉬함수에서 나오는 값의 범위보다 작아야 하는 이유는 이보다 클경우, 빈 슬롯을 찾으로 해쉬테이블을
											몇바퀴 돌아야하는데 이를 방지하기 위해서.
										ㄴ '소수'를 선택하는 이유는 통계적으로 '소수'를 선택해야 클러스터 현상의 발생확률이 줄어든다고 한다.
					ㄴ 닫힌 어드레싱 방법 )
						ㄴ '충돌'이 발생해도 그 지점에 무조건 저장하는 방식.
						ㄴ 해당 해쉬값 지점에 공간을 여러개 만드는  방식으로 구현한다.
						ㄴ 배열과 리스트로 가능하다, 배열은 충돌발생이 안될경우 메모리 낭비가 심해, 일반적으로는 리스트를 말한다.
						ㄴ '체이닝' )
							ㄴ 각 해쉬값 지점들을 리스트로 만들어 '충돌'발생시 그 리스트에 쭉이어서 추가하는 방식을 '체이닝'이라 한다.

				ㅡ 해쉬테이블의 슬롯 상태정보 )
					ㄴ 해쉬테이블의 각 슬롯마다 '상태정보'를 별도로 저장해 관리해야한다.
					ㄴ 상태는 보통 'EMPTY', 'DELETED', 'INUSE' 가 있다.
						ㄴ empty : 슬롯이 단한번도 채워진적이 없음.
						ㄴ deleted : 슬롯이 채워져있었으나 삭제됨.
						ㄴ inuse : 슬롯에 현재 값이 채워져있음.
					ㄴ 상태정보가 필요한 이유 )
						ㄴ '충돌'이 발생하여 데이터가 '선형 조사법'이나 '이차 조사법'에 의해 다른 곳에 저장되어있는경우
						ㄴ ???????????????????????????????///
			</pre>

			ㅇ 분할정복법<button>more</button>
			<pre>
				ㅡ 주어진 문제를 n개의 부분 문제들로 분할하고 각 부분 문제들을 해결하여 원래 문제의 해답으로 결합하는 방식.
				ㅡ 부분 문제들이 원래 문제와 크기 차이만 있는 동일한 문제이어야 한다.
				ㅡ ??? 대략 방식?
					재귀함수 사용.
					함수 내에서, 문제가 충분히 작다면 문제를 해결하여 반환,
					충분히 작지 않다면, 문제를 부분 문제로 분할후, 각 부분에 대해 재귀함수 호출.
					재귀함수들이 끝나면 부분문제들을 결함.
				ㅡ 장점
					ㄴ 어려운 문제를 간단해질 때까지 잘게 나누어 풂으로서 쉽게 해결할 수 있다
					ㄴ 병렬진행이 가능하다
					ㄴ
				ㅡ 재귀적으로 구현될 수도, 분할한 sub problem의 해를 따로 저장하는 식으로 구현될 수 있다.
				ㅡ 하나의 subproblem으로 분할하는 경우, 'divide and conquer'보단 'decrease and conquer'로 보는게 더 적절하다함.
				ㅡ ??? constant factor에 의해 탐색공간이 감소되면(가지치기 되면?)?
				ㅡ base case의 선택
					ㄴ base case란, 분할정복 알고리즘에서 가장 잘게 나누어지는 단위를 말함. 알고리즘에서 어떤 경우를 가장 작은 단위로
						보고 풀이를 할 것인지를 의미.
						ㄴ ex ) 합병정렬의 경우, 보통 나누어진 배열의 길이가 1인 경우를 가장 작은 단위로 보고 알고리즘 풀이가 진행됨.
				ㅡ 동적 계획법과의 차이
					ㄴ 원문제가 'overlapping subproblem'이 아닌 하위 문제들의 해를 통해 구해질 수 있으면
						분할정복법이라함.
			</pre>

			ㅇ 그리디 알고리즘, Greedy<button>more</button>
			<pre>
				ㅡ ??? 매번 각 단계에서 지역적인 최선의 선택을 하는 휴리스틱 문제해결법을 따르는 모든 알고리즘을 지칭?
				ㅡ 정확한 최적해가 아닌 '적당한' 해를 구하기 위해 사용된다.
					ㄴ '적당한' 해란, 합리적인 시간 안에 최대한 최적해에 근접한 해.
				ㅡ 정확한 최적해를 구하기 위해 필요한 복잡하고 많은 풀이 단계를 생략해주어 시간이 많이 걸리지 않는 경우가 많다.
				ㅡ 그리디 알고리즘을 적용할 수 있는 문제 성질 )
					ㄴ greddy choice 속성
						ㄴ ???그리디 알고리즘에 의해 선택된 선택들은 알고리즘 안에서의 과거 선탹에 의존하여 결정될 순 있지만
							미래 선탹이나 subproblem에 의존하여 결정되지는 않는다?
					ㄴ optimal substructure
						ㄴ 동적 계획법에 나오는 것과 동일.
				ㅡ ??? 탐색, 'branch-and-bound' 문제에서 우선하는 것을 선택할 때 사용되는 알고리즘.
				ㅡ 그리디 알고리즘이 최적해를 산출해 낸다는 것이 증명만 된다면 이 알고리즘은 문제해결을 위한 선택함수로 사용된다.


			</pre>

			ㅇ 동적 계획법<button>more</button>
			<pre>
				ㅡ 최적화 알고리즘 중 하나.
				ㅡ 어떤 문제가 'optimal substructure'와 'overlapping subproblem'에 해당되면 동적 프로그래밍을 적용할 수 있다.
					ㄴ 'optimal substructure', 'overlapping subproblem'은 문제가 가지는 속성을 말함.
						문제가 이러한 속성을 가지면 동적 계획법을 적용할 수 있다는 말.
					ㄴ 'optimal substructure'이지만 'non-overlapping subproblem'이면 '분할 정복법'을 적용 대상이다.
					ㄴ '최적 하부구조(optimal substructure)'
						ㄴ 원문제를 하위 문제로 쪼갰을 때, 하위 문제에 대한 최적해를 통해 원문제에 대한 최적해를 구할 수 있을 때
							최적 하부구조를 가진다고 한다.???
						ㄴ 보통 재귀함수를 통해 표현된다.
						ㄴ ex ) 최단경로. a->b로 가는 최단경로 path1이 있다면,
							a와 b사이 임의의 c에 대해, a->c 경로가 path1-1, c->b경로가 paht1-2라하면 path1-1, path1-2도
							마찬가지로 최단경로이다.
					ㄴ 겹치는 하위 문제(overlapping sub-problem)
						ㄴ 원문제가 여러번 재사용되는 하위 문제로 분해될 수 있거나, 원문제를 재귀함수로 풀 때, 그 재귀풀이가 동일한
							하위문제를 반복적으로 푸는 경우, '겹치는 하위 문제'를 가진다고 한다.
						ㄴ ex ) 피보나치 수열.
							f(i) = f(i-1) + f(i-2)
							f(5)를 구한다할 때, 재귀로 구하는 과정에서 f(2) 등은 계속해서 구해지고, 이 f(2)를 전체 과정 안에서
							재사용해 사용할 수 있으므로 overlapping subproblem을 가진다.
				ㅡ ??? 큰 문제를 작은 문제로 중첩 재귀로서 표현할 수 있으면 동적 계획법을 적용할 수 있다?
					ㄴ ??? 이럴 때, 원래 문제와 sub문제 사이에 'Bellman equation'이란 관계가 있다?
				ㅡ ??? '최적 하부구조'를 만족하도록, 즉, 하위 문제를 통해 전체문제의 최적해를 풀 수 있도록 하위문제를 적절히 정의하는 것이
					중요?
					전체 문제의 최적해를 하위 문제들을 통하여 풀 수 있는 알고리즘을 생각해내는게 중요?
			</pre>

			ㅇ Backtracking, 백트래킹<button>more</button>
			<pre>
				ㅡ ??? 'partial candidate solution'이 적용되고, 해가 될 수 있는지 빠른 판단이 가능한 문제에 적용 가능하다?
				ㅡ '가능한 케이스'들을 나열한다.
					이 '가능한 케이스'들은 최종적으로 해의 일부('완벽한 케이스')가 될 수 있는 케이스들이며,
					알고리즘의 단계들을 거치면서 점진적으로 '완벽한 케이스'가 되어간다.
					이를 '트리' 구조로서 표현이 가능하다. 케이스들을 트리의 노드로 바라보고, 루트로부터 트리를 탐색해 나가며,
					노드가 '가능한 케이스'이면 그 노드의 서브트리 노드들을 나열하고 아닌 경우 나열하지 않고 탐색하지 않는다.
			</pre>

			ㅇ 알고리즘 문제풀이 팁<button>more</button>
			<pre>
				ㅡ
			</pre>

		</pre>

		FireBase<button>펼치기</button>
		<pre>
			ㅡ 간단 개요 )
				ㄴ 앱, 웹을 개발하는데 사용되는 주요한 여러 기능들(로그인처리, 메세지, 알림, 데이터베이스 등)을 손쉽게 구현할 수 있도록
					도와주는 도구들이 있는 플랫폼..? 툴 박스 같은것..?
			ㅡ FCM ( Firebase Cloud Message)
				ㄴ

		</pre>

		오픈 api<button>펼치기</button>
		<pre>
			유튜브 api<button>펼치기</button>
			<pre>
				ㅡ ~~~~~
				ㅡ api 리소스 유형
					ㄴ api를 통해 여러 작업(조회,삭제,수정,삽입)을 할 수 있는 리소스의 유형.
					ㄴ video, thumbnail, playlist, channel, search result 등.
				ㅡ api 작업 유형
					ㄴ list, insert, update, delete 를 제공.
					ㄴ 리소스 유형별로 가능한 작업이 다르다.
				ㅡ part, fields
					ㄴ api 요청시, 'part', 'fields' 파라미터를 추가하여, api에서 반환하는 데이터에서 일부만을 받을 수 있다.
						ㄴ https://www.googleapis.com/youtube/v3/search?key=(*api키*)&maxResults=10&q=동화약품
							위와 같은 api요청에 쿼리파라미터로 'part', 'fields'를 추가하는 것.
						ㄴ 각 api요청마나 가능한 'part'들 존재. 문서 참고.
							ex) 키워드 검색api인 https://www.googleapis.com/youtube/v3/search 에는 'id', 'snippet' part 존재.
						ㄴ api의 응답 데이터(json)에 대해, json의 키값으로 'fields' 작성 가능.
							ㄴ 동일 계층 키워드면 컴마(,)로 나열, 하위 계층 키워드면 상위 계층 키워드 뒤에 소괄호()로 나열.
							ㄴ 아래 예제 참고.
						ㄴ ex)<button>more</button>
						<pre>
							ㄴ https://www.googleapis.com/youtube/v3/search?key=AIzaSyByUMQzcO6cH_OLQ6iukmS4bTTWHFatPY8&part=id,snippet&maxResults=10&q=%EB%8F%99%ED%99%94%EC%95%BD%ED%92%88%20000020&type=video
								위와 같이 요청시, ('part'파라미터만 지정) 아래와 같이 결과.
							{
							  "kind": "youtube#searchListResponse",
							  "etag": "jqqvVuUsOjLEbnAoS29pl3s-uYQ",
							  "nextPageToken": "CAoQAA",
							  "regionCode": "KR",
							  "pageInfo": {
								"totalResults": 4091,
								"resultsPerPage": 10
							  },
							  "items": [
								{
								  "kind": "youtube#searchResult",
								  "etag": "FVO4D-RAOhujM4onwxFNLL3zYYs",
								  "id": {
									"kind": "youtube#video",
									"videoId": "70DLk9gay8w"
								  },
								  "snippet": {
									"publishedAt": "2021-12-15T06:18:44Z",
									"channelId": "UC8Sv6O3Ux8ePVqorx8aOBMg",
									"title": "동화약품(000020)_종목 상담_주식 챔피언 쇼 (20211215)",
									"description": "종목 상담: #동화약품(000020) #주식 #김두호 #종목 #상담 이데일리TV ✓주식·부동산 전문 재테크 채널 ▷이데일리TV 채널 구독하기 ...",
									"thumbnails": {
									  "default": {
										"url": "https://i.ytimg.com/vi/70DLk9gay8w/default.jpg",
										"width": 120,
										"height": 90
									  },
									  "medium": {
										"url": "https://i.ytimg.com/vi/70DLk9gay8w/mqdefault.jpg",
										"width": 320,
										"height": 180
									  },
									  "high": {
										"url": "https://i.ytimg.com/vi/70DLk9gay8w/hqdefault.jpg",
										"width": 480,
										"height": 360
									  }
									},
									"channelTitle": "이데일리TV",
									"liveBroadcastContent": "none",
									"publishTime": "2021-12-15T06:18:44Z"
								  }
								},
								...
							  ]
							}

							ㄴ https://www.googleapis.com/youtube/v3/search?key=AIzaSyByUMQzcO6cH_OLQ6iukmS4bTTWHFatPY8&part=id,snippet&maxResults=10&q=%EB%8F%99%ED%99%94%EC%95%BD%ED%92%88%20000020&type=video&fields=kind,etag,nextPageToken,regionCode,pageInfo,items(kind,etag,id(videoId),snippet(publishedAt,title,thumbnails(default(url)),channelTitle))
								위와 같이 요청시, ('fields'파라미터 추가) 아래와 같이 결과
							{
							  "kind": "youtube#searchListResponse",
							  "etag": "9g9dM56dyGW-Lf8NFbqCJZVQL2E",
							  "nextPageToken": "CAoQAA",
							  "regionCode": "KR",
							  "pageInfo": {
								"totalResults": 4030,
								"resultsPerPage": 10
							  },
							  "items": [
								{
								  "kind": "youtube#searchResult",
								  "etag": "FVO4D-RAOhujM4onwxFNLL3zYYs",
								  "id": {
									"videoId": "70DLk9gay8w"
								  },
								  "snippet": {
									"publishedAt": "2021-12-15T06:18:44Z",
									"title": "동화약품(000020)_종목 상담_주식 챔피언 쇼 (20211215)",
									"thumbnails": {
									  "default": {
										"url": "https://i.ytimg.com/vi/70DLk9gay8w/default.jpg"
									  }
									},
									"channelTitle": "이데일리TV"
								  }
								},
								...
							  ]
							}

						</pre>

				ㅡ 할당량<button>more</button>
				<pre>
					ㄴ api요청시마다 할당량이 소모.
						요청하는 api종류마다 할당량이 다름 ex) 영상 하나에 대한 정보 조회는 1, 키워드 검색 요청은 100 등
						한 api 종류 안에서도 'part'의 개수만큼 할당량 추가.
					ㄴ api 종류별 할당량
						ㄴ https://developers.google.com/youtube/v3/determine_quota_cost
						ㄴ ex) 키워드 검색 api인 https://www.googleapis.com/youtube/v3/search의 경우 한번 요청으로 최소 할당량 100이 소모.
					ㄴ 할당량 늘리기
						ㄴ googl cloud platform > youtube data api 관리 콘솔에서 할당량 추가 요청을 구글에 보내어 허락받아야함.
						ㄴ 할당량 요청 api 로직에 할당량 최적화 개선 여지가 있는지 메일로 주고받는 과정이 있다 하고, 오래 걸린다 함.
				</pre>

				ㅡ 라이브러리<button>more</button>
				<pre>
					ㄴ api요청을 편리하게 할
				</pre>

			</pre>
			애플 <button>펼치기</button>
			<pre>
				로그인 연동<button>펼치기</button>
					<pre>
						ㅡ 문서가 영어로 되어있고 이해하기가 어려워 블로그에서 찾은 구현된코드만 기록해둔다. OAuth방식이라 대충 어떻게 동작하는지
							알수는 있을것이다.
							ㄴ 블로그 주소 : https://whitepaek.tistory.com/61
						ㅡ 처음 로그인 요청 부분. js 코드 )
							< body >
							< div id="appleid-signin" data-color="black" data-border="true" data-type="sign in" style="height: 50px; width: 100%;">< /div>
							< script type="text/javascript" src="https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js">< /script>
							< script type="text/javascript">
								AppleID.auth.init({
									clientId : '[[${client_id}]]',	//애플에서 certificate & identifier?등록시 나오는 서비스id.
									scope : 'name email',
									redirectURI : '[[${redirect_uri}]]',	//애플에서 앱등록시 설정하는 redirect url.
									state : 'test',
									nonce : '[[${nonce}]]',	//잘모르겠음. 크게상관없는 임의의 값이거나 api로부터 반환받은값 검증에 쓰이는듯함.
									usePopup : false
								});
							< /script>
							ㄴ 이렇게 만들고 실행하면 앱 로그인 버튼이 뜨며, 클릭후 로그인하면 정보가 redirect url로 넘어감.
						ㅡ 응답받는 컨트롤러 메소드 )
							@ApiOperation(value = "애플 로그인 리다이렉트 메소드",notes = "")
							@PostMapping("/appleAuthCode")
							public void getAppleAuthCode(
									AppleAuthCodeDto request,
									HttpServletResponse response
							) throws NoSuchAlgorithmException, InvalidKeyException, IOException, InvalidAlgorithmParameterException, NoSuchPaddingException, BadPaddingException, ParseException, IllegalBlockSizeException {
								System.out.println("in /v2/api/appleAuthCode");
								SnsLoginResponseDto dto = memberService.snsLoginForApple(request.getId_token());
							}
							ㄴ AppleAuthCodeDto에는 state,code,id_token,user가 들어있으며, id_token안에 로그인한 사용자 정보가 들어있다.
								이중 sub가 로그인 사용자의 고유 식별자이다.
							ㄴ id_token은 암호화되어 있고 다음은 이를 decode하는 코드이다. JWT를 사용하였다.
								SignedJWT signedJWT = SignedJWT.parse(idToken);
								ReadOnlyJWTClaimsSet getPayload = signedJWT.getJWTClaimsSet();
								ObjectMapper objectMapper = new ObjectMapper();
								AppleLoginPayLoadDto payload = objectMapper.readValue(getPayload.toJSONObject().toJSONString(), AppleLoginPayLoadDto.class);
								String usrId = payload.getSub();

					</pre>

			</pre>

            ㅇ 구글 api<button>more</button>
            <pre>
                ㅡ 구글 로그인<button>more</button>
                <pre>
                    ㄴ

                </pre>

            </pre>

		</pre>

		IDE<button>펼치기</button>
		<pre>
			Intellij<button>펼치기</button>
			<pre>

			</pre>
		</pre>

		통계<button>more</button>
		<pre>
			ㅡ ~~~~~
			ㅡ 중앙값 : 데이터 항목들 중 인덱스 가운데 위치한 항목의 값??
			ㅡ 확률 변수 : 특정 확률로 일어나는 각 사건의 결과들을 임의의 수치값으로 표현한 변수.
				ㄴ 가령, 동전 두개를 던지는 경우를 봤을 때, 모든 사건의 경우에 대해서 나오는 앞면의 개수를 실수로 표현하면 0,1,2가 되며
					이걸 사건의 결과들을 임의의 수치값으로 표현하였다고 볼 수 있다.
				ㄴ 종류 )
					ㄴ 이산확률 변수 : 확률변수가 가질 수 있는 값이 '가산 개'인 것. 자연수같이 셀 수 있다고.
					ㄴ 연속확률 변수 : 확률변수가 가질 수 있는 값이 어떤 범위에 속하는 모든 실수값인 경우.
			ㅡ 상태공간, 확률 변수가 취하는 모든 실수들의 집합.
				ㄴ 이 상태공간 안의 특정 값이 나올 가능성은 확률로 계산될 수 있다.
			ㅡ 확률 분포, 확률 함수
				ㄴ 확률 함수란, 확률 변수에서 특정한 값을 입력하면 그 값이 발생할 확률을 나타내는 함수.
					ㄴ 가령 동전두개 던지기에서, 앞면의 개수를 확률변수로 수치화했다면, 앞면의 개수가 2개(확률변수의값이 2)나올 확률은 1/4가 된다.
				ㄴ 확률 분포란, 이런 확률 함수에서 확률 변수의 값과 그 확률을 분포로 나타낸 것. 정규분포 등.
			ㅡ 기댓값
				ㄴ 확률변수의 기댓값. 그 확률변수의 사건들에 대한 확률변수 값의 평균이라고 생각하면 된다.
				ㄴ 모든 사건들에 대해 (*확률변수의 값*) * (*그 값에 해당하는 확률*) 을 모두 더한 값이다.
			ㅡ 사분편차
				ㄴ 전체 분포에서 1/4에 해당하는 값부터 3/4에 해당하는 값의 차를 절반으로 나눈 것.
					ㄴ 즉, 전체 분포를 4등분하여 중간 두개의 쿼터 중 하나를 나타낸다.
			ㅡ 편차
				ㄴ 개별 항목의 값과 평균의 차이. (*개별값*) - (*평균*) 으로 계산
				ㄴ 분산 : 데이터의 분포에서 편차가 얼마나 되는지를 알기 위해 편차의 제곱을 모두 더해 총 항목의 개수로 나누어준 값.
					ㄴ 전체 분포에서 얼마나 퍼져있는지를 알고 싶은데, 이를 편차를 모두 더해 평균내서 계산하자니 편차의 합이 0이 되기때문에
						생각한 방법이라함.
				ㄴ 표준편차 : 분산에 제곱근을 취해준 값.
					ㄴ 분산을 이용해 분포가 얼마나 퍼져있는지 확인할 수 있지만, 제곱을 하였기 때문에 단위가 다름. 해서 제곱근을 취해줌.
			ㅡ 정규분포
				ㄴ 확률 분포의 종류 중 하나? 그냥 확률 분포가 이런 형태를 따르는게 많다고하며 이런 정규 분포가 가지는 특징들이 있다.
				ㄴ 표준 정규분포 : 많은 데이터들의 분포가 정규분포를 따르지만, 이들끼리 비교하기가 여럽다. 하여 평균과 표준편차를 0, 1로 맞추어
								비교하기가 쉽게 만든 정규분포이다.
			ㅡ 공분산
				ㄴ 확률 변수가 두 가지일때, 두 변수 사이의 상관관계를 확인할 수 있는 값.
					ㄴ 양수이면, x증가시 y도 증가한다 말할 수 있다.
				ㄴ 이를 이용하여 '상관계수'를 구한다.
				ㄴ ?????
		</pre>

		코드<button>more</button>
		<pre>
			ㅡ 클린 코드의 필요성
				ㄴ 코드 작성 후, 평생 다시 볼일이 없으면 상관 없지만,
                    이후 다시 보거나 수정이 필요하거나 재사용을 하게 될 시,
                    코드가 잘 정리되지 않고 지저분할 수록 파악 및 수정 작업이 더 buggy하고 오래 걸린다.
				ㄴ 무조건은 아니지만 프로그램에 수정은 한번 쓰고 버릴 프로그램이 아니라면 있을 확률이 크다.
				ㄴ 개인적인 경험으로는, 개발 완료 후 수정할 때 뿐만 아니라 개발 중에도 조금 코드가 길어지면 비슷한 현상을 겪는 것같다.
					코드가 길고 복잡하여 파악이 어렵고 오래걸리고 수정이 어렵고 buggy하다.
			ㅡ 클린 코드에 있어서 주요한 요소 )
				ㄴ 가독성 )
					ㄴ 변수명이 난해하거나 로직이 단순명쾌하지 않은 것.
					ㄴ 시작 단계인 코드 파악이 어려워 오래걸리고 실수를 유발함.
				ㄴ 정돈, 묶여 있지 않고 여기저기 흩어져 있거나 중복된 경우 )
					ㄴ 높은 buggy. 흩어진 코드 중 놓치는 경우가 생겨 오류 발생.
					ㄴ 가독성에도 좋지 않음.
				ㄴ 의존성
					ㄴ 의존성이 많을 수록 수정시 연달아 수정이 필요한 부분이 많고, 버그 발생시 연달아 문제가 생기는 부분이 많다.
				ㄴ 등등.. 딱 어떤게 어떤점을 유발해서 문제가 된다기보단
					이런 여러 요인들이 복합적으로 수정에 있어서 악영향을 끼치는 것.
					해서, 이런 요인들에 유의하면 되겠다.
			ㅡ 아름다울 필요까지는 없을 것 같다. 그정도로 중요도가 높거나 영향력이 크지는 않을 것 같다.
				단지, 지저분해서 문제가 생길 정도는 아니어야 한다.
			ㅡ 중복, 변수명, 적절한 크기 및 단일책임 묶음(함수 또는 클래스), 의존성,
			ㅡ 책 "클린 코드"<button>more</button>
			<pre>
				ㄴ 1. 깨끗한 코드<button>more</button>
				<pre>
					ㄴ 나쁜 코드의 문제점 : 단기적으로는 모르겠지만, 장기적으로 보았을 때
						깔끔하지 않고 지저분한 코드 때문에, 코드 파악, 수정에 많은 비용이 들고 후에는, 버그를 감당할 수 없어진다?
						ㄴ 지금 당장 그 부분을 개발하는 데에는 빠를지 몰라도, 이후 이 지저분한 부분과 조금이라도 연관이 있는
							부분을 하게 된다면 바로 역효과가 나타날 것.
						ㄴ 따라서, 시간이 조금 더 걸리더라도 좋은 코드를 작성해야 한다. 장기적으로 볼 때 그 조금 더 든 시간 보다
							많은 시간을 아껴줄테니.
					ㄴ 좋은 코드에 대한 대가들의 생각
						ㄴ 적은 의존성, 깔끔하고 명쾌한 논리
						ㄴ 글처럼 잘 읽히는, 깨끗한 코드, 단순명료한 로직.
						ㄴ 중복을 피해라, 한 가지 기능만 해라.
					ㄴ 이 책은 책을 집필한 사람들이 생각하는 '좋은 코드'에 관한 내용이다. 즉, 절대적인 기준이 아니다.
				</pre>
				ㄴ 2. 의미 있는 이름<button>more</button>
				<pre>
					ㄴ 명확하게 이름으로 대상을 파악할 수 있게 해라.
					ㄴ 가까운 범위 안에 유사한 이름을 사용하지 마라.
					ㄴ 이름에서 불필요한 정보를 제공하는 부분은 제외하라.
					ㄴ 클래스 이름은 명사, 함수 이름은 동사.
					ㄴ 같은 개념에 일관성 있는 단어를 사용하라. (가져온다는 함수 이름으로 get, retrieve, fetch 등을 이것 저것 쓰지 말란 것)
				</pre>
				ㄴ 3. 함수<button>more</button>
				<pre>
					ㄴ '의미 있는 이름'으로 무슨 일을 하는지 파악할 수 있어야 한다.
					ㄴ 한 가지 일을 해야 한다.
						ㄴ 이름으로 파악할 수 없는 다른 일을 수행하면 안 된다.
						ㄴ 오류 처리도 '한 가지 일'에 해당된다. 따라서 try/catch문으로 가독성을 떨어뜨리지 말고 오류 처리 또한 새로운
							함수로 빼내어야 한다.
					ㄴ 명확하고 쉽게 읽히기 위해 함수는 '짧아'야 한다.
						ㄴ 무조건 작을 수록 좋다고 한다. 10줄 이내, 4,5줄..?
					ㄴ 들여쓰기, 즉, 중첩구조를 사용할 수록 안 좋다. 파악하기 어렵다. 1,2단을 넘어가선 안된다.
					ㄴ 함수를 적절히 분리하고 적절한 이름을 짓는다면 함수들을 이용해 줄일 수 있다.
					ㄴ 추상화의 수준이 같아야 한다.?????
						ㄴ
					ㄴ 인수가 적을 수록 좋다?????
						ㄴ 인수는 코드를 이해하기 어렵게 만든다?????
							ㄴ 순서
							ㄴ 출력인수(인자로 받은 값을 반환하는 것)는 함수를 이해하는 데 어려움을 준다.
						ㄴ 인수가 많을 수록 테스트 하기 어렵다.
						ㄴ 최대한 인수를 줄이거나 객체를 만들어 넘기거나
					ㄴ 반복하지 마라.
						ㄴ 코드가 길어져 이해하기 어려워지고, 똑같은 것을 여러번 고쳐야 하므로 수정에 드는 시간과 버그 가능성이 늘어난다.
					ㄴ 일단 코딩하고 리펙토링 하는 것..?????
					ㄴ 예제 최종 수정본(목록3-7)
						ㄴ 길게 늘여쓸 코드를 이런식으로 위 원칙들대로 함수화하여 코딩하는 것.
						ㄴ 확실히, 길게 늘여쓰고 추상화의 단계가 뒤섞여 있는 것보다는 로직을 파악하기 쉬울 것 같다.
						ㄴ 함수들이 너무 많은 게 개인적으로 불편하긴 하다.
						ㄴ 오로지 가독성을 위해서 이렇게까지 해야 하나 싶기도 하다. 재사용성도 한두개 얻어 걸릴 수는 있어도 딱히 좋을 것
							같지는 않다.
							가독성만을 위해 길게 늘여쓸 코드들을 부분 부분 떼어내어 함수로 만들고 이름을 붙인 느낌이다. 물론, 가독성
							측면에서는 좋은 것 같다.
							ㄴ 의존성 측면에서는?
								ㄴ 그 수행하는 한가지 일을 담당하는 부분만 수정하면 되므로 더 좋은가..??
							ㄴ 재사용하지 않을 함수가 저렇게 쭉 나열되어 있으면 가독성이 오히려 더 떨어질 것 같은데, 이함수 저함수
								돌아다니며 로직을 파악해야 하고.
								차라리 단순명료한 로직과 변수명에 신경써서 한눈에 볼 수 있게 하는 게 낫지 않을까.
							ㄴ 재사용성, 모듈화에 딱히 좋을 것 같지가 않다..?

				</pre>
				ㄴ 주석 <button>more</button>
				<pre>
					ㄴ 주석은 코드를 제대로 작성을 못 했을 때, 이를 보완하기 위해 쓰게 되는 것.
						즉, 코드가 알아먹기 어렵고 지저분해서 설명을 덧붙이는 것이고, 따라서 지양해야 하는 것이라고 한다.
						주석을 달 바에 코드를 다시 짜라고 한다.
					ㄴ 주석은 유지보수하기가 힘들다. 개발자가 주석까지 유지보수를 할 것이라 기대하기는 어렵다.
						따라서, 시간이 지날 수록 주석은 해당 코드와 동떨어지게 된다.
					ㄴ ~~~~~
				</pre>
				ㄴ 형식 맞추기
					ㄴ ~~~~~
				ㄴ 객체와 자료구조<button>more</button>
				<pre>
					ㄴ
				</pre>
				ㄴ 오류 처리<button>more</button>
				<pre>
					ㄴ ~~~~~
					ㄴ null을 반환하지 마라
						ㄴ null 체크가 필요해지고 이는 코드를 지저분하게 만든다.
				</pre>
				ㄴ 단위 테스트<button>more</button>
				<pre>
					ㄴ
				</pre>
				ㄴ 클래스<button>more</button>
				<pre>
					ㄴ 객체지향에 대해 더 공부하고 보는 게 좋을 것 같다.
				</pre>
				ㄴ 시스템<button>more</button>
				<pre>
					ㄴ 프로그램의 전체적인 시스템 수준에서도 깨끗한 코드를 유지하는 것에 관해 다룬다.
					ㄴ 시스템 제작과 사용을 분리하라
						ㄴ 시스템 제작이란 프로그램에서 사용될 객체들의 생성과 초기화?를 말 하는 듯하고
							시스템 사용이란 이러한 객체들을 사용하여 프로그램의 로직이 실제로 돌아가는 것을 말하는 듯 하다.
						ㄴ ex)
							public Service getSerivce(){
								if(service==null){
									service = new ServiceImpl( ~~~~~ );
								}
								return service
							ㄴ 위와 같이 함수 안에 객체 생성 로직(시스템 제작 로직)과 service를 반환하는 로직(시스템 사용 로직)이 섞이게 하지 말라함.
						ㄴ 이를 분리하기 위한 방법 : main 분리
							ㄴ main이나 main에서 호출하는 곳에서 시스템 제작과 관련한 로직을 모두 처리하는 것.
								ㄴ 즉, main부분에서 사용할 객체들을 모두 생성해 놓고 런타임 로직에서는 이를 사용하기만 하는 것.
						ㄴ 분리하기 위한 방법2 : 추상 팩토리 패턴?????
							ㄴ
						ㄴ 분리하기 위한 방법3 : 의존성 주입?????

				</pre>
			</pre>

			ㅡ 리책터링 2판, 마틴 파울러<button>more</button>
			<pre>
				ㄴ 리펙터링이란 )
                    ㄴ '설계를 하고 코딩'을 하는 것이 아닌,
                        '코딩을 하고 설계를 개선하는 것'을 말함.
				ㄴ 무제 <button>more</button>
				<pre>
					ㄴ 리팩터링의 첫 단계는 코드를 수정한 뒤에도 동작에 이상이 없음을 보장해 줄 테스트 코드들 작성.
						ㄴ 테스트를 작성하는 데 시간이 할애되지만 크만큼 디버깅 시간이 줄어든다.
						ㄴ 한가지 수정시마다 테스트하면, 변경 폭이 작아 문제를 찾고 해결하기 쉽다.
						ㄴ 이렇게 조금씩 변경하고, 매번 테스트 하는 것.
					ㄴ 함수로 추출하여 리펙토링 할 때, 클래스의 멤버 변수가 아닌데도, 해당 범위에서 접근 가능한 지역 변수들을
						함수 내에서 멤버 변수처럼 접근하여 사용하고 수정하는 방식은 buggy한 것 같다.
						ㄴ 해당 범위 어디서나 접근하고 수정할 수 있는 지역 변수가 함수의 반환값 대입 같은 것도 안 했는데 갑자기
							바뀌어 버려 예측하기 어렵다.
					ㄴ 리펙토링 과정에서 반복문 등과 관련된 부분을 수정하며 성능에 문제가 될까 염려하는 경우.
						ㄴ 미미한 부분들은 큰 영향이 없으니 그냥 가독성을 우선하는 게 좋다.
						ㄴ 성능 이슈가 나오더라도, 리펙토링이 되어 있어야 수정하기 쉽다.
				</pre>


			</pre>

			ㅡ 무제 <button>more</button>
			<pre>
				ㄴ 주석도 필요 없을 정도로, 보면 이해 할 수 있는 로직과 모양새가 깔끔하고 단순한 코드?
					ㄴ 이를 위해선 변수 명이 보면 바로 이해가 가야 한다.
					ㄴ 적절한 값을 적절한 네이밍으로 변수화가 필요하기도 하다.
				ㄴ 중복되는 로직, 한 부분에서 코드가 너무 길어지는 경우 등은 모듈화.
				ㄴ 약어를 지양하라.
					ㄴ 이름 길어지는 게 싫기는 하겠지만, 의미 전달이 어렵다.
					ㄴ 당장 작성할 때야 알겠지만 나중에 쉽게 알 수 있을까?
				ㄴ 코드에 신경써야 하는 이유는.. 가독성, buggy, 수정 때문?
					ㄴ 가독성은 buggy와 수정에서 중요한 요소이고?
				ㄴ 겹치는 부분들이 있기는 하지만 코드에 신경써야 하는 이유는 세 가지 정도 있는 것 같다.
					코드 파악, 수정에 용이, buggy
					ㄴ 변수명, 깔끔하고 명쾌한 로직, 함수화, 중복 제거 등은 코드를 쉽게 파악하기 위해서
					ㄴ 의존성, 즉, 코드들을 잘 분리해 두는 것은 수정에 용이하기 위해서
					ㄴ 위 두가지가 모두 buggy한 것과 관련이 있고,
				ㄴ 충분한 고려 없이 그냥 막, 돌아가게만 만든 코드와 그렇지 않은 코드.
				ㄴ 기본적인 배경 지식이 있다고 가정하고 내용을 진행해 나가는 것 같다. TDD나 몇 가지 디자인 패턴이나, 객체지향, 등등.
			</pre>
		</pre>

		소프트웨어 테스트<button>more</button>
		<pre>
			ㅡ ~~~~~

            ㅇ test case
                ㅡ 하나의 테스트를 정의하는 명세. 입력값, 조건, 테스트 절차, 예상 결과값 등을 포함.

            ㅇ 방법<button>more</button>
            <pre>
                ㅡ ~~~
                ㅡ test automation (테스트 자동화)<button>more</button>
                <pre>
                    ㄴ 테스트 대상 소프트웨어와 분리된 다른 소프트웨어를 사용하여
                        테스트를 진행을 제어하고 테스트 결과를 예상 결과와 비교하는 것.
                    ㄴ 반복적이고 필수적인 테스트를 자동화 할 수 있다.
                    ㄴ 수작업으로 하기 어려운 테스트를 수행할 수 있다.
                    ㄴ 결국, 가장 큰 장점은 빠르고 힘 안들이고 테스트를 할 수 있다는 것?
                        ㄴ 테스트할게 많고 자주 할수록 효과 큼?
                        ㄴ 소프트웨어가 크고 복잡할 수록 수정에 따라 어떤 부분에 영향이 있을지 확인할게 많으므로 효과 큼?
                        ㄴ 개발 시간 증가라는 확실하고 작지 않은 단점이 있으므로 효과를 고려해서 가성비를 따져봐야함?
                    ㄴ 'Continuous delivery(CD)'와 'continuout testing'에 있어서 필수적이다.
                        ㄴ Continuous delivery란
                            ㄴ 짧은 소프트웨어 싸이클로 소프트웨어가 항상 안정적으로 릴리즈 가능하도록 하는 소프트웨어 엔지니어링 방식.
                            ㄴ 빠른 속도와 짧은 주기로 빌드, 테스트, 릴리스하는 소프트웨어를 지향.
                            ㄴ 변경사항 릴리즈의 비용, 시간, 리스크를 줄여 프로덕션 프로그램에 더 많은 업데이트를 가능하게 한다.
                            ㄴ Continuous deployment
                                ㄴ continuous delivery와 유사한 개념.
                                ㄴ 동일하게 소프트웨어를 언제든지 릴리즈 가능하도록 하는 엔지니어링 방식이지만,
                                    continuous delivery와 다르게 continuous deployment는 자동화된 배포를 통하여 프로덕션에 릴리즈.
                                    continuous delivery는 수동으로 릴리즈.
                                ㄴ continuous deployment를 위해선 continuous delivery가 우선 필요하다 할 수 있다.
                        ㄴ Continuous testing
                            ㄴ
                    ㄴ 방법들 )
                        ㄴ 테스트 자동화를 하기 위한 여러가지 접근법 존재.
                        ㄴ graphical user interface testing
                            ㄴ 테스트 프레임워크를 사용하여 사용자 인터페이스에서의 이벤트를 발생시키고,
                                사용자 인터페이스 상에서의 변화를 확인하여 테스트하는 방식.
                            ㄴ 액션을 기록하고 반복하여 자동 재생함으로서 테스트하는 방식.
                            ㄴ 소프트웨어 개발이 거의 필요치 않다.
                            ㄴ GUI를 가지는 어떤 프로그램이라도 적용될 수 있다.
                            ㄴ 안정성, 유지보수 관점에서의 문제.
                                ㄴ GUI상의 변경시 기록 재설정 필요.
                                ㄴ 관련없거나 잘못된 기록 및 재생 동작.
                            ㄴ ex ) auto-hotkey
                            ㄴ web testing에 있어서 변형 도구 )
                                ㄴ web 페이지를 테스트하는 경우를 위한 GUI testing의 변형판 도구들이 있다.
                                ㄴ 이 경우 interface란 web page가 되며.
                                ㄴ ??? html과 DOM event를 활용하기 때문에 기술적으로 약간 다르다?
                                ㄴ ex ) Headless browsers, Selenium Web Driver
                            ㄴ 모바일 어플에 대한 변형 도구도 존재.
                                ㄴ 모바일에서의 다양한 해상도, 크기, os에 대해 테스트하기 유용하다.
                        ㄴ API driven testing
                            ㄴ ???유저 인터페이스가 아닌 프로그램 상에서의 인터페이스를 사용하여 테스트.
                                프로그램상에서의 인터페이스란
                            ㄴ GUI 구현체와 독립적으로 수행될 수 있다.
                                ㄴ GUI 구현체가 준비가 안 되어 있어도 개발단계에서 실행할 수 있는 장점.
                                ㄴ 코드가 좀 더 클린하게 되는 경향이 있다.
                            ㄴ API가 프로그램 로직의 주요 인터페이스인 경우 특히 더 중요하게 여겨진다.
                    ㄴ ??? 중요한 결정 사항들?
                    ㄴ unit test의 테스트 자동화는 TDD로 알려진 'extreme programming', 'agile software development'의 핵심이다.
                    ㄴ 장기간 유지보수되는 제품에 대한 회귀테스트에 효과가 좋다.
                        ㄴ 아무리 작은 변경사항이라도 이전에 동작하던 기능에 문제를 일으킬 수 있으므로.
                    ㄴ 자동화된 테스트를 많이 쓸수록 그 가치가 커진다 할 수 있다.
                        ㄴ 따라서, 프로그램에서 항상 쓰이는 공통적인 부분에 대해 자동화 테스트를 작성하는 것이 효율이 좋다.
                    ㄴ 테스트 레벨별 자동화할 테스트 숫자 결정
                        ㄴ test automation pyramid에 따라 테스트 레벨별로 자동화할 테스트의 숫자가 결정된다함.
                            <img src="image/test_automation_pyramid.png"/>
                        ㄴ unit test를 가장 많이 자동화하고 ui test를 가장 적게 만든다.
                            ui의 경우 자동화 테스트 적용이 더 어렵기 때문. 작은 변화에도 많은 자동화 테스트가 수정이 필요하여 유지보수 비용 큼.
                    ㄴ ~~~
                </pre>

                ㅡ ~~~

            </pre>

            ㅇ Unit test<button>more</button>
            <pre>
                ㅡ 프로그램의 특정 부분(unit)이 의도된 설계대로 동작하는지 확인하기 위해 개발자에 의해 작성된 'test automation'를 의미.
                ㅡ ~~~
                ㅡ 장점 )
                    ㄴ 빠른 버그 확인.
                        ㄴ 코드를 실행한 뒤에 버그를 확인하고 찾고 고치는 비용보다
                            개발 단계에서 정확히 어떤 케이스가 문제가 있는지 확인하여 고치는 비용이 훨씬 싸다.
                    ㄴ 버그에 대한 보험.
                        ㄴ 개발단계에서 유닛 단위로 테스트를 진행함으로서 실서비스 단계에서의 버그 발생을 줄여주는 보험이 된다.
                        ㄴ 또한 당연히 유저단에서 버그가 확인되는 것은 단순히 픽스 비용 문제보다 큰 문제이다.
                    ㄴ 일종의 문서로서의 역할 가능.
                        ㄴ 단위 테스트를 보면서 unit의 대략적인 기능, 사용법 등 확인 가능.
                ㅡ 한계 및 단점 )
                    ㄴ 유닛 단위로 테스트 되기 위하여 개발시 코드 구조에 신경써야 한다.
                    ㄴ 'unit' 단위로 인한 한계점
                        ㄴ unit단위에 대해선 테스트 되지만, 시스템 전체에 대해 오류가 없음을 보장하지 않음.
                            다른 unit들과 함께 동작해야하는 통합 테스트나 성능 테스트에 대해 제약.
                    ㄴ 테스트 코드로 테스트하기 어려운 문제들 존재.
                        ㄴ ex ) '비결정적 알고리즘'에 대한 테스트, 멀티 스레드 관련 테스트 등.
                            ㄴ '비결정적 알고리즘'(nondeterministic)이란, 같은 인풋값에 대해서 매번 실행시마다 실행 내용이 달라지는 알고리즘?
                    ㄴ 개발 시간 증가.
                        ㄴ 하나의 동작에 대한 케이스별 테스트 코드 작성을 위해 2배 이상의 코드 작성이 필요한 경우 많음.
                    ㄴ 테스트 코드 자체 버그 가능성.
                        ㄴ 코드의 버그를 테스트하기 위한 테스트 코드 작성 중에도 버그가 있을 수 있기 때문에
                            완벽하게 장담하기 힘들다.
                    ㄴ ??? 테스트할 명확한 조건들 필요?
                        ㄴ 이러한 조건들이 없으면 테스트 코드가 실질적으로 도움되지 않을 것.
                    ㄴ ??? 적용을 위한 개발 과정에서의 엄격한 절차 필요
                        ㄴ 수행된 테스트, 소스 코드에 대한 변경사항 기록 필요.
                        ㄴ 버전컨트롤 시스템 사용 필요. 테스트 실패시 버전컨트롤 시스템의 히스토리를 통하여 변경점 확인.
                    ㄴ 단순히 인풋, 아웃풋이 있는 유닛이면 테스트하기 쉬우나, 외부 프로그램과 상호작용하는 경우 테스트 코드 작성이
                        까다로울 수 있음.
                        ㄴ ex ) http request 요청에 대한 테스트, db와 상호작용하는 테스트.
            </pre>

            ㅇ Integration testing (통합 테스트)
                ㅡ

			ㅡ TDD, 켄트 벡<button>more</button>
			<pre>
				ㄴ ~~~~~
				ㄴ TDD란? 개요 )
					ㄴ TDD, Test-Driven Development
						방식이 (자동화된) 테스트를 중심으로 개발을 해 나가는 방법이어서 이렇게 이름 붙었다.
					ㄴ 대략적인 방식은,
						자동화된 테스트를 작성하고,
						이 테스트를 통과하도록 코드를 작성하고,
						작성한 코드로 테스트 통과 후 리펙토링을 하는 것.
						위 세 단계가 한 싸이클로, 이를 반복하면서 개발해 나가는 방식이다.

				ㄴ 무제<button>more</button>
				<pre>
					ㄴ 모든 작업을 작은 단위로 나눈다.
						해당 작업에 대한 적절한 자동화된 테스트를 준비한다.
						개발
						테스트
						리펙토링
					ㄴ TDD도 배우지만, 테스트 코드에 대한 것들도 배우고 사실상 이게 주된 목적이다.
					ㄴ 자동화된 테스트의 장점
						ㄴ 테스트가 수월해져, 수정이 수월해 진다.
					ㄴ 테스트는 서로 독립적인 게 좋다.
						ㄴ 다른 테스트에 영향을 받을 시 당연히 해당 기능을 제대로 테스트 할 수 없다.
					ㄴ 단위 테스트 위주로 개발하면 생기는 장점.
						ㄴ 테스트 단위로 적절하기 구성하기 위해, 작성하는 코드가 응집도가 높아지고 의존성이 낮아진다.
					ㄴ 모든 해야 하는 기능에 대한 테스트 케이스를 적고 이에 대한 리펙토링을 적는다.
						개발 중간에 생각난 테스트 케이스나 리펙토링도 할 일 목록에 추가한다.
					ㄴ 테스트 작성시, assert를 먼저 작성하라.
						ㄴ 시스템 개발시, 그 시스템이 어떨 것이라는 것부터 만들고 시작하고,
							특정 기능 개발시, 그 기능이 완료되면 통과할 테스트부터 작성하듯이,
							테스트 개발시, 완료되면 통과할 assert부터 작성하라고 한다.

				</pre>
			</pre>

		</pre>

		Window<button>more</button>
		<pre>
			ㄴ 작업 스케줄러<button>more</button>
			<pre>
				ㄴ 작업 만들기<button>more</button>
				<pre>
					ㄴ ~~~~~
					ㄴ 트리거<button>more</button>
					<pre>
						ㄴ ~~~~~
						ㄴ 고급 설정<button>more</button>
						<pre>
							ㄴ 작업이 지연되는 최대 시간(임의지연) : 가령, 30분 설정 시, 시작 시간이 3:00이면, 3:00~3:30 사이에
																랜덤한 시간에 작업 시작.
							ㄴ
						</pre>

					</pre>

					ㄴ 조건<button>more</button>
					<pre>
						ㄴ 유휴 상태(Idle)
							ㄴ 유휴 상태란, 컴퓨터를 사용하고 있지 않아 아무 것도 안 하는 상태. screensaver가 동작 중이거나 cpu 사용량이
								0% 이하이면 해당.
							ㄴ 특정 시간 이상 유휴 상태일 때만 작업 실행하도록 설정.
						ㄴ 전원
							ㄴ AC전원 어쩌구는 노트북인 경우, 베터리, 전원 연결과 관련된 설정.
							ㄴ

					</pre>

					ㄴ 설정<button>more</button>
					<pre>
						ㄴ 요청 시 작업이 실행되도록 허용 : 작업 스케줄러 메인 창에서 우클릭-실행 클릭 시, 작업이 실행되게 할 건지 여부 설정.


					</pre>

				</pre>
			</pre>
			ㅡ
		</pre>

        software design (소프트웨어 설계)
            ㅡ ???
            ㅡ ??? 개념화, 프레이밍, 구현, 위임, 시스템을 수정하는 것과 관련된 모든 활동?
                또는 요구사항을 따르거나 프로그래밍하기 전 양식화된 소프트웨어 엔지니어링 절차를 의미?
            ㅡ ???
            ㅡ ??? 하나 이상의 문제들에 대해 소프트웨어 솔루션을 구상하고 정의하는 과정?
            ㅡ 주요 설계 요소 중 하나는 '요구사항 분석'.
            ㅡ 분석과 설계 차이
                ㄴ ??? 분석의 결과는 해결해야할 작은 문제들로 구성되어 있다?
                ㄴ ??? 분석은 멤버나 그룹이 달라도 큰 차이가 없어야 한다?
                ㄴ ??? 설계는 같은 문제에 대해서도 여러개의 설계가 존재할 수 있다?
            ㅡ ~~~
            ㅡ design 개념
                ㄴ ??? 설계자가 더 정교한 방법을 적용할 수 있게 해주는 기반이 된다?
                ㄴ 목록 )
                    ㄴ abstraction
                        ㄴ
            ㅡ 설계시 고려사항
                ㄴ
            ㅡ 모델링 언어
                ㄴ
            ㅡ 디자인 패턴
                ㄴ 과거 마주한적이 있거나 다른 사람들에 의해 해결된 설계시의 문제가 있다.
                    이러한 흔한 문제에 대한 솔루션을 나타내는 템플릿 또는 패턴을 '디자인 패턴'이라 한다.

        UML diagram
            ㄴ software engineering에서, 시스템의 설계를 시각화하는 표준을 제공하기 위해 만들어진 범용, 개발 modeling language.
                즉, 소프트웨어 만들 때, 설계를 도식으로 만들어 눈으로 보기 좋게하는데, 이 도식화 방법에 대한 표준.
                ㄴ modeling language : 일관된 규칙대로 정보, 시스템 등을 표현하는데 사용되는 만들어진 인공 언어.
                ㄴ 당연히, 소프트웨어 설계에 대한 서로 다른 표기법, 접근법 등을 표준화하려고 등장했다.
            ㄴ 1997에 OMG(Object Management Group)에 의해 표준으로 채택되고 지금까지 계속 관리중.
                2005, ISO(International Organization for Standardization)에 의해 표준 채택 후 계속 관리 중.
            ㄴ 실무 사용
                ㄴ 대부분의 실무자들은 UML을 사용하지 않으나, 이와 유사한 그냥 손으로 그린 다이어그램을 사용한다.
                ㄴ 대충 시간이 없어 비스무리한 것을 그려놓거나 머릿 속에만 가지고 있거나,
                    대규모 플젝 등 체계가 잡혀있는 곳에선 기획, 설계단에서 만든다?
            ㄴ ~~~
            ㄴ 분류 )
                ㄴ UML diagram은 여러 방식으로 시스템을 표현한다. 크게 두 분류로 나눌 수 있다.
                ㄴ 정적, 구조적 UML diagram (static, structural)
                    ㄴ 시스템의 정적인 구조에 포커스를 둔 표현 방식.
                    ㄴ ex ) Class diagram, Component diagram, Composite structure diagram,
                        Deployment diagram, Object diagram, Package diagram, Profile diagram
                ㄴ 동적, 행위적 UML diagram (dynamic, behavioral)
                    ㄴ 시스템의 동적인 행위에 포커스를 둔 표현 방식.
                    ㄴ ex ) Activity diagram, Communication diagram, Interaction overview diagram,
                        Sequence diagram, State diagram, Use case diagram, Timing diagram
                    ㄴ Use case diagram )
                        ㄴ 동적 모델링의 핵심 중 하나.
                        ㄴ 시스템의 요구 사항, 즉, 시스템이 무엇을 해야 하는지를 표현하는데 사용된다.
                        ㄴ ~~~
                    ㄴ ~~~
            ㄴ ~~~


		디자인 패턴<button>more</button>
		<pre>
			ㅡ 헤드퍼스트 '디자인 패턴' 공부 예정이었으나,
				이 책뿐만 아니라 디자인 패턴에 대한 대부분의 내용이 '객체지향' 관련 내용이라,
				객체지향에 대해 먼저 공부하고 디자인 패턴에 대해 공부하기로함.
		</pre>

		객체지향<button>more</button>
		<pre>
			ㅡ '객체지향의 사실과 오해' 책 참고
			ㅡ '객체지향이란 실세계를 모델링할 수 있는 패러다임'?
				ㄴ 객체지향에 대한 설명 중 실세계의 대상을 객체화 시켜서 사용한다는 것들이 있는데 이는 적합하지 않은 면이 있다고 한다.
					ㄴ 실제 실무에서 실세계의 대상과 연결지을만한 객체가 많지 않을 것이기 때문에.
				ㄴ 그러나 실용적인 부분에선 적합하지 않을지 몰라도 객체지향의 이론을 이해하는데는 효용성이 크다한다.
					ㄴ ~~~
			ㅡ 역할, 책임, 협력
				ㄴ ex ) 커피를 주문하고, 주문을 받고 커피를 만들고 고객에게 전달하는 과정.
						고객, 캐시어, 바리스타. 역할.
						각자가 해야 할 일을 수행. 책임.
						이들이 서로 '요청'과 응답을 하며 과정이 이루어진다. 협력.
				ㄴ 역할을 맡는 사람이 '객체', 이들 간의 요청이 '메시지', 이들의 책임 수행이 '메소드'에 해당.
				ㄴ ???여러 사람이 동일한 역할을 수행할 수 있다???
				ㄴ 역할은 대체 가능하다.
					ㄴ 그 사람이 필요한 역할을 맡고 있다면 누구라도 상관 없다는 것.
				ㄴ 책임 수행 방법은 자율 선택 가능하다
					ㄴ 요청을 받을 사람은 그 요청의 수행 방법을 자유롭게 선택 가능하다. 다형성.
				ㄴ 한 사람이 동시에 여러 역할 수행 가능.
					ㄴ
				ㄴ 객체
					ㄴ 필요 성질
						ㄴ 협력적
							ㄴ ???
						ㄴ 자율적
							ㄴ ???
							ㄴ 객체의 내부와 외부를 명확히 구분하는 것으로 결정된다???
					ㄴ 객체는 외부에서 그 객체가 '무엇을' 하는지는 알아도 '어떻게' 하는지는 모르게 해야한다.
				ㄴ 메시지
					ㄴ 한 객체가 다른 객체에게 요청을 하는 것을 메시지를 보낸다고한다.
				ㄴ ??? 왜 이런 패턴으로 프로그램을 구성하는가? 왜 객체지향 방식인가? 이점이 뭔가?
			ㅡ 객체지향으로 설계된 프로그램은 이런 객체들의 연쇄적인 요청과 응답을 통해 구성된다.?
			ㅡ 객체지향이란?
				ㄴ 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고
			ㅡ 클래스 중심이 아닌 객체와 이들의 협력관계를 중심으로 객체지향을 생각해야 한다?
			ㅡ 객체지향은 인간이 기본적으로 세상을 인지하는 방식과 유사하기 떄문에 직관적이고 이해가 쉽다?


			ㅡ 객체지향과 ORM?
				ㄴ ORM의 객체들은 (가령 Entity) 데이터 조회라는 '행동'을 기본적으로 가지고 있다 할 수 있나?
					당연히 그 외 추가적인 행동의 책임이 있을 수 있고.
		</pre>

        ProtonVpn<button>more</button>
        <pre>
            ㅡ centos7에 protonvpn 설치
                ㄴ protonvpn-cli이용
                ㄴ ~~~
                ㄴ KeyError 'resolvconf_hash' 나는 경우
                    ㄴ ~/.pvpn-cli/resolv.conf.backup 파일 삭제 후, protonvpn-cli 재설치, 실행.
                ㄴ domain leak protection이라 하여,
                    ㄴ protonvpn설치히 사용하는 domainname 서버를 protonvpn에서 제공하는 서버로 변경한다.
                        ㄴ /etc/resolv.conf 파일이 수정되며, protonvpn어쩌구하는 내용이 들어간다.
                    ㄴ 문제는 이렇게 변경되면 google, naver 등을 도메인으로 들어가지지 않는다. 추가 설정이 필요한 것인지..
                    ㄴ 일단 기존 domain name server로 수정해줌.
        </pre>



	</pre>

	<br>기타<button>더보기</button>
	<pre>
		기타<button>더보기</button>
		<pre>

            ㅡ Emulator
                ㄴ 어떤 컴퓨터 시스템(host라 부른다)이 다른 컴퓨터 시스템(guest라 부른다)처럼 행동할 수 있게 해주는 하드웨어나 소프트웨어를 지칭.
                ㄴ 일반적으로, 특정 소프트웨어를 실행할 수 있게 해주거나, guest 시스템을 위해 설계된 장치를 사용할 수 있게 해준다.
            ㅡ Archive file
                ㄴ 그냥 파일. 파일인데, 메타데이터와 하나 이상의 파일로 구성된 파일을 지칭하는 말.
                    여러개의 파일들을 휴대성과 저장의 편리함을 위해 한 파일로 모으거나 압축하기 위해 사용된다.
                ㄴ ex ) jar, zip,
                ㄴ 소프트웨어 배포를 위한 패키징에도 자주 사용된다. 이런 경우, '패키지'라고도 불린다.
                    archive format은 동일하되, 관례에 따라 몇가지 파일들이 추가되며 이런 format을'package format'이라 부른다.
                    ㄴ ex ) java의 JAR, Debian의 deb, Android의 APK

			*Cookie란?
		                ㅡ개요) 서버에서 브라우저로 작은 크기의 정보를 보내는 기술을 말하며, 정보는
		                  브라우저쪽에 저장된다.
		                ㅡ개요) session 기술과 유사하게 클라이언트와 서버간 연결유지기능을 한다
		                ㅡ특징) 쿠키 객체는 이름, 값, ㄱ 외 추가적인 속성값들을 가질 수 있으며
		                  response.addCookie()를 통해 브라우저로 전송되게 된다
		                ㅡ쿠키의 개수느 ㄴ약 20개개정도 크기는 4Kb정도이다
		                ㅡ이후 브라우저가 서버로 요청을 보낼때 쿠키정보를 같이 보내게 된다
		                ㅡ쿠키 메소드)
		                    new Cookie("--이름--", "--값--")
			*디렉토리 구조?
	       		ㅡ 이클립스에서 동적 웹프로젝트를 만들면 자동으로 디렉토리 구조가 형성되는데 실무에서는 그 구조를 잘 안쓴다고함.
	       		ㅡ 이유는 IDE마다 이 디렉토리구조가 다른데 때문에 데이터를 주고받을때 불편하다함.
	       		ㅡ 그래서 전세계적으로 쓰이는 구조인 Maven(메이븐)구조를 사용한다고한다.
			ㅡ 코딩이 좀만 길어지고 복잡해지니까 가독성좋고 간단,심플,깔끔한 코드의 중요성을 조금 알것같다. 돌아가기만하는데 집중하여 이상한 기교부려가며 코딩하면
				돌아가는건둘째치고 내가알아보기도힘들어서 어디서 오류가났는지, 어떻게 돌아가는지, 어디를 수정해야하는지 모르겟다.
			ㅡ 오류찾기 팁)
				ㄴ 오류내용을 그대로 구글링하는게 좀빠른듯.
			ㅡ MIME 타입)
				ㄴ 웹상에서 텍스트 뿐만 아니라 다른 이미지, 오디오등의 바이너리 파일을 전송하기 위해 파일을 텍스트형식으로 변환(인코딩)하여 송신하고
					인코딩된 파일을 다시 바이너리로 변환(디코딩)하는데 쓰이는 포멧, 형식을  말한다.
			ㅡ 동기적 vs 비동기적)
				ㄴ 동기적 : 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다린 후 다음(다른) 작업을 수행하는 방식
				ㄴ 비동기적(Asynchronous) : 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다리지 않고 다른 작업을 하고 있다가, 요청했던 작업이
					종료되면 그에 대한 추가 작업을 수행하는 방식

			ㅡ 동기 함수, 비동기 함수)
				ㄴ 동기함수 : 함수 호출부분에서 호출결과가 리턴될때까지 기다려야하는 함수로, 보통 사용하는 대부분의 함수라고 생각하면된다.
				ㄴ 비동기함수 : 호출부에서 실행결과를 기다리지 않아도 되는 함수.
					ex)	js의 setTimeout( (*콜백함수*), (*시간*))메소드. 이 함수실행시, (*시간*)만큼의 시간이 흐른뒤 (*콜백함수*)를
						실행한다. (*시간*)을 기다리는동안 이 호출부에서 계속기다리는게 아니라 다른 작업을 수행한다.
					ㄴ 자바스크립트에서 특히 자주쓰이며, 이런 비동기함수를 많이써야하는 상황에서 콜백함수들이 여러개가 중첩되어 가독성이 심각하게
						안좋아지는 '콜백지옥' 현상이 생긴다고한다. (이에 대한 해결책이 Promise객체)
			ㅡ 공부자료 tip)
				ㄴ MDN페이지에서 설명해주는 페이지들 맨 아래쪽에보면 'Specifications'항목에 'specification'아래에 해당 내용에 관련된 API나
					객체이름을 클릭하면 그 API나 객체의 스펙을 아주 자세히 알려주는 페이지가 나온다.
			ㅡ 자바스크립트 코딩)
				ㄴ 이유는 모르겟지만 js코드를 이클립스에서 돌리면 콘솔창으로 출력한 내용이 어디로 나오는지도모르겟고 오류목록도 잘 안뜨는듯하다.
					해서 자바스크립트는 코딩만 이클립스로하고 실행결과를볼때는 크롬에서 톰켓url로 입력하여 실행하는 방식으로 하자.
			ㅡ 웹 동작 과정)
				ㄴ 웹 페이지는 서버단에서 java, jsp, jstl등이 실행되고 파싱된 페이지가 브라우저로 전달되어 브라우저에서  html,css, js가 파싱되고 실행되는 순서.
				ㄴ 따라서 js의 스크립트 부분안에 jstl등을 넣어도 서버단에서 먼저 처리되긴하므로 사용 '가능'하기는 하다. (순서를 잘고려해 조심해서 코딩해야함)

			* 자바 annotation
				ㅡ 소스코드에 메타데이터를 표현하는게 본질이라함.
				ㅡ 문법)
					ㄴ 선언? : ex)	@(*annotation 이름*)  과 같은 형태로 사용한다. 컴파일러에게 이게 어노테이션임을 알린다.
						위치는 클래스, 인터페이스, 메소드, 메소드파라미터, 필드, 지역변수 위에 위치한다.
						ex)	@(*이름*)
							public class AAA{~~~}
					ㄴ 요소 : 어노테이션은 요소를 가질수있다. setAttribute()같은것.
						형태는 @(*어노테이션이름*)( (*요소이름1*) = " (*요소 값1*) ", (*요소이름2*) = " (*요소 값*) " )
						요소가 하나일경우 @(*어노테이션이름*)( " (*요소 값*) " ) 이렇게쓸수도잇다.

				ㅡ 기본적으로 제공하는 어노테이션)
					ㄴ @Deprecated : 해당 대상은 더이상지원하지않거나, 문제가있거나, 다른 더좋은게있으니 '사용하지 말라는 의미'. 사용하면 컴파일경고.
					ㄴ @Override : 대상이 슈퍼클래스에대해 오버라이드 되었다는걸 알려준다. 매칭되지 않는다면 오류를 날림.
					ㄴ @SuppressWarnings : 해당 메소드에 대해 컴파일러 경고메세지를 없애준다.
				ㅡ 메타 어노테이션)
					ㄴ 커스텀 어노테이션을 만드는데 쓰이는 기본어노테이션 이외의 어노테이션이라하마.
					ㄴ @Retention : 어노테이션 범위. 어떤시점까지 어노테이션이 영향을 미치는지 결정.
					ㄴ @Documented : 문서에도 어노테이션 정보를 표현.
					ㄴ @Target : 적용할 위치결정.
					ㄴ @Inherited : 이 어노테이션을 선언하면 자식클래스가 어노테이션을 상속받을수있음.
					ㄴ @Repeatable : 반복적으로 어노테이션을 선언할수있게함.
				ㅡ 커스텀 어노테이션)
					ㄴ ex)
				import java.lang.annotation.*;

				@Inherited
				@Documented
				@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능합니다.
				//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효합니다.
				//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 없어집니다.
				@Target({
				        ElementType.PACKAGE, // 패키지 선언시
				        ElementType.TYPE, // 타입 선언시
				        ElementType.CONSTRUCTOR, // 생성자 선언시
				        ElementType.FIELD, // 멤버 변수 선언시
				        ElementType.METHOD, // 메소드 선언시
				        ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시
				        ElementType.LOCAL_VARIABLE, // 지역 변수 선언시
				        ElementType.PARAMETER, // 매개 변수 선언시
				        ElementType.TYPE_PARAMETER, // 매개 변수 타입 선언시
				        ElementType.TYPE_USE // 타입 사용시
				})
				public @interface MyAnnotation {
				    /* enum 타입을 선언할 수 있습니다. */
				    public enum Quality {BAD, GOOD, VERYGOOD}
				    /* String은 기본 자료형은 아니지만 사용 가능합니다. */
				    String value();
				    /* 배열 형태로도 사용할 수 있습니다. */
				    int[] values();
				    /* enum 형태를 사용하는 방법입니다. */
				    Quality quality() default Quality.GOOD;
				}
					ㄴ @interface (*커스텀어노테이션 이름*){ ~~~(*내용*)~~~ } 형태로 만든다.
			ㅡ 애자일 설계 방법) (정확하지않음)
				ㄴ 이 방법이란건 일종의 큰 범위이고 이 안에 속하는 대표적 방법으로 '스크럼'이 있다고한다.
				ㄴ 폭포수모델이 경직적인 단점을 해결하려고 나온 방법같으며
				ㄴ 짧은 개발주기를 반복적으로 하는게 특징인것 같다. (프로토타입을 여러번 만든다고 표현한다)
				ㄴ 한 주기안에서 요구사항, 명세, 구현 등 진행과정은 비슷한 듯 싶다.
			ㅇ 컴퓨터 작동의 원리
				ㅡ 컴퓨터 작동의 원리
				ㅡ 무엇이 컴퓨터를 컴퓨터로 만들까요?
					ㄴ 여러 종류가 있겠지만 모든 컴퓨터는 공통적인 네가지 단계를 가진다.
					ㄴ input, storage, processing, output
				ㅡ 이진수와 데이터
					ㄴ 컴퓨터는 전기신호를 통해서만 정보를 사용 할 수 있다.
					ㄴ 전기 신호는 전기가 통하는 전선에서 '켜짐'과 '꺼짐'을 이용하여 0,1로 표현이 가능하며 이것을 '비트'라고 한다.
					ㄴ 이 비트는 0,1 또는 참,거짓 또는 on,off 두가지밖에 표현하지 못하지만 이 비트가 무수히 많아질수록 표현가능한 정보의 종류는 많아진다.
					ㄴ 3비트가 있으면 8가지를 표현할 수 있고 이런식으로.
					ㄴ 이런 무수한 비트들의조합으로 글자, 이미지, 소리 등을 표현할 수 있다.
				ㅡ 회로와 논리
					ㄴ 컴퓨터가 이런 비트정보들로 processing을 하기 위해선 이 비트들을 변경하거나 합치는 등의 작업을 해야한다.
					ㄴ 이를 위해서 필요한 것이 '회로'이다.
					ㄴ 회로란 내가 알고있는 논리 회로를 말하며, XOR, AND연산 등을 해주는 회로를 말함.
					ㄴ 이러한 간단한 회로들을 복잡하게 연결하여 사칙연산과 같은 기능을 하는 회로를 만들수 있으며, 또 이 덧셈 회로를 복잡하게 연결하여
						곱셈연산을 하는 회로를 만들 수 도 있다.
					ㄴ 이런식으로 processing과정의 연산들은 이러한 간단한 연산들의 합이라고 볼 수 있다.
					ㄴ 이런 복잡한 회로, 연산을 통해 프로그램을 만드는것.
				ㅡ cpu, 메모리, 입출력
					ㄴ 위에서 말한 컴퓨터의 공통적인 네단계는 컴퓨터 안에서 각기 다른곳에서 발생한다함.
					ㄴ 데이터를 받거나 내보내거나 이진수로 변환해주는 io, 이 이진데이터를 저장하는 메모리, 이진데이터들을 연산하는 cpu.
			ㅡ 파일질라 )
				ㄴ sftp의 경우는 22번 포트, ftp의 경우는 21번포트로 연결을 시도하면 되는 듯하다.
				ㄴ 계정과 비번은 접속하려는 컴퓨터의 계정을 말하는 것.
					ㄴ 네이버클라우드플랫폼 서버의 경우, ssh연결할때 사용한 root계정을 쓰면되는듯하다. 이게 그컴퓨터의 계정이니까.
			ㅡ BSON <button>more</button>
			<pre>
				ㄴ JSON과 같은 데이터 변환 형태이다. Binary JSON의 약자.
				ㄴ '연관 배열'이나 정수 인덱스 배열과 같은 복잡한 데이터 structure나 단순 데이터를 바이너리 형태로 나타낸다.
			</pre>
            ㅡ 포팅, Porting
                ㄴ 원래 해당 소프트웨어가 실행되도록 고려된 환경이 아닌 다른 환경에서 실행시키기 위해 소프트웨어를 적용시키는 과정
                ㄴ 소프트웨어를 다시 처음부터 만드는 비용보다 소프트웨어를 새 플랫폼 환경으로 포팅하는 비용이 싸다면 그 소프트웨어는
                    'portable'하다 한다. 비용이 쌀 수록 더 '휴대성있다'한다.
            ㅡ ORM )
                ㄴ ??? 객체지향 프로그램에서는 주로 객체에 대해서 로직이 짜인다.
                    객체에 대한 정보를 db에 저장하려하면, 객체의 데이터를 원자화하여 sql로 작성하거나 sql로부터 가져온 원자 데이터를
                    객체로 만드는 등의 작업이 필요한데, 일일히 sql을 작성하여 작업해야 한다.
                    ORM은 객체지향 언어에 대해 적절한 api를 제공하여 sql없이 객체만 사용하여 이러한 작업을 할 수 있게 해준다???
                ㄴ persistent, 영속성
                    ㄴ 객체를 db에 원자화 하여 저장하고, db로부터 객체를 객체의 속성과 관계를 보존하면서 가져와 쓸 수 있을 때,
                        이 객체를 'persistent하다' 라고 한다.
                ㄴ sql 작성 관련 작업의 상당수를 간소화.
                    ㄴ '모두'는 아님.
                ㄴ 높은 추상화 수준으로 인한 러닝 커브.
                ㄴ ??? ORM 소프트웨어에 대한 의존성으로 인한 db 설계상의 문제.


		</pre>
		오류내용<button>더보기</button>
		<pre>
			ㅡRequestDispatcher의 forward()를 사용해 페이지를 넘기는게 안됨. 오류가뜨지도않고 그냥 페이지가 멈춤. 콘솔창에는
				ERR_INCOMPLETE_CHUNKED_ENCODING 200 라고뜨며, 인터넷에 처보면 해결책이 먼소린지모르겟음. 간단한 forward는 작동하나
				myBoard에서 문제발생함.

			ㅡa태그로 jsp페이지로 넘어가면 이유는 모르겟지만 스크립틀릿부분이 제대로 실행되지 않는경우가 있다. form을 이용해 넘겨주면 제대로 되긴함.
				이유는 잘모르겟음.

			ㅡ서버가 아예 시작이안되는 경우.  뭐가 중복된다고뜸.오른쪽 프록젝트 목록 다지우니까 됨. 같이컴파일비슷하게 되나봄.

			ㅡ 자바는 함수호출시 값의의한 호출만 지원. 객체도 복사된 참조값이 넘어가기때문에  해당객체의 내용을 바꿀수는 있지만 넘어간 함수안에서 참조값에 null을넣어봤자
				복사본의 참조자에 null을넣는것이므로 원본참조자에는 변동없음.

			ㅡ 서블릿을 어플리케이션의 시작으로 삼을때)
				ㄴ 그 서블릿이 제대로 동작하지않는 경우가 있는것같다. forward()가있었는데 이부분만 동작하고 그 위로는 다 처리되지않았다.

			ㅡ 외부 jar파일이나 라이브러리같은 파일을 추가하고나서 왼쪽탐색기에 추가한 내용이 표시되지않으면 인식이 안되는듯하다. refresh버튼 눌러서 추가되도록하거나
				톰켓 매니저페이지 들어가서 리로드하자.

			ㅡ 보안설정하려고 톰캣에서 "tomcat-users.xml"파일 에서 < role rolename~~~>등 설정하는데 이 파일에 대한 쓰기권한이 없다고한다.

			ㅡ 파일 경로에 한글이 포함되어 있으면 인식하지 못하는 오류가 가끔 있는 듯 하다.

			ㅡ  java.lang.IllegalArgumentException: 메소드 이름에 유효하지 않은 문자가 발견되었습니다. HTTP 메소드 이름은 유효한 토큰이어야 합니다.
				ㄴ 형식이 잘못된 http request로 인해 발생한다함.
				ㄴ 출처 ) https://stackoverrun.com/ko/q/11614574
				ㄴ 내 경우, request를 https에서 http로 변경하여 해결. 이유는 정확히 모르겠으나 이 오류가 https를 못쓰는데 https요청을 보낼때
					생긴다하여 바꿔봤는데 해결됨.
			ㅡ ajax 이용해서 파라미터 보낼시 받는 컨트롤러에서 한글이 깨지는 현상 )
				ㄴ 맨위에 jsp지시자로 아래와같이 설정해주는 문제느 ㄴ아니었고
					ㄴ <%@ page language="java" contentType="text/html; charset=UTF-8"  pageEncoding="UTF-8"%>
				ㄴ ajax사용시 post형태로 보내기위해 	httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); 를
					추가했는데 여기 맨뒤에 보이는것처럼 charset=UTF-8을 추가해주니 해결되었다.
			ㅡ
		</pre>
		팁<button>더보기</button>
		<pre>
			ㅡ 가장 먼저 스펠링 확인.
			ㅡ 디버깅 모드가 강력. 함수 하나하나 들어가서 살펴 볼 필요 없고(어차피 어려워서 모름), F6으로 넘기면서 값들 확인만으로도 버그찾기 수월.
			ㅡ 퓨어 자바스크립트와 제이쿼리와 같이, 확실히 만들어진 api가 쓰기는 좋지만 섬세한 작업이 필요할때와 커스터마이징이 필요할 때는 근간기술을 사용하는게 더 수월하기도 하다.
				ㄴ 자바로 웹페이지 만드는 거하고 wordpress로 만드려던것 생각해보자.
			ㅡ 되도록 영어로 검색하자. 더 많고 깊은정보가 나오는듯하다. 익숙해져야하기도하고.
			ㅡ 주석달기
				ㄴ 아무리깔끔하게 코딩하고 내가 몇일전에 짠 코드라 해도 다시보면 뭐가뭔지모르거나 헷갈림.
				ㄴ 코드가 아무리 쉽더라도 다시보면서 이해하는데 시간이 걸림. 지금 게시판도 이렇게 복잡하게 느껴지는데 실무의 만줄코드는 서로 얽히고 섥혀 얼마나 복잡할까. 그리고 이걸 아무정리없이 나중에 다시봐야한다고 생각해보자.
					이걸 언제 다시 이해하고있는가.
				ㄴ 성능 약간 좋아지는 것보다 코드 깔끔하고 주석 잘 정리해 두는게 훨씬 더 중요한 것 같다.
			ㅡ 역시 뭔가 처음써보는것을 사용할땐 튜토리얼을 한번쭉훑고 시작하는게 낫다. 여기서 모든걸 알수는 없겠지만 기본적이고 많이쓰이는 내용들은 대부분 담겨있고 구글링으로 검색해서 아는것보다 더깊은 지식이있는경우가 많다.
				기본적인것도 몰라서 삽질하는걸 막을 수도 있고.
			ㅡ 콘솔에 찍히는 예외 스택 트레이스 )
				ㄴ 말그대로 예외 스택 트레이스이므로 가장 밑단에서 예외발생하면 그걸 던지고 던지고 쭉 타고 내 코드부분까지 올라오는것.
		</pre>
		궁금증<button>더보기</button>
		<pre>
			ㅡㅇㅇ 이런 언어들, css,ajax, el 등등 이 어디서왔는지? 어떻게 동작하는지?(사용법말고 내부적으로), 그냥 언어로만들어진 프로그램의 일종이라면 뭘로 만들어졌는지?
				ㄴ 가령 css의 예를들면, computer language의 일종. 그중에서도 Style Sheet Language 의 일종이다.
				ㄴ c언어처럼 문법이 있고 이를 해석하는 컴파일러, 어셈블러, 로더가 있어 해당언어로 작성한 문서를 실행할수있게해주는.
				ㄴ 이것처럼 css도 css의 문법이 html같은 dom문서에서 display부분을 조작하도록 만들어진
				ㄴ 예상했던대로, c같은 언어 그 자체는 일종의 문법, rule이고 이를 컴파일러(어셈블러,로더)가 해석해서 실행가능한 파일로 만들어주는것.
					ㄴ 컴파일러 역시 c코드같은 문자데이터를 해석해주는 프로그램의 일종이고, 어떤언어로든 만들어졌겠지.
					ㄴ 컴파일된걸 어셈블러, 로더 등등의 과정을 거쳐 실행가능한 프로그램이 되는거고.
				ㄴ 그럼 어떤 프로그램이든, 뭐든 어떠한 언어로 만들어져 내부적으로 프로그램된 프로그램의 일종이라고 생각한다면, 굳이 그 내부적으로 어떻게 동작하는지 필요한게 아니면 알 필요가 없지않을까?
					ㄴ 모르긴몰라도 어차피 내가만들거나 다른 만들어진 프로그램들처럼, 똑같이 함수쓰고 알고리즘 만들어서 돌아가는 프로그램일 테니까.
					ㄴ 네트워크, 스레드, 프로세스, 이런 컴구에 나오는 주요한 이슈 아니면 굳이 알필요없지 않을까 싶다.
				ㄴ css도 마찬가지. 모르긴몰라도 사람들에 의해 어떤 문법이 만들어졌고, dom상에 적용되는 언어라니까 dom을 다루는 브라우져같은 프로그램에서 내부적으로 동작하면서 css의 내용중 해당 dom부분에 css rule대로 display를 입혀주는
					그런 프로그램이겠지.
				ㄴ ajax도 마찬가지, el도 마찬가지.
				ㄴ 이렇게 되면 굳이 내부동작원리 알려고 애쓸거없이 그냥 사용법만 잘익혀서 사용하면 되는거 아닌가?
				ㄴ 물론 아예 필요없는건 아니고. 굳이 특별한 이유없으면 하나하나 궁금해할 이유가 없는거니까.

		</pre>
	</pre>

    <br/>
    서비스 기획? 도메인?<button>more</button>
    <pre>
        ㅡ 본인인증?, 인증?
            ㄴ 종류
                ㄴ 휴대폰 본인인증
                    ㄴ ??? 당사자의 개인 정보를 가지고 있고, 그 당사자의 휴대폰을 실소유하고 있는지 확인?
                        개인정보 입력과 그 사람 소유의 휴대폰으로 sms인증을 통하여?
                    ㄴ 휴대폰 통신사를 통하여 진행.
                ㄴ 실명인증
                    ㄴ ??? 당사자가 실존하는 사람인지 확인?
                        개인정보 입력을 통해 확인?
                    ㄴ 신용평가기관을 통하여 진행?
                ㄴ 휴대폰 인증
                    ㄴ 실제로 있는 번호인지 확인?
                    ㄴ sms 인증번호 확인을 통해 진행?
                ㄴ 이메일 인증
                    ㄴ 실제로 있는 이메일인지 확인?
                    ㄴ 이메일 인증번호 확인을 통해 진행?
            ㄴ 서비스에서 굳이 본인을 인증할 필요가 없다면 할 필요 없다.
            ㄴ 본인 인증이 필요한 경우
                ㄴ 서비스 특성상 본인 인증이 필요할 때
                    ㄴ ex ) 법적인 이유, ???도용 및 부정 거래 방지?
                ㄴ 진정 정보 수집?
                    ㄴ 실제 서비스 이용자들에 대한 정보를 수집하고자 하는 것?
            ㄴ 본인인증은 ux관점에서 허들로 작용할 수 있다.
            ㄴ 통상적으로 말하는 본인인증의 필요성 및 장점
                ㄴ 주민등록번호 생성기를 통한 회원가입 및 타인 주민등록번호 도용을 방지할 수 있습니다.
                ㄴ 정보통신망 이용에 관한 법률에 따라 일정규모 이상의 방문자를 가진 인터넷사이트는 의무적으로 실명확인서비스를 도입해야 합니다.
                ㄴ 인터넷 상거래가 일어나는 쇼핑몰, 유료 사이트 등은 회원들의 실명 확인을 통해 명의도용 등의 상거래 상의 문제를 예방할 수 있습니다.
                ㄴ 성인인증이 필요한 사이트는 미성년자의 실명확인을 통해 접근을 사전 차단할 수 있습니다.
                ㄴ 실명이 확인된 고객 데이터를 기반으로 실제 고객에게만 CRM활동을 함으로써 마케팅비용을 절감할 수 있습니다.
                ㄴ 가명을 이용하여 가입한 회원들의 익명성에 의한 허위 사실의 유포 및 무분별한 비방을 막을 수 있습니다
            ㄴ ex )
                ㄴ


    </pre>


	<script src="https://code.jquery.com/jquery-latest.js"></script>
	<script>
		$('button').next('pre').css('display','none');
		$('button').on('click',function(e){
			if($(this).next('pre').css('display')=='none'){
				$(this).next('pre').css('display','block');
				$(this).text('접기');
			}
			else{
				$(this).next('pre').css('display','none');
				$(this).text('펼치기');
			}
		})

		$('#showAll').on('click', function(e){
			$('pre').css('display','block');
		})
	</script>
</body>
</html>
